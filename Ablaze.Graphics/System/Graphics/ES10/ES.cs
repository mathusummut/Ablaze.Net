//Ported from OpenTK, and excellent library.

#pragma warning disable 1572
#pragma warning disable 1573

using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

namespace System.Graphics.ES10 {
	/// <summary>
	/// An abstraction layer for all OpenGL|ES 1.0 functions.
	/// </summary>
	[Security.SuppressUnmanagedCodeSecurity]
	public static partial class GL {
		/// <summary>
		/// The name of the OpenGL|ES library.
		/// </summary>
		public const string Library = "libGLES.dll";
		/// <summary>
		/// The native prefix of every GL function.
		/// </summary>
		public const string Prefix = "gl";



		/// <summary>[requires: v1.0 and 1.0]
		/// Select active texture unit
		/// </summary>
		/// <param name="texture">
		/// <para>
		/// Specifies which texture unit to make active. The number of texture units is implementation dependent, but must be at least two. texture must be one of GL_TEXTUREi, where i ranges from 0 (GL_MAX_COMBINED_TEXTURE_IMAGE_UNITS - 1). The initial value is GL_TEXTURE0.
		/// </para>
		/// </param>
		//[AutoGenerated(Category = "1.0", Version = "1.0", EntryPoint = "glActiveTexture")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
				void ActiveTexture(System.Graphics.ES10.All texture) {
			Delegates.glActiveTexture((System.Graphics.ES10.All) texture);
		}


		/// <summary>[requires: v1.0 and 1.0]
		/// Specify the alpha test function
		/// </summary>
		/// <param name="func">
		/// <para>
		/// Specifies the alpha comparison function. Symbolic constants GL_NEVER, GL_LESS, GL_EQUAL, GL_LEQUAL, GL_GREATER, GL_NOTEQUAL, GL_GEQUAL, and GL_ALWAYS are accepted. The initial value is GL_ALWAYS.
		/// </para>
		/// </param>
		/// <param name="ref">
		/// <para>
		/// Specifies the reference value that incoming alpha values are compared to. This value is clamped to the range [0,1], where 0 represents the lowest possible alpha value and 1 the highest possible value. The initial reference value is 0.
		/// </para>
		/// </param>
		//[AutoGenerated(Category = "1.0", Version = "1.0", EntryPoint = "glAlphaFunc")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
				void AlphaFunc(System.Graphics.ES10.All func, Single @ref) {
			Delegates.glAlphaFunc((System.Graphics.ES10.All) func, (Single) @ref);
		}

		/// <summary>[requires: v1.0 and 1.0]</summary>
		//[AutoGenerated(Category = "1.0", Version = "1.0", EntryPoint = "glAlphaFuncx")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
				void AlphaFuncx(System.Graphics.ES10.All func, int @ref) {
			Delegates.glAlphaFuncx((System.Graphics.ES10.All) func, (int) @ref);
		}


		/// <summary>[requires: v1.0 and 1.0]
		/// Bind a named texture to a texturing target
		/// </summary>
		/// <param name="target">
		/// <para>
		/// Specifies the target to which the texture is bound. Must be either GL_TEXTURE_1D, GL_TEXTURE_2D, GL_TEXTURE_3D, or GL_TEXTURE_1D_ARRAY, GL_TEXTURE_2D_ARRAY, GL_TEXTURE_RECTANGLE, GL_TEXTURE_CUBE_MAP, GL_TEXTURE_2D_MULTISAMPLE or GL_TEXTURE_2D_MULTISAMPLE_ARRAY.
		/// </para>
		/// </param>
		/// <param name="texture">
		/// <para>
		/// Specifies the name of a texture.
		/// </para>
		/// </param>
		//[AutoGenerated(Category = "1.0", Version = "1.0", EntryPoint = "glBindTexture")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
				void BindTexture(System.Graphics.ES10.All target, Int32 texture) {
			Delegates.glBindTexture((System.Graphics.ES10.All) target, (UInt32) texture);
		}


		/// <summary>[requires: v1.0 and 1.0]
		/// Bind a named texture to a texturing target
		/// </summary>
		/// <param name="target">
		/// <para>
		/// Specifies the target to which the texture is bound. Must be either GL_TEXTURE_1D, GL_TEXTURE_2D, GL_TEXTURE_3D, or GL_TEXTURE_1D_ARRAY, GL_TEXTURE_2D_ARRAY, GL_TEXTURE_RECTANGLE, GL_TEXTURE_CUBE_MAP, GL_TEXTURE_2D_MULTISAMPLE or GL_TEXTURE_2D_MULTISAMPLE_ARRAY.
		/// </para>
		/// </param>
		/// <param name="texture">
		/// <para>
		/// Specifies the name of a texture.
		/// </para>
		/// </param>
		[System.CLSCompliant(false)]
		//[AutoGenerated(Category = "1.0", Version = "1.0", EntryPoint = "glBindTexture")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
		void BindTexture(System.Graphics.ES10.All target, UInt32 texture) {
			Delegates.glBindTexture((System.Graphics.ES10.All) target, (UInt32) texture);
		}


		/// <summary>[requires: v1.0 and 1.0]
		/// Specify pixel arithmetic
		/// </summary>
		/// <param name="sfactor">
		/// <para>
		/// Specifies how the red, green, blue, and alpha source blending factors are computed. The initial value is GL_ONE.
		/// </para>
		/// </param>
		/// <param name="dfactor">
		/// <para>
		/// Specifies how the red, green, blue, and alpha destination blending factors are computed. The following symbolic constants are accepted: GL_ZERO, GL_ONE, GL_SRC_COLOR, GL_ONE_MINUS_SRC_COLOR, GL_DST_COLOR, GL_ONE_MINUS_DST_COLOR, GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA, GL_DST_ALPHA, GL_ONE_MINUS_DST_ALPHA. GL_CONSTANT_COLOR, GL_ONE_MINUS_CONSTANT_COLOR, GL_CONSTANT_ALPHA, and GL_ONE_MINUS_CONSTANT_ALPHA. The initial value is GL_ZERO.
		/// </para>
		/// </param>
		//[AutoGenerated(Category = "1.0", Version = "1.0", EntryPoint = "glBlendFunc")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
				void BlendFunc(System.Graphics.ES10.All sfactor, System.Graphics.ES10.All dfactor) {
			Delegates.glBlendFunc((System.Graphics.ES10.All) sfactor, (System.Graphics.ES10.All) dfactor);
		}


		/// <summary>[requires: v1.0 and 1.0]
		/// Clear buffers to preset values
		/// </summary>
		/// <param name="mask">
		/// <para>
		/// Bitwise OR of masks that indicate the buffers to be cleared. The three masks are GL_COLOR_BUFFER_BIT, GL_DEPTH_BUFFER_BIT, and GL_STENCIL_BUFFER_BIT.
		/// </para>
		/// </param>
		//[AutoGenerated(Category = "1.0", Version = "1.0", EntryPoint = "glClear")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
				void Clear(Int32 mask) {
			Delegates.glClear((UInt32) mask);
		}


		/// <summary>[requires: v1.0 and 1.0]
		/// Clear buffers to preset values
		/// </summary>
		/// <param name="mask">
		/// <para>
		/// Bitwise OR of masks that indicate the buffers to be cleared. The three masks are GL_COLOR_BUFFER_BIT, GL_DEPTH_BUFFER_BIT, and GL_STENCIL_BUFFER_BIT.
		/// </para>
		/// </param>
		[System.CLSCompliant(false)]
		//[AutoGenerated(Category = "1.0", Version = "1.0", EntryPoint = "glClear")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
		void Clear(UInt32 mask) {
			Delegates.glClear((UInt32) mask);
		}


		/// <summary>[requires: v1.0 and 1.0]
		/// Specify clear values for the color buffers
		/// </summary>
		//[AutoGenerated(Category = "1.0", Version = "1.0", EntryPoint = "glClearColor")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
				void ClearColor(Single red, Single green, Single blue, Single alpha) {
			Delegates.glClearColor((Single) red, (Single) green, (Single) blue, (Single) alpha);
		}

		/// <summary>[requires: v1.0 and 1.0]</summary>
		//[AutoGenerated(Category = "1.0", Version = "1.0", EntryPoint = "glClearColorx")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
				void ClearColorx(int red, int green, int blue, int alpha) {
			Delegates.glClearColorx((int) red, (int) green, (int) blue, (int) alpha);
		}


		/// <summary>[requires: v1.0 and 1.0]
		/// Specify the clear value for the depth buffer
		/// </summary>
		/// <param name="depth">
		/// <para>
		/// Specifies the depth value used when the depth buffer is cleared. The initial value is 1.
		/// </para>
		/// </param>
		//[AutoGenerated(Category = "1.0", Version = "1.0", EntryPoint = "glClearDepthf")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
				void ClearDepth(Single depth) {
			Delegates.glClearDepthf((Single) depth);
		}

		/// <summary>[requires: v1.0 and 1.0]</summary>
		//[AutoGenerated(Category = "1.0", Version = "1.0", EntryPoint = "glClearDepthx")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
				void ClearDepthx(int depth) {
			Delegates.glClearDepthx((int) depth);
		}


		/// <summary>[requires: v1.0 and 1.0]
		/// Specify the clear value for the stencil buffer
		/// </summary>
		/// <param name="s">
		/// <para>
		/// Specifies the index used when the stencil buffer is cleared. The initial value is 0.
		/// </para>
		/// </param>
		//[AutoGenerated(Category = "1.0", Version = "1.0", EntryPoint = "glClearStencil")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
				void ClearStencil(Int32 s) {
			Delegates.glClearStencil((Int32) s);
		}


		/// <summary>[requires: v1.0 and 1.0]
		/// Select active texture unit
		/// </summary>
		/// <param name="texture">
		/// <para>
		/// Specifies which texture unit to make active. The number of texture units is implementation dependent, but must be at least two. texture must be one of GL_TEXTURE, where i ranges from 0 to the value of GL_MAX_TEXTURE_COORDS - 1, which is an implementation-dependent value. The initial value is GL_TEXTURE0.
		/// </para>
		/// </param>
		//[AutoGenerated(Category = "1.0", Version = "1.0", EntryPoint = "glClientActiveTexture")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
				void ClientActiveTexture(System.Graphics.ES10.All texture) {
			Delegates.glClientActiveTexture((System.Graphics.ES10.All) texture);
		}


		/// <summary>[requires: v1.0 and 1.0]
		/// Set the current color
		/// </summary>
		//[AutoGenerated(Category = "1.0", Version = "1.0", EntryPoint = "glColor4f")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
				void Color4(Single red, Single green, Single blue, Single alpha) {
			Delegates.glColor4f((Single) red, (Single) green, (Single) blue, (Single) alpha);
		}

		/// <summary>[requires: v1.0 and 1.0]</summary>
		//[AutoGenerated(Category = "1.0", Version = "1.0", EntryPoint = "glColor4x")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
				void Color4x(int red, int green, int blue, int alpha) {
			Delegates.glColor4x((int) red, (int) green, (int) blue, (int) alpha);
		}


		/// <summary>[requires: v1.0 and 1.0]
		/// Enable and disable writing of frame buffer color components
		/// </summary>
		//[AutoGenerated(Category = "1.0", Version = "1.0", EntryPoint = "glColorMask")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
				void ColorMask(bool red, bool green, bool blue, bool alpha) {
			Delegates.glColorMask((bool) red, (bool) green, (bool) blue, (bool) alpha);
		}


		/// <summary>[requires: v1.0 and 1.0]
		/// Define an array of colors
		/// </summary>
		/// <param name="size">
		/// <para>
		/// Specifies the number of components per color. Must be 3 or 4. The initial value is 4.
		/// </para>
		/// </param>
		/// <param name="type">
		/// <para>
		/// Specifies the data type of each color component in the array. Symbolic constants GL_BYTE, GL_UNSIGNED_BYTE, GL_SHORT, GL_UNSIGNED_SHORT, GL_INT, GL_UNSIGNED_INT, GL_FLOAT, and GL_DOUBLE are accepted. The initial value is GL_FLOAT.
		/// </para>
		/// </param>
		/// <param name="stride">
		/// <para>
		/// Specifies the byte offset between consecutive colors. If stride is 0, the colors are understood to be tightly packed in the array. The initial value is 0.
		/// </para>
		/// </param>
		/// <param name="pointer">
		/// <para>
		/// Specifies a pointer to the first component of the first color element in the array. The initial value is 0.
		/// </para>
		/// </param>
		//[AutoGenerated(Category = "1.0", Version = "1.0", EntryPoint = "glColorPointer")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
				void ColorPointer(Int32 size, System.Graphics.ES10.All type, Int32 stride, IntPtr pointer) {
			Delegates.glColorPointer((Int32) size, (System.Graphics.ES10.All) type, (Int32) stride, (IntPtr) pointer);
		}


		/// <summary>[requires: v1.0 and 1.0]
		/// Define an array of colors
		/// </summary>
		/// <param name="size">
		/// <para>
		/// Specifies the number of components per color. Must be 3 or 4. The initial value is 4.
		/// </para>
		/// </param>
		/// <param name="type">
		/// <para>
		/// Specifies the data type of each color component in the array. Symbolic constants GL_BYTE, GL_UNSIGNED_BYTE, GL_SHORT, GL_UNSIGNED_SHORT, GL_INT, GL_UNSIGNED_INT, GL_FLOAT, and GL_DOUBLE are accepted. The initial value is GL_FLOAT.
		/// </para>
		/// </param>
		/// <param name="stride">
		/// <para>
		/// Specifies the byte offset between consecutive colors. If stride is 0, the colors are understood to be tightly packed in the array. The initial value is 0.
		/// </para>
		/// </param>
		/// <param name="pointer">
		/// <para>
		/// Specifies a pointer to the first component of the first color element in the array. The initial value is 0.
		/// </para>
		/// </param>
		//[AutoGenerated(Category = "1.0", Version = "1.0", EntryPoint = "glColorPointer")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
				void ColorPointer<T3>(Int32 size, System.Graphics.ES10.All type, Int32 stride, [InAttribute, OutAttribute] T3[] pointer)
					where T3 : struct {
			GCHandle pointer_ptr = GCHandle.Alloc(pointer, GCHandleType.Pinned);
			try {
				Delegates.glColorPointer((Int32) size, (System.Graphics.ES10.All) type, (Int32) stride, (IntPtr) pointer_ptr.AddrOfPinnedObject());
			} finally {
				pointer_ptr.Free();
			}
		}


		/// <summary>[requires: v1.0 and 1.0]
		/// Define an array of colors
		/// </summary>
		/// <param name="size">
		/// <para>
		/// Specifies the number of components per color. Must be 3 or 4. The initial value is 4.
		/// </para>
		/// </param>
		/// <param name="type">
		/// <para>
		/// Specifies the data type of each color component in the array. Symbolic constants GL_BYTE, GL_UNSIGNED_BYTE, GL_SHORT, GL_UNSIGNED_SHORT, GL_INT, GL_UNSIGNED_INT, GL_FLOAT, and GL_DOUBLE are accepted. The initial value is GL_FLOAT.
		/// </para>
		/// </param>
		/// <param name="stride">
		/// <para>
		/// Specifies the byte offset between consecutive colors. If stride is 0, the colors are understood to be tightly packed in the array. The initial value is 0.
		/// </para>
		/// </param>
		/// <param name="pointer">
		/// <para>
		/// Specifies a pointer to the first component of the first color element in the array. The initial value is 0.
		/// </para>
		/// </param>
		//[AutoGenerated(Category = "1.0", Version = "1.0", EntryPoint = "glColorPointer")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
				void ColorPointer<T3>(Int32 size, System.Graphics.ES10.All type, Int32 stride, [InAttribute, OutAttribute] T3[,] pointer)
					where T3 : struct {
			GCHandle pointer_ptr = GCHandle.Alloc(pointer, GCHandleType.Pinned);
			try {
				Delegates.glColorPointer((Int32) size, (System.Graphics.ES10.All) type, (Int32) stride, (IntPtr) pointer_ptr.AddrOfPinnedObject());
			} finally {
				pointer_ptr.Free();
			}
		}


		/// <summary>[requires: v1.0 and 1.0]
		/// Define an array of colors
		/// </summary>
		/// <param name="size">
		/// <para>
		/// Specifies the number of components per color. Must be 3 or 4. The initial value is 4.
		/// </para>
		/// </param>
		/// <param name="type">
		/// <para>
		/// Specifies the data type of each color component in the array. Symbolic constants GL_BYTE, GL_UNSIGNED_BYTE, GL_SHORT, GL_UNSIGNED_SHORT, GL_INT, GL_UNSIGNED_INT, GL_FLOAT, and GL_DOUBLE are accepted. The initial value is GL_FLOAT.
		/// </para>
		/// </param>
		/// <param name="stride">
		/// <para>
		/// Specifies the byte offset between consecutive colors. If stride is 0, the colors are understood to be tightly packed in the array. The initial value is 0.
		/// </para>
		/// </param>
		/// <param name="pointer">
		/// <para>
		/// Specifies a pointer to the first component of the first color element in the array. The initial value is 0.
		/// </para>
		/// </param>
		//[AutoGenerated(Category = "1.0", Version = "1.0", EntryPoint = "glColorPointer")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
				void ColorPointer<T3>(Int32 size, System.Graphics.ES10.All type, Int32 stride, [InAttribute, OutAttribute] T3[,,] pointer)
					where T3 : struct {
			GCHandle pointer_ptr = GCHandle.Alloc(pointer, GCHandleType.Pinned);
			try {
				Delegates.glColorPointer((Int32) size, (System.Graphics.ES10.All) type, (Int32) stride, (IntPtr) pointer_ptr.AddrOfPinnedObject());
			} finally {
				pointer_ptr.Free();
			}
		}


		/// <summary>[requires: v1.0 and 1.0]
		/// Define an array of colors
		/// </summary>
		/// <param name="size">
		/// <para>
		/// Specifies the number of components per color. Must be 3 or 4. The initial value is 4.
		/// </para>
		/// </param>
		/// <param name="type">
		/// <para>
		/// Specifies the data type of each color component in the array. Symbolic constants GL_BYTE, GL_UNSIGNED_BYTE, GL_SHORT, GL_UNSIGNED_SHORT, GL_INT, GL_UNSIGNED_INT, GL_FLOAT, and GL_DOUBLE are accepted. The initial value is GL_FLOAT.
		/// </para>
		/// </param>
		/// <param name="stride">
		/// <para>
		/// Specifies the byte offset between consecutive colors. If stride is 0, the colors are understood to be tightly packed in the array. The initial value is 0.
		/// </para>
		/// </param>
		/// <param name="pointer">
		/// <para>
		/// Specifies a pointer to the first component of the first color element in the array. The initial value is 0.
		/// </para>
		/// </param>
		//[AutoGenerated(Category = "1.0", Version = "1.0", EntryPoint = "glColorPointer")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
				void ColorPointer<T3>(Int32 size, System.Graphics.ES10.All type, Int32 stride, [InAttribute, OutAttribute] ref T3 pointer)
					where T3 : struct {
			GCHandle pointer_ptr = GCHandle.Alloc(pointer, GCHandleType.Pinned);
			try {
				Delegates.glColorPointer((Int32) size, (System.Graphics.ES10.All) type, (Int32) stride, (IntPtr) pointer_ptr.AddrOfPinnedObject());
				pointer = (T3) pointer_ptr.Target;
			} finally {
				pointer_ptr.Free();
			}
		}


		/// <summary>[requires: v1.0 and 1.0]
		/// Specify a two-dimensional texture image in a compressed format
		/// </summary>
		/// <param name="target">
		/// <para>
		/// Specifies the target texture. Must be GL_TEXTURE_2D, GL_PROXY_TEXTURE_2D, GL_TEXTURE_1D_ARRAY, GL_PROXY_TEXTURE_1D_ARRAY, GL_TEXTURE_CUBE_MAP_POSITIVE_X, GL_TEXTURE_CUBE_MAP_NEGATIVE_X, GL_TEXTURE_CUBE_MAP_POSITIVE_Y, GL_TEXTURE_CUBE_MAP_NEGATIVE_Y, GL_TEXTURE_CUBE_MAP_POSITIVE_Z, GL_TEXTURE_CUBE_MAP_NEGATIVE_Z, or GL_PROXY_TEXTURE_CUBE_MAP.
		/// </para>
		/// </param>
		/// <param name="level">
		/// <para>
		/// Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.
		/// </para>
		/// </param>
		/// <param name="internalformat">
		/// <para>
		/// Specifies the format of the compressed image data stored at address data.
		/// </para>
		/// </param>
		/// <param name="width">
		/// <para>
		/// Specifies the width of the texture image. All implementations support 2D texture images that are at least 64 texels wide and cube-mapped texture images that are at least 16 texels wide.
		/// </para>
		/// </param>
		/// <param name="height">
		/// <para>
		/// Specifies the height of the texture image. All implementations support 2D texture images that are at least 64 texels high and cube-mapped texture images that are at least 16 texels high.
		/// </para>
		/// </param>
		/// <param name="border">
		/// <para>
		/// This value must be 0.
		/// </para>
		/// </param>
		/// <param name="imageSize">
		/// <para>
		/// Specifies the number of unsigned bytes of image data starting at the address specified by data.
		/// </para>
		/// </param>
		/// <param name="data">
		/// <para>
		/// Specifies a pointer to the compressed image data in memory.
		/// </para>
		/// </param>
		//[AutoGenerated(Category = "1.0", Version = "1.0", EntryPoint = "glCompressedTexImage2D")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
				void CompressedTexImage2D(System.Graphics.ES10.All target, Int32 level, System.Graphics.ES10.All internalformat, Int32 width, Int32 height, Int32 border, Int32 imageSize, IntPtr data) {
			Delegates.glCompressedTexImage2D((System.Graphics.ES10.All) target, (Int32) level, (System.Graphics.ES10.All) internalformat, (Int32) width, (Int32) height, (Int32) border, (Int32) imageSize, (IntPtr) data);
		}


		/// <summary>[requires: v1.0 and 1.0]
		/// Specify a two-dimensional texture image in a compressed format
		/// </summary>
		/// <param name="target">
		/// <para>
		/// Specifies the target texture. Must be GL_TEXTURE_2D, GL_PROXY_TEXTURE_2D, GL_TEXTURE_1D_ARRAY, GL_PROXY_TEXTURE_1D_ARRAY, GL_TEXTURE_CUBE_MAP_POSITIVE_X, GL_TEXTURE_CUBE_MAP_NEGATIVE_X, GL_TEXTURE_CUBE_MAP_POSITIVE_Y, GL_TEXTURE_CUBE_MAP_NEGATIVE_Y, GL_TEXTURE_CUBE_MAP_POSITIVE_Z, GL_TEXTURE_CUBE_MAP_NEGATIVE_Z, or GL_PROXY_TEXTURE_CUBE_MAP.
		/// </para>
		/// </param>
		/// <param name="level">
		/// <para>
		/// Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.
		/// </para>
		/// </param>
		/// <param name="internalformat">
		/// <para>
		/// Specifies the format of the compressed image data stored at address data.
		/// </para>
		/// </param>
		/// <param name="width">
		/// <para>
		/// Specifies the width of the texture image. All implementations support 2D texture images that are at least 64 texels wide and cube-mapped texture images that are at least 16 texels wide.
		/// </para>
		/// </param>
		/// <param name="height">
		/// <para>
		/// Specifies the height of the texture image. All implementations support 2D texture images that are at least 64 texels high and cube-mapped texture images that are at least 16 texels high.
		/// </para>
		/// </param>
		/// <param name="border">
		/// <para>
		/// This value must be 0.
		/// </para>
		/// </param>
		/// <param name="imageSize">
		/// <para>
		/// Specifies the number of unsigned bytes of image data starting at the address specified by data.
		/// </para>
		/// </param>
		/// <param name="data">
		/// <para>
		/// Specifies a pointer to the compressed image data in memory.
		/// </para>
		/// </param>
		//[AutoGenerated(Category = "1.0", Version = "1.0", EntryPoint = "glCompressedTexImage2D")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
				void CompressedTexImage2D<T7>(System.Graphics.ES10.All target, Int32 level, System.Graphics.ES10.All internalformat, Int32 width, Int32 height, Int32 border, Int32 imageSize, [InAttribute, OutAttribute] T7[] data)
					where T7 : struct {
			GCHandle data_ptr = GCHandle.Alloc(data, GCHandleType.Pinned);
			try {
				Delegates.glCompressedTexImage2D((System.Graphics.ES10.All) target, (Int32) level, (System.Graphics.ES10.All) internalformat, (Int32) width, (Int32) height, (Int32) border, (Int32) imageSize, (IntPtr) data_ptr.AddrOfPinnedObject());
			} finally {
				data_ptr.Free();
			}
		}


		/// <summary>[requires: v1.0 and 1.0]
		/// Specify a two-dimensional texture image in a compressed format
		/// </summary>
		/// <param name="target">
		/// <para>
		/// Specifies the target texture. Must be GL_TEXTURE_2D, GL_PROXY_TEXTURE_2D, GL_TEXTURE_1D_ARRAY, GL_PROXY_TEXTURE_1D_ARRAY, GL_TEXTURE_CUBE_MAP_POSITIVE_X, GL_TEXTURE_CUBE_MAP_NEGATIVE_X, GL_TEXTURE_CUBE_MAP_POSITIVE_Y, GL_TEXTURE_CUBE_MAP_NEGATIVE_Y, GL_TEXTURE_CUBE_MAP_POSITIVE_Z, GL_TEXTURE_CUBE_MAP_NEGATIVE_Z, or GL_PROXY_TEXTURE_CUBE_MAP.
		/// </para>
		/// </param>
		/// <param name="level">
		/// <para>
		/// Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.
		/// </para>
		/// </param>
		/// <param name="internalformat">
		/// <para>
		/// Specifies the format of the compressed image data stored at address data.
		/// </para>
		/// </param>
		/// <param name="width">
		/// <para>
		/// Specifies the width of the texture image. All implementations support 2D texture images that are at least 64 texels wide and cube-mapped texture images that are at least 16 texels wide.
		/// </para>
		/// </param>
		/// <param name="height">
		/// <para>
		/// Specifies the height of the texture image. All implementations support 2D texture images that are at least 64 texels high and cube-mapped texture images that are at least 16 texels high.
		/// </para>
		/// </param>
		/// <param name="border">
		/// <para>
		/// This value must be 0.
		/// </para>
		/// </param>
		/// <param name="imageSize">
		/// <para>
		/// Specifies the number of unsigned bytes of image data starting at the address specified by data.
		/// </para>
		/// </param>
		/// <param name="data">
		/// <para>
		/// Specifies a pointer to the compressed image data in memory.
		/// </para>
		/// </param>
		//[AutoGenerated(Category = "1.0", Version = "1.0", EntryPoint = "glCompressedTexImage2D")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
				void CompressedTexImage2D<T7>(System.Graphics.ES10.All target, Int32 level, System.Graphics.ES10.All internalformat, Int32 width, Int32 height, Int32 border, Int32 imageSize, [InAttribute, OutAttribute] T7[,] data)
					where T7 : struct {
			GCHandle data_ptr = GCHandle.Alloc(data, GCHandleType.Pinned);
			try {
				Delegates.glCompressedTexImage2D((System.Graphics.ES10.All) target, (Int32) level, (System.Graphics.ES10.All) internalformat, (Int32) width, (Int32) height, (Int32) border, (Int32) imageSize, (IntPtr) data_ptr.AddrOfPinnedObject());
			} finally {
				data_ptr.Free();
			}
		}


		/// <summary>[requires: v1.0 and 1.0]
		/// Specify a two-dimensional texture image in a compressed format
		/// </summary>
		/// <param name="target">
		/// <para>
		/// Specifies the target texture. Must be GL_TEXTURE_2D, GL_PROXY_TEXTURE_2D, GL_TEXTURE_1D_ARRAY, GL_PROXY_TEXTURE_1D_ARRAY, GL_TEXTURE_CUBE_MAP_POSITIVE_X, GL_TEXTURE_CUBE_MAP_NEGATIVE_X, GL_TEXTURE_CUBE_MAP_POSITIVE_Y, GL_TEXTURE_CUBE_MAP_NEGATIVE_Y, GL_TEXTURE_CUBE_MAP_POSITIVE_Z, GL_TEXTURE_CUBE_MAP_NEGATIVE_Z, or GL_PROXY_TEXTURE_CUBE_MAP.
		/// </para>
		/// </param>
		/// <param name="level">
		/// <para>
		/// Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.
		/// </para>
		/// </param>
		/// <param name="internalformat">
		/// <para>
		/// Specifies the format of the compressed image data stored at address data.
		/// </para>
		/// </param>
		/// <param name="width">
		/// <para>
		/// Specifies the width of the texture image. All implementations support 2D texture images that are at least 64 texels wide and cube-mapped texture images that are at least 16 texels wide.
		/// </para>
		/// </param>
		/// <param name="height">
		/// <para>
		/// Specifies the height of the texture image. All implementations support 2D texture images that are at least 64 texels high and cube-mapped texture images that are at least 16 texels high.
		/// </para>
		/// </param>
		/// <param name="border">
		/// <para>
		/// This value must be 0.
		/// </para>
		/// </param>
		/// <param name="imageSize">
		/// <para>
		/// Specifies the number of unsigned bytes of image data starting at the address specified by data.
		/// </para>
		/// </param>
		/// <param name="data">
		/// <para>
		/// Specifies a pointer to the compressed image data in memory.
		/// </para>
		/// </param>
		//[AutoGenerated(Category = "1.0", Version = "1.0", EntryPoint = "glCompressedTexImage2D")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
				void CompressedTexImage2D<T7>(System.Graphics.ES10.All target, Int32 level, System.Graphics.ES10.All internalformat, Int32 width, Int32 height, Int32 border, Int32 imageSize, [InAttribute, OutAttribute] T7[,,] data)
					where T7 : struct {
			GCHandle data_ptr = GCHandle.Alloc(data, GCHandleType.Pinned);
			try {
				Delegates.glCompressedTexImage2D((System.Graphics.ES10.All) target, (Int32) level, (System.Graphics.ES10.All) internalformat, (Int32) width, (Int32) height, (Int32) border, (Int32) imageSize, (IntPtr) data_ptr.AddrOfPinnedObject());
			} finally {
				data_ptr.Free();
			}
		}


		/// <summary>[requires: v1.0 and 1.0]
		/// Specify a two-dimensional texture image in a compressed format
		/// </summary>
		/// <param name="target">
		/// <para>
		/// Specifies the target texture. Must be GL_TEXTURE_2D, GL_PROXY_TEXTURE_2D, GL_TEXTURE_1D_ARRAY, GL_PROXY_TEXTURE_1D_ARRAY, GL_TEXTURE_CUBE_MAP_POSITIVE_X, GL_TEXTURE_CUBE_MAP_NEGATIVE_X, GL_TEXTURE_CUBE_MAP_POSITIVE_Y, GL_TEXTURE_CUBE_MAP_NEGATIVE_Y, GL_TEXTURE_CUBE_MAP_POSITIVE_Z, GL_TEXTURE_CUBE_MAP_NEGATIVE_Z, or GL_PROXY_TEXTURE_CUBE_MAP.
		/// </para>
		/// </param>
		/// <param name="level">
		/// <para>
		/// Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.
		/// </para>
		/// </param>
		/// <param name="internalformat">
		/// <para>
		/// Specifies the format of the compressed image data stored at address data.
		/// </para>
		/// </param>
		/// <param name="width">
		/// <para>
		/// Specifies the width of the texture image. All implementations support 2D texture images that are at least 64 texels wide and cube-mapped texture images that are at least 16 texels wide.
		/// </para>
		/// </param>
		/// <param name="height">
		/// <para>
		/// Specifies the height of the texture image. All implementations support 2D texture images that are at least 64 texels high and cube-mapped texture images that are at least 16 texels high.
		/// </para>
		/// </param>
		/// <param name="border">
		/// <para>
		/// This value must be 0.
		/// </para>
		/// </param>
		/// <param name="imageSize">
		/// <para>
		/// Specifies the number of unsigned bytes of image data starting at the address specified by data.
		/// </para>
		/// </param>
		/// <param name="data">
		/// <para>
		/// Specifies a pointer to the compressed image data in memory.
		/// </para>
		/// </param>
		//[AutoGenerated(Category = "1.0", Version = "1.0", EntryPoint = "glCompressedTexImage2D")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
				void CompressedTexImage2D<T7>(System.Graphics.ES10.All target, Int32 level, System.Graphics.ES10.All internalformat, Int32 width, Int32 height, Int32 border, Int32 imageSize, [InAttribute, OutAttribute] ref T7 data)
					where T7 : struct {
			GCHandle data_ptr = GCHandle.Alloc(data, GCHandleType.Pinned);
			try {
				Delegates.glCompressedTexImage2D((System.Graphics.ES10.All) target, (Int32) level, (System.Graphics.ES10.All) internalformat, (Int32) width, (Int32) height, (Int32) border, (Int32) imageSize, (IntPtr) data_ptr.AddrOfPinnedObject());
				data = (T7) data_ptr.Target;
			} finally {
				data_ptr.Free();
			}
		}


		/// <summary>[requires: v1.0 and 1.0]
		/// Specify a two-dimensional texture subimage in a compressed format
		/// </summary>
		/// <param name="target">
		/// <para>
		/// Specifies the target texture. Must be GL_TEXTURE_2D, GL_TEXTURE_CUBE_MAP_POSITIVE_X, GL_TEXTURE_CUBE_MAP_NEGATIVE_X, GL_TEXTURE_CUBE_MAP_POSITIVE_Y, GL_TEXTURE_CUBE_MAP_NEGATIVE_Y, GL_TEXTURE_CUBE_MAP_POSITIVE_Z, or GL_TEXTURE_CUBE_MAP_NEGATIVE_Z.
		/// </para>
		/// </param>
		/// <param name="level">
		/// <para>
		/// Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.
		/// </para>
		/// </param>
		/// <param name="xoffset">
		/// <para>
		/// Specifies a texel offset in the x direction within the texture array.
		/// </para>
		/// </param>
		/// <param name="yoffset">
		/// <para>
		/// Specifies a texel offset in the y direction within the texture array.
		/// </para>
		/// </param>
		/// <param name="width">
		/// <para>
		/// Specifies the width of the texture subimage.
		/// </para>
		/// </param>
		/// <param name="height">
		/// <para>
		/// Specifies the height of the texture subimage.
		/// </para>
		/// </param>
		/// <param name="format">
		/// <para>
		/// Specifies the format of the compressed image data stored at address data.
		/// </para>
		/// </param>
		/// <param name="imageSize">
		/// <para>
		/// Specifies the number of unsigned bytes of image data starting at the address specified by data.
		/// </para>
		/// </param>
		/// <param name="data">
		/// <para>
		/// Specifies a pointer to the compressed image data in memory.
		/// </para>
		/// </param>
		//[AutoGenerated(Category = "1.0", Version = "1.0", EntryPoint = "glCompressedTexSubImage2D")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
				void CompressedTexSubImage2D(System.Graphics.ES10.All target, Int32 level, Int32 xoffset, Int32 yoffset, Int32 width, Int32 height, System.Graphics.ES10.All format, Int32 imageSize, IntPtr data) {
			Delegates.glCompressedTexSubImage2D((System.Graphics.ES10.All) target, (Int32) level, (Int32) xoffset, (Int32) yoffset, (Int32) width, (Int32) height, (System.Graphics.ES10.All) format, (Int32) imageSize, (IntPtr) data);
		}


		/// <summary>[requires: v1.0 and 1.0]
		/// Specify a two-dimensional texture subimage in a compressed format
		/// </summary>
		/// <param name="target">
		/// <para>
		/// Specifies the target texture. Must be GL_TEXTURE_2D, GL_TEXTURE_CUBE_MAP_POSITIVE_X, GL_TEXTURE_CUBE_MAP_NEGATIVE_X, GL_TEXTURE_CUBE_MAP_POSITIVE_Y, GL_TEXTURE_CUBE_MAP_NEGATIVE_Y, GL_TEXTURE_CUBE_MAP_POSITIVE_Z, or GL_TEXTURE_CUBE_MAP_NEGATIVE_Z.
		/// </para>
		/// </param>
		/// <param name="level">
		/// <para>
		/// Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.
		/// </para>
		/// </param>
		/// <param name="xoffset">
		/// <para>
		/// Specifies a texel offset in the x direction within the texture array.
		/// </para>
		/// </param>
		/// <param name="yoffset">
		/// <para>
		/// Specifies a texel offset in the y direction within the texture array.
		/// </para>
		/// </param>
		/// <param name="width">
		/// <para>
		/// Specifies the width of the texture subimage.
		/// </para>
		/// </param>
		/// <param name="height">
		/// <para>
		/// Specifies the height of the texture subimage.
		/// </para>
		/// </param>
		/// <param name="format">
		/// <para>
		/// Specifies the format of the compressed image data stored at address data.
		/// </para>
		/// </param>
		/// <param name="imageSize">
		/// <para>
		/// Specifies the number of unsigned bytes of image data starting at the address specified by data.
		/// </para>
		/// </param>
		/// <param name="data">
		/// <para>
		/// Specifies a pointer to the compressed image data in memory.
		/// </para>
		/// </param>
		//[AutoGenerated(Category = "1.0", Version = "1.0", EntryPoint = "glCompressedTexSubImage2D")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
				void CompressedTexSubImage2D<T8>(System.Graphics.ES10.All target, Int32 level, Int32 xoffset, Int32 yoffset, Int32 width, Int32 height, System.Graphics.ES10.All format, Int32 imageSize, [InAttribute, OutAttribute] T8[] data)
					where T8 : struct {
			GCHandle data_ptr = GCHandle.Alloc(data, GCHandleType.Pinned);
			try {
				Delegates.glCompressedTexSubImage2D((System.Graphics.ES10.All) target, (Int32) level, (Int32) xoffset, (Int32) yoffset, (Int32) width, (Int32) height, (System.Graphics.ES10.All) format, (Int32) imageSize, (IntPtr) data_ptr.AddrOfPinnedObject());
			} finally {
				data_ptr.Free();
			}
		}


		/// <summary>[requires: v1.0 and 1.0]
		/// Specify a two-dimensional texture subimage in a compressed format
		/// </summary>
		/// <param name="target">
		/// <para>
		/// Specifies the target texture. Must be GL_TEXTURE_2D, GL_TEXTURE_CUBE_MAP_POSITIVE_X, GL_TEXTURE_CUBE_MAP_NEGATIVE_X, GL_TEXTURE_CUBE_MAP_POSITIVE_Y, GL_TEXTURE_CUBE_MAP_NEGATIVE_Y, GL_TEXTURE_CUBE_MAP_POSITIVE_Z, or GL_TEXTURE_CUBE_MAP_NEGATIVE_Z.
		/// </para>
		/// </param>
		/// <param name="level">
		/// <para>
		/// Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.
		/// </para>
		/// </param>
		/// <param name="xoffset">
		/// <para>
		/// Specifies a texel offset in the x direction within the texture array.
		/// </para>
		/// </param>
		/// <param name="yoffset">
		/// <para>
		/// Specifies a texel offset in the y direction within the texture array.
		/// </para>
		/// </param>
		/// <param name="width">
		/// <para>
		/// Specifies the width of the texture subimage.
		/// </para>
		/// </param>
		/// <param name="height">
		/// <para>
		/// Specifies the height of the texture subimage.
		/// </para>
		/// </param>
		/// <param name="format">
		/// <para>
		/// Specifies the format of the compressed image data stored at address data.
		/// </para>
		/// </param>
		/// <param name="imageSize">
		/// <para>
		/// Specifies the number of unsigned bytes of image data starting at the address specified by data.
		/// </para>
		/// </param>
		/// <param name="data">
		/// <para>
		/// Specifies a pointer to the compressed image data in memory.
		/// </para>
		/// </param>
		//[AutoGenerated(Category = "1.0", Version = "1.0", EntryPoint = "glCompressedTexSubImage2D")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
				void CompressedTexSubImage2D<T8>(System.Graphics.ES10.All target, Int32 level, Int32 xoffset, Int32 yoffset, Int32 width, Int32 height, System.Graphics.ES10.All format, Int32 imageSize, [InAttribute, OutAttribute] T8[,] data)
					where T8 : struct {
			GCHandle data_ptr = GCHandle.Alloc(data, GCHandleType.Pinned);
			try {
				Delegates.glCompressedTexSubImage2D((System.Graphics.ES10.All) target, (Int32) level, (Int32) xoffset, (Int32) yoffset, (Int32) width, (Int32) height, (System.Graphics.ES10.All) format, (Int32) imageSize, (IntPtr) data_ptr.AddrOfPinnedObject());
			} finally {
				data_ptr.Free();
			}
		}


		/// <summary>[requires: v1.0 and 1.0]
		/// Specify a two-dimensional texture subimage in a compressed format
		/// </summary>
		/// <param name="target">
		/// <para>
		/// Specifies the target texture. Must be GL_TEXTURE_2D, GL_TEXTURE_CUBE_MAP_POSITIVE_X, GL_TEXTURE_CUBE_MAP_NEGATIVE_X, GL_TEXTURE_CUBE_MAP_POSITIVE_Y, GL_TEXTURE_CUBE_MAP_NEGATIVE_Y, GL_TEXTURE_CUBE_MAP_POSITIVE_Z, or GL_TEXTURE_CUBE_MAP_NEGATIVE_Z.
		/// </para>
		/// </param>
		/// <param name="level">
		/// <para>
		/// Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.
		/// </para>
		/// </param>
		/// <param name="xoffset">
		/// <para>
		/// Specifies a texel offset in the x direction within the texture array.
		/// </para>
		/// </param>
		/// <param name="yoffset">
		/// <para>
		/// Specifies a texel offset in the y direction within the texture array.
		/// </para>
		/// </param>
		/// <param name="width">
		/// <para>
		/// Specifies the width of the texture subimage.
		/// </para>
		/// </param>
		/// <param name="height">
		/// <para>
		/// Specifies the height of the texture subimage.
		/// </para>
		/// </param>
		/// <param name="format">
		/// <para>
		/// Specifies the format of the compressed image data stored at address data.
		/// </para>
		/// </param>
		/// <param name="imageSize">
		/// <para>
		/// Specifies the number of unsigned bytes of image data starting at the address specified by data.
		/// </para>
		/// </param>
		/// <param name="data">
		/// <para>
		/// Specifies a pointer to the compressed image data in memory.
		/// </para>
		/// </param>
		//[AutoGenerated(Category = "1.0", Version = "1.0", EntryPoint = "glCompressedTexSubImage2D")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
				void CompressedTexSubImage2D<T8>(System.Graphics.ES10.All target, Int32 level, Int32 xoffset, Int32 yoffset, Int32 width, Int32 height, System.Graphics.ES10.All format, Int32 imageSize, [InAttribute, OutAttribute] T8[,,] data)
					where T8 : struct {
			GCHandle data_ptr = GCHandle.Alloc(data, GCHandleType.Pinned);
			try {
				Delegates.glCompressedTexSubImage2D((System.Graphics.ES10.All) target, (Int32) level, (Int32) xoffset, (Int32) yoffset, (Int32) width, (Int32) height, (System.Graphics.ES10.All) format, (Int32) imageSize, (IntPtr) data_ptr.AddrOfPinnedObject());
			} finally {
				data_ptr.Free();
			}
		}


		/// <summary>[requires: v1.0 and 1.0]
		/// Specify a two-dimensional texture subimage in a compressed format
		/// </summary>
		/// <param name="target">
		/// <para>
		/// Specifies the target texture. Must be GL_TEXTURE_2D, GL_TEXTURE_CUBE_MAP_POSITIVE_X, GL_TEXTURE_CUBE_MAP_NEGATIVE_X, GL_TEXTURE_CUBE_MAP_POSITIVE_Y, GL_TEXTURE_CUBE_MAP_NEGATIVE_Y, GL_TEXTURE_CUBE_MAP_POSITIVE_Z, or GL_TEXTURE_CUBE_MAP_NEGATIVE_Z.
		/// </para>
		/// </param>
		/// <param name="level">
		/// <para>
		/// Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.
		/// </para>
		/// </param>
		/// <param name="xoffset">
		/// <para>
		/// Specifies a texel offset in the x direction within the texture array.
		/// </para>
		/// </param>
		/// <param name="yoffset">
		/// <para>
		/// Specifies a texel offset in the y direction within the texture array.
		/// </para>
		/// </param>
		/// <param name="width">
		/// <para>
		/// Specifies the width of the texture subimage.
		/// </para>
		/// </param>
		/// <param name="height">
		/// <para>
		/// Specifies the height of the texture subimage.
		/// </para>
		/// </param>
		/// <param name="format">
		/// <para>
		/// Specifies the format of the compressed image data stored at address data.
		/// </para>
		/// </param>
		/// <param name="imageSize">
		/// <para>
		/// Specifies the number of unsigned bytes of image data starting at the address specified by data.
		/// </para>
		/// </param>
		/// <param name="data">
		/// <para>
		/// Specifies a pointer to the compressed image data in memory.
		/// </para>
		/// </param>
		//[AutoGenerated(Category = "1.0", Version = "1.0", EntryPoint = "glCompressedTexSubImage2D")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
				void CompressedTexSubImage2D<T8>(System.Graphics.ES10.All target, Int32 level, Int32 xoffset, Int32 yoffset, Int32 width, Int32 height, System.Graphics.ES10.All format, Int32 imageSize, [InAttribute, OutAttribute] ref T8 data)
					where T8 : struct {
			GCHandle data_ptr = GCHandle.Alloc(data, GCHandleType.Pinned);
			try {
				Delegates.glCompressedTexSubImage2D((System.Graphics.ES10.All) target, (Int32) level, (Int32) xoffset, (Int32) yoffset, (Int32) width, (Int32) height, (System.Graphics.ES10.All) format, (Int32) imageSize, (IntPtr) data_ptr.AddrOfPinnedObject());
				data = (T8) data_ptr.Target;
			} finally {
				data_ptr.Free();
			}
		}


		/// <summary>[requires: v1.0 and 1.0]
		/// Copy pixels into a 2D texture image
		/// </summary>
		/// <param name="target">
		/// <para>
		/// Specifies the target texture. Must be GL_TEXTURE_2D, GL_TEXTURE_CUBE_MAP_POSITIVE_X, GL_TEXTURE_CUBE_MAP_NEGATIVE_X, GL_TEXTURE_CUBE_MAP_POSITIVE_Y, GL_TEXTURE_CUBE_MAP_NEGATIVE_Y, GL_TEXTURE_CUBE_MAP_POSITIVE_Z, or GL_TEXTURE_CUBE_MAP_NEGATIVE_Z.
		/// </para>
		/// </param>
		/// <param name="level">
		/// <para>
		/// Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.
		/// </para>
		/// </param>
		/// <param name="internalformat">
		/// <para>
		/// Specifies the internal format of the texture. Must be one of the following symbolic constants: GL_COMPRESSED_RED, GL_COMPRESSED_RG, GL_COMPRESSED_RGB, GL_COMPRESSED_RGBA. GL_COMPRESSED_SRGB, GL_COMPRESSED_SRGB_ALPHA. GL_DEPTH_COMPONENT, GL_DEPTH_COMPONENT16, GL_DEPTH_COMPONENT24, GL_DEPTH_COMPONENT32, GL_RED, GL_RG, GL_RGB, GL_R3_G3_B2, GL_RGB4, GL_RGB5, GL_RGB8, GL_RGB10, GL_RGB12, GL_RGB16, GL_RGBA, GL_RGBA2, GL_RGBA4, GL_RGB5_A1, GL_RGBA8, GL_RGB10_A2, GL_RGBA12, GL_RGBA16, GL_SRGB, GL_SRGB8, GL_SRGB_ALPHA, or GL_SRGB8_ALPHA8.
		/// </para>
		/// </param>
		/// <param name="x">
		/// <para>
		/// Specify the window coordinates of the lower left corner of the rectangular region of pixels to be copied.
		/// </para>
		/// </param>
		/// <param name="y">
		/// <para>
		/// Specify the window coordinates of the lower left corner of the rectangular region of pixels to be copied.
		/// </para>
		/// </param>
		/// <param name="width">
		/// <para>
		/// Specifies the width of the texture image. Must be 0 or 2 sup n + 2 ( border ) for some integer .
		/// </para>
		/// </param>
		/// <param name="height">
		/// <para>
		/// Specifies the height of the texture image. Must be 0 or 2 sup m + 2 ( border ) for some integer .
		/// </para>
		/// </param>
		/// <param name="border">
		/// <para>
		/// Specifies the width of the border. Must be either 0 or 1.
		/// </para>
		/// </param>
		//[AutoGenerated(Category = "1.0", Version = "1.0", EntryPoint = "glCopyTexImage2D")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
				void CopyTexImage2D(System.Graphics.ES10.All target, Int32 level, System.Graphics.ES10.All internalformat, Int32 x, Int32 y, Int32 width, Int32 height, Int32 border) {
			Delegates.glCopyTexImage2D((System.Graphics.ES10.All) target, (Int32) level, (System.Graphics.ES10.All) internalformat, (Int32) x, (Int32) y, (Int32) width, (Int32) height, (Int32) border);
		}


		/// <summary>[requires: v1.0 and 1.0]
		/// Copy a two-dimensional texture subimage
		/// </summary>
		/// <param name="target">
		/// <para>
		/// Specifies the target texture. Must be GL_TEXTURE_2D, GL_TEXTURE_CUBE_MAP_POSITIVE_X, GL_TEXTURE_CUBE_MAP_NEGATIVE_X, GL_TEXTURE_CUBE_MAP_POSITIVE_Y, GL_TEXTURE_CUBE_MAP_NEGATIVE_Y, GL_TEXTURE_CUBE_MAP_POSITIVE_Z, or GL_TEXTURE_CUBE_MAP_NEGATIVE_Z.
		/// </para>
		/// </param>
		/// <param name="level">
		/// <para>
		/// Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.
		/// </para>
		/// </param>
		/// <param name="xoffset">
		/// <para>
		/// Specifies a texel offset in the x direction within the texture array.
		/// </para>
		/// </param>
		/// <param name="yoffset">
		/// <para>
		/// Specifies a texel offset in the y direction within the texture array.
		/// </para>
		/// </param>
		/// <param name="x">
		/// <para>
		/// Specify the window coordinates of the lower left corner of the rectangular region of pixels to be copied.
		/// </para>
		/// </param>
		/// <param name="y">
		/// <para>
		/// Specify the window coordinates of the lower left corner of the rectangular region of pixels to be copied.
		/// </para>
		/// </param>
		/// <param name="width">
		/// <para>
		/// Specifies the width of the texture subimage.
		/// </para>
		/// </param>
		/// <param name="height">
		/// <para>
		/// Specifies the height of the texture subimage.
		/// </para>
		/// </param>
		//[AutoGenerated(Category = "1.0", Version = "1.0", EntryPoint = "glCopyTexSubImage2D")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
				void CopyTexSubImage2D(System.Graphics.ES10.All target, Int32 level, Int32 xoffset, Int32 yoffset, Int32 x, Int32 y, Int32 width, Int32 height) {
			Delegates.glCopyTexSubImage2D((System.Graphics.ES10.All) target, (Int32) level, (Int32) xoffset, (Int32) yoffset, (Int32) x, (Int32) y, (Int32) width, (Int32) height);
		}


		/// <summary>[requires: v1.0 and 1.0]
		/// Specify whether front- or back-facing facets can be culled
		/// </summary>
		/// <param name="mode">
		/// <para>
		/// Specifies whether front- or back-facing facets are candidates for culling. Symbolic constants GL_FRONT, GL_BACK, and GL_FRONT_AND_BACK are accepted. The initial value is GL_BACK.
		/// </para>
		/// </param>
		//[AutoGenerated(Category = "1.0", Version = "1.0", EntryPoint = "glCullFace")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
				void CullFace(System.Graphics.ES10.All mode) {
			Delegates.glCullFace((System.Graphics.ES10.All) mode);
		}


		/// <summary>[requires: v1.0 and 1.0]
		/// Delete named textures
		/// </summary>
		/// <param name="n">
		/// <para>
		/// Specifies the number of textures to be deleted.
		/// </para>
		/// </param>
		/// <param name="textures">
		/// <para>
		/// Specifies an array of textures to be deleted.
		/// </para>
		/// </param>
		//[AutoGenerated(Category = "1.0", Version = "1.0", EntryPoint = "glDeleteTextures")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
				void DeleteTextures(Int32 n, Int32[] textures) {
			unsafe
			{
				fixed (Int32* textures_ptr = textures) {
					Delegates.glDeleteTextures((Int32) n, (UInt32*) textures_ptr);
				}
			}
		}


		/// <summary>[requires: v1.0 and 1.0]
		/// Delete named textures
		/// </summary>
		/// <param name="n">
		/// <para>
		/// Specifies the number of textures to be deleted.
		/// </para>
		/// </param>
		/// <param name="textures">
		/// <para>
		/// Specifies an array of textures to be deleted.
		/// </para>
		/// </param>
		//[AutoGenerated(Category = "1.0", Version = "1.0", EntryPoint = "glDeleteTextures")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
				void DeleteTextures(Int32 n, ref Int32 textures) {
			unsafe
			{
				fixed (Int32* textures_ptr = &textures) {
					Delegates.glDeleteTextures((Int32) n, (UInt32*) textures_ptr);
				}
			}
		}


		/// <summary>[requires: v1.0 and 1.0]
		/// Delete named textures
		/// </summary>
		/// <param name="n">
		/// <para>
		/// Specifies the number of textures to be deleted.
		/// </para>
		/// </param>
		/// <param name="textures">
		/// <para>
		/// Specifies an array of textures to be deleted.
		/// </para>
		/// </param>
		[System.CLSCompliant(false)]
		//[AutoGenerated(Category = "1.0", Version = "1.0", EntryPoint = "glDeleteTextures")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
		unsafe void DeleteTextures(Int32 n, Int32* textures) {
			Delegates.glDeleteTextures((Int32) n, (UInt32*) textures);
		}


		/// <summary>[requires: v1.0 and 1.0]
		/// Delete named textures
		/// </summary>
		/// <param name="n">
		/// <para>
		/// Specifies the number of textures to be deleted.
		/// </para>
		/// </param>
		/// <param name="textures">
		/// <para>
		/// Specifies an array of textures to be deleted.
		/// </para>
		/// </param>
		[System.CLSCompliant(false)]
		//[AutoGenerated(Category = "1.0", Version = "1.0", EntryPoint = "glDeleteTextures")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
		void DeleteTextures(Int32 n, UInt32[] textures) {
			unsafe
			{
				fixed (UInt32* textures_ptr = textures) {
					Delegates.glDeleteTextures((Int32) n, (UInt32*) textures_ptr);
				}
			}
		}


		/// <summary>[requires: v1.0 and 1.0]
		/// Delete named textures
		/// </summary>
		/// <param name="n">
		/// <para>
		/// Specifies the number of textures to be deleted.
		/// </para>
		/// </param>
		/// <param name="textures">
		/// <para>
		/// Specifies an array of textures to be deleted.
		/// </para>
		/// </param>
		[System.CLSCompliant(false)]
		//[AutoGenerated(Category = "1.0", Version = "1.0", EntryPoint = "glDeleteTextures")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
		void DeleteTextures(Int32 n, ref UInt32 textures) {
			unsafe
			{
				fixed (UInt32* textures_ptr = &textures) {
					Delegates.glDeleteTextures((Int32) n, (UInt32*) textures_ptr);
				}
			}
		}


		/// <summary>[requires: v1.0 and 1.0]
		/// Delete named textures
		/// </summary>
		/// <param name="n">
		/// <para>
		/// Specifies the number of textures to be deleted.
		/// </para>
		/// </param>
		/// <param name="textures">
		/// <para>
		/// Specifies an array of textures to be deleted.
		/// </para>
		/// </param>
		[System.CLSCompliant(false)]
		//[AutoGenerated(Category = "1.0", Version = "1.0", EntryPoint = "glDeleteTextures")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
		unsafe void DeleteTextures(Int32 n, UInt32* textures) {
			Delegates.glDeleteTextures((Int32) n, (UInt32*) textures);
		}


		/// <summary>[requires: v1.0 and 1.0]
		/// Specify the value used for depth buffer comparisons
		/// </summary>
		/// <param name="func">
		/// <para>
		/// Specifies the depth comparison function. Symbolic constants GL_NEVER, GL_LESS, GL_EQUAL, GL_LEQUAL, GL_GREATER, GL_NOTEQUAL, GL_GEQUAL, and GL_ALWAYS are accepted. The initial value is GL_LESS.
		/// </para>
		/// </param>
		//[AutoGenerated(Category = "1.0", Version = "1.0", EntryPoint = "glDepthFunc")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
				void DepthFunc(System.Graphics.ES10.All func) {
			Delegates.glDepthFunc((System.Graphics.ES10.All) func);
		}


		/// <summary>[requires: v1.0 and 1.0]
		/// Enable or disable writing into the depth buffer
		/// </summary>
		/// <param name="flag">
		/// <para>
		/// Specifies whether the depth buffer is enabled for writing. If flag is GL_FALSE, depth buffer writing is disabled. Otherwise, it is enabled. Initially, depth buffer writing is enabled.
		/// </para>
		/// </param>
		//[AutoGenerated(Category = "1.0", Version = "1.0", EntryPoint = "glDepthMask")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
				void DepthMask(bool flag) {
			Delegates.glDepthMask((bool) flag);
		}


		/// <summary>[requires: v1.0 and 1.0]
		/// Specify mapping of depth values from normalized device coordinates to window coordinates
		/// </summary>
		/// <param name="zNear">
		/// <para>
		/// Specifies the mapping of the near clipping plane to window coordinates. The initial value is 0.
		/// </para>
		/// </param>
		/// <param name="zFar">
		/// <para>
		/// Specifies the mapping of the far clipping plane to window coordinates. The initial value is 1.
		/// </para>
		/// </param>
		//[AutoGenerated(Category = "1.0", Version = "1.0", EntryPoint = "glDepthRangef")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
				void DepthRange(Single zNear, Single zFar) {
			Delegates.glDepthRangef((Single) zNear, (Single) zFar);
		}

		/// <summary>[requires: v1.0 and 1.0]</summary>
		//[AutoGenerated(Category = "1.0", Version = "1.0", EntryPoint = "glDepthRangex")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
				void DepthRangex(int zNear, int zFar) {
			Delegates.glDepthRangex((int) zNear, (int) zFar);
		}

		/// <summary>[requires: v1.0 and 1.0]</summary>
		//[AutoGenerated(Category = "1.0", Version = "1.0", EntryPoint = "glDisable")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
				void Disable(System.Graphics.ES10.All cap) {
			Delegates.glDisable((System.Graphics.ES10.All) cap);
		}

		/// <summary>[requires: v1.0 and 1.0]</summary>
		//[AutoGenerated(Category = "1.0", Version = "1.0", EntryPoint = "glDisableClientState")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
				void DisableClientState(System.Graphics.ES10.All array) {
			Delegates.glDisableClientState((System.Graphics.ES10.All) array);
		}


		/// <summary>[requires: v1.0 and 1.0]
		/// Render primitives from array data
		/// </summary>
		/// <param name="mode">
		/// <para>
		/// Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES, GL_LINE_STRIP_ADJACENCY, GL_LINES_ADJACENCY, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_TRIANGLES, GL_TRIANGLE_STRIP_ADJACENCY, GL_TRIANGLES_ADJACENCY and GL_PATCHES are accepted.
		/// </para>
		/// </param>
		/// <param name="first">
		/// <para>
		/// Specifies the starting index in the enabled arrays.
		/// </para>
		/// </param>
		/// <param name="count">
		/// <para>
		/// Specifies the number of indices to be rendered.
		/// </para>
		/// </param>
		//[AutoGenerated(Category = "1.0", Version = "1.0", EntryPoint = "glDrawArrays")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
				void DrawArrays(System.Graphics.ES10.All mode, Int32 first, Int32 count) {
			Delegates.glDrawArrays((System.Graphics.ES10.All) mode, (Int32) first, (Int32) count);
		}


		/// <summary>[requires: v1.0 and 1.0]
		/// Render primitives from array data
		/// </summary>
		/// <param name="mode">
		/// <para>
		/// Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES, GL_LINE_STRIP_ADJACENCY, GL_LINES_ADJACENCY, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_TRIANGLES, GL_TRIANGLE_STRIP_ADJACENCY, GL_TRIANGLES_ADJACENCY and GL_PATCHES are accepted.
		/// </para>
		/// </param>
		/// <param name="count">
		/// <para>
		/// Specifies the number of elements to be rendered.
		/// </para>
		/// </param>
		/// <param name="type">
		/// <para>
		/// Specifies the type of the values in indices. Must be one of GL_UNSIGNED_BYTE, GL_UNSIGNED_SHORT, or GL_UNSIGNED_INT.
		/// </para>
		/// </param>
		/// <param name="indices">
		/// <para>
		/// Specifies a pointer to the location where the indices are stored.
		/// </para>
		/// </param>
		//[AutoGenerated(Category = "1.0", Version = "1.0", EntryPoint = "glDrawElements")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
				void DrawElements(System.Graphics.ES10.All mode, Int32 count, System.Graphics.ES10.All type, IntPtr indices) {
			Delegates.glDrawElements((System.Graphics.ES10.All) mode, (Int32) count, (System.Graphics.ES10.All) type, (IntPtr) indices);
		}


		/// <summary>[requires: v1.0 and 1.0]
		/// Render primitives from array data
		/// </summary>
		/// <param name="mode">
		/// <para>
		/// Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES, GL_LINE_STRIP_ADJACENCY, GL_LINES_ADJACENCY, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_TRIANGLES, GL_TRIANGLE_STRIP_ADJACENCY, GL_TRIANGLES_ADJACENCY and GL_PATCHES are accepted.
		/// </para>
		/// </param>
		/// <param name="count">
		/// <para>
		/// Specifies the number of elements to be rendered.
		/// </para>
		/// </param>
		/// <param name="type">
		/// <para>
		/// Specifies the type of the values in indices. Must be one of GL_UNSIGNED_BYTE, GL_UNSIGNED_SHORT, or GL_UNSIGNED_INT.
		/// </para>
		/// </param>
		/// <param name="indices">
		/// <para>
		/// Specifies a pointer to the location where the indices are stored.
		/// </para>
		/// </param>
		//[AutoGenerated(Category = "1.0", Version = "1.0", EntryPoint = "glDrawElements")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
				void DrawElements<T3>(System.Graphics.ES10.All mode, Int32 count, System.Graphics.ES10.All type, [InAttribute, OutAttribute] T3[] indices)
					where T3 : struct {
			GCHandle indices_ptr = GCHandle.Alloc(indices, GCHandleType.Pinned);
			try {
				Delegates.glDrawElements((System.Graphics.ES10.All) mode, (Int32) count, (System.Graphics.ES10.All) type, (IntPtr) indices_ptr.AddrOfPinnedObject());
			} finally {
				indices_ptr.Free();
			}
		}


		/// <summary>[requires: v1.0 and 1.0]
		/// Render primitives from array data
		/// </summary>
		/// <param name="mode">
		/// <para>
		/// Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES, GL_LINE_STRIP_ADJACENCY, GL_LINES_ADJACENCY, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_TRIANGLES, GL_TRIANGLE_STRIP_ADJACENCY, GL_TRIANGLES_ADJACENCY and GL_PATCHES are accepted.
		/// </para>
		/// </param>
		/// <param name="count">
		/// <para>
		/// Specifies the number of elements to be rendered.
		/// </para>
		/// </param>
		/// <param name="type">
		/// <para>
		/// Specifies the type of the values in indices. Must be one of GL_UNSIGNED_BYTE, GL_UNSIGNED_SHORT, or GL_UNSIGNED_INT.
		/// </para>
		/// </param>
		/// <param name="indices">
		/// <para>
		/// Specifies a pointer to the location where the indices are stored.
		/// </para>
		/// </param>
		//[AutoGenerated(Category = "1.0", Version = "1.0", EntryPoint = "glDrawElements")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
				void DrawElements<T3>(System.Graphics.ES10.All mode, Int32 count, System.Graphics.ES10.All type, [InAttribute, OutAttribute] T3[,] indices)
					where T3 : struct {
			GCHandle indices_ptr = GCHandle.Alloc(indices, GCHandleType.Pinned);
			try {
				Delegates.glDrawElements((System.Graphics.ES10.All) mode, (Int32) count, (System.Graphics.ES10.All) type, (IntPtr) indices_ptr.AddrOfPinnedObject());
			} finally {
				indices_ptr.Free();
			}
		}


		/// <summary>[requires: v1.0 and 1.0]
		/// Render primitives from array data
		/// </summary>
		/// <param name="mode">
		/// <para>
		/// Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES, GL_LINE_STRIP_ADJACENCY, GL_LINES_ADJACENCY, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_TRIANGLES, GL_TRIANGLE_STRIP_ADJACENCY, GL_TRIANGLES_ADJACENCY and GL_PATCHES are accepted.
		/// </para>
		/// </param>
		/// <param name="count">
		/// <para>
		/// Specifies the number of elements to be rendered.
		/// </para>
		/// </param>
		/// <param name="type">
		/// <para>
		/// Specifies the type of the values in indices. Must be one of GL_UNSIGNED_BYTE, GL_UNSIGNED_SHORT, or GL_UNSIGNED_INT.
		/// </para>
		/// </param>
		/// <param name="indices">
		/// <para>
		/// Specifies a pointer to the location where the indices are stored.
		/// </para>
		/// </param>
		//[AutoGenerated(Category = "1.0", Version = "1.0", EntryPoint = "glDrawElements")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
				void DrawElements<T3>(System.Graphics.ES10.All mode, Int32 count, System.Graphics.ES10.All type, [InAttribute, OutAttribute] T3[,,] indices)
					where T3 : struct {
			GCHandle indices_ptr = GCHandle.Alloc(indices, GCHandleType.Pinned);
			try {
				Delegates.glDrawElements((System.Graphics.ES10.All) mode, (Int32) count, (System.Graphics.ES10.All) type, (IntPtr) indices_ptr.AddrOfPinnedObject());
			} finally {
				indices_ptr.Free();
			}
		}


		/// <summary>[requires: v1.0 and 1.0]
		/// Render primitives from array data
		/// </summary>
		/// <param name="mode">
		/// <para>
		/// Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES, GL_LINE_STRIP_ADJACENCY, GL_LINES_ADJACENCY, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_TRIANGLES, GL_TRIANGLE_STRIP_ADJACENCY, GL_TRIANGLES_ADJACENCY and GL_PATCHES are accepted.
		/// </para>
		/// </param>
		/// <param name="count">
		/// <para>
		/// Specifies the number of elements to be rendered.
		/// </para>
		/// </param>
		/// <param name="type">
		/// <para>
		/// Specifies the type of the values in indices. Must be one of GL_UNSIGNED_BYTE, GL_UNSIGNED_SHORT, or GL_UNSIGNED_INT.
		/// </para>
		/// </param>
		/// <param name="indices">
		/// <para>
		/// Specifies a pointer to the location where the indices are stored.
		/// </para>
		/// </param>
		//[AutoGenerated(Category = "1.0", Version = "1.0", EntryPoint = "glDrawElements")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
				void DrawElements<T3>(System.Graphics.ES10.All mode, Int32 count, System.Graphics.ES10.All type, [InAttribute, OutAttribute] ref T3 indices)
					where T3 : struct {
			GCHandle indices_ptr = GCHandle.Alloc(indices, GCHandleType.Pinned);
			try {
				Delegates.glDrawElements((System.Graphics.ES10.All) mode, (Int32) count, (System.Graphics.ES10.All) type, (IntPtr) indices_ptr.AddrOfPinnedObject());
				indices = (T3) indices_ptr.Target;
			} finally {
				indices_ptr.Free();
			}
		}


		/// <summary>[requires: v1.0 and 1.0]
		/// Enable or disable server-side GL capabilities
		/// </summary>
		/// <param name="cap">
		/// <para>
		/// Specifies a symbolic constant indicating a GL capability.
		/// </para>
		/// </param>
		//[AutoGenerated(Category = "1.0", Version = "1.0", EntryPoint = "glEnable")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
				void Enable(System.Graphics.ES10.All cap) {
			Delegates.glEnable((System.Graphics.ES10.All) cap);
		}


		/// <summary>[requires: v1.0 and 1.0]
		/// Enable or disable client-side capability
		/// </summary>
		/// <param name="array">
		/// <para>
		/// Specifies the capability to enable. Symbolic constants GL_COLOR_ARRAY, GL_EDGE_FLAG_ARRAY, GL_FOG_COORD_ARRAY, GL_INDEX_ARRAY, GL_NORMAL_ARRAY, GL_SECONDARY_COLOR_ARRAY, GL_TEXTURE_COORD_ARRAY, and GL_VERTEX_ARRAY are accepted.
		/// </para>
		/// </param>
		//[AutoGenerated(Category = "1.0", Version = "1.0", EntryPoint = "glEnableClientState")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
				void EnableClientState(System.Graphics.ES10.All array) {
			Delegates.glEnableClientState((System.Graphics.ES10.All) array);
		}


		/// <summary>[requires: v1.0 and 1.0]
		/// Block until all GL execution is complete
		/// </summary>
		//[AutoGenerated(Category = "1.0", Version = "1.0", EntryPoint = "glFinish")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
				void Finish() {
			Delegates.glFinish();
		}


		/// <summary>[requires: v1.0 and 1.0]
		/// Force execution of GL commands in finite time
		/// </summary>
		//[AutoGenerated(Category = "1.0", Version = "1.0", EntryPoint = "glFlush")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
				void Flush() {
			Delegates.glFlush();
		}


		/// <summary>[requires: v1.0 and 1.0]
		/// Specify fog parameters
		/// </summary>
		/// <param name="pname">
		/// <para>
		/// Specifies a single-valued fog parameter. GL_FOG_MODE, GL_FOG_DENSITY, GL_FOG_START, GL_FOG_END, GL_FOG_INDEX, and GL_FOG_COORD_SRC are accepted.
		/// </para>
		/// </param>
		/// <param name="param">
		/// <para>
		/// Specifies the value that pname will be set to.
		/// </para>
		/// </param>
		//[AutoGenerated(Category = "1.0", Version = "1.0", EntryPoint = "glFogf")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
				void Fog(System.Graphics.ES10.All pname, Single param) {
			Delegates.glFogf((System.Graphics.ES10.All) pname, (Single) param);
		}


		/// <summary>[requires: v1.0 and 1.0]
		/// Specify fog parameters
		/// </summary>
		/// <param name="pname">
		/// <para>
		/// Specifies a single-valued fog parameter. GL_FOG_MODE, GL_FOG_DENSITY, GL_FOG_START, GL_FOG_END, GL_FOG_INDEX, and GL_FOG_COORD_SRC are accepted.
		/// </para>
		/// </param>
		/// <param name="params">
		/// <para>
		/// Specifies the value that pname will be set to.
		/// </para>
		/// </param>
		//[AutoGenerated(Category = "1.0", Version = "1.0", EntryPoint = "glFogfv")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
				void Fog(System.Graphics.ES10.All pname, Single[] @params) {
			unsafe
			{
				fixed (Single* @params_ptr = @params) {
					Delegates.glFogfv((System.Graphics.ES10.All) pname, (Single*) @params_ptr);
				}
			}
		}


		/// <summary>[requires: v1.0 and 1.0]
		/// Specify fog parameters
		/// </summary>
		/// <param name="pname">
		/// <para>
		/// Specifies a single-valued fog parameter. GL_FOG_MODE, GL_FOG_DENSITY, GL_FOG_START, GL_FOG_END, GL_FOG_INDEX, and GL_FOG_COORD_SRC are accepted.
		/// </para>
		/// </param>
		/// <param name="params">
		/// <para>
		/// Specifies the value that pname will be set to.
		/// </para>
		/// </param>
		[System.CLSCompliant(false)]
		//[AutoGenerated(Category = "1.0", Version = "1.0", EntryPoint = "glFogfv")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
		unsafe void Fog(System.Graphics.ES10.All pname, Single* @params) {
			Delegates.glFogfv((System.Graphics.ES10.All) pname, (Single*) @params);
		}

		/// <summary>[requires: v1.0 and 1.0]</summary>
		//[AutoGenerated(Category = "1.0", Version = "1.0", EntryPoint = "glFogx")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
				void Fogx(System.Graphics.ES10.All pname, int param) {
			Delegates.glFogx((System.Graphics.ES10.All) pname, (int) param);
		}

		/// <summary>[requires: v1.0 and 1.0]</summary>
		//[AutoGenerated(Category = "1.0", Version = "1.0", EntryPoint = "glFogxv")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
				void Fogx(System.Graphics.ES10.All pname, int[] @params) {
			unsafe
			{
				fixed (int* @params_ptr = @params) {
					Delegates.glFogxv((System.Graphics.ES10.All) pname, (int*) @params_ptr);
				}
			}
		}

		/// <summary>[requires: v1.0 and 1.0]</summary>
		[System.CLSCompliant(false)]
		//[AutoGenerated(Category = "1.0", Version = "1.0", EntryPoint = "glFogxv")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
		unsafe void Fogx(System.Graphics.ES10.All pname, int* @params) {
			Delegates.glFogxv((System.Graphics.ES10.All) pname, (int*) @params);
		}


		/// <summary>[requires: v1.0 and 1.0]
		/// Define front- and back-facing polygons
		/// </summary>
		/// <param name="mode">
		/// <para>
		/// Specifies the orientation of front-facing polygons. GL_CW and GL_CCW are accepted. The initial value is GL_CCW.
		/// </para>
		/// </param>
		//[AutoGenerated(Category = "1.0", Version = "1.0", EntryPoint = "glFrontFace")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
				void FrontFace(System.Graphics.ES10.All mode) {
			Delegates.glFrontFace((System.Graphics.ES10.All) mode);
		}


		/// <summary>[requires: v1.0 and 1.0]
		/// Multiply the current matrix by a perspective matrix
		/// </summary>
		//[AutoGenerated(Category = "1.0", Version = "1.0", EntryPoint = "glFrustumf")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
				void Frustum(Single left, Single right, Single bottom, Single top, Single zNear, Single zFar) {
			Delegates.glFrustumf((Single) left, (Single) right, (Single) bottom, (Single) top, (Single) zNear, (Single) zFar);
		}

		/// <summary>[requires: v1.0 and 1.0]</summary>
		//[AutoGenerated(Category = "1.0", Version = "1.0", EntryPoint = "glFrustumx")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
				void Frustumx(int left, int right, int bottom, int top, int zNear, int zFar) {
			Delegates.glFrustumx((int) left, (int) right, (int) bottom, (int) top, (int) zNear, (int) zFar);
		}


		/// <summary>[requires: v1.0 and 1.0]
		/// Generate texture names
		/// </summary>
		/// <param name="n">
		/// <para>
		/// Specifies the number of texture names to be generated.
		/// </para>
		/// </param>
		/// <param name="textures">
		/// <para>
		/// Specifies an array in which the generated texture names are stored.
		/// </para>
		/// </param>
		//[AutoGenerated(Category = "1.0", Version = "1.0", EntryPoint = "glGenTextures")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
				void GenTextures(Int32 n, Int32[] textures) {
			unsafe
			{
				fixed (Int32* textures_ptr = textures) {
					Delegates.glGenTextures((Int32) n, (UInt32*) textures_ptr);
				}
			}
		}


		/// <summary>[requires: v1.0 and 1.0]
		/// Generate texture names
		/// </summary>
		/// <param name="n">
		/// <para>
		/// Specifies the number of texture names to be generated.
		/// </para>
		/// </param>
		/// <param name="textures">
		/// <para>
		/// Specifies an array in which the generated texture names are stored.
		/// </para>
		/// </param>
		//[AutoGenerated(Category = "1.0", Version = "1.0", EntryPoint = "glGenTextures")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
				void GenTextures(Int32 n, ref Int32 textures) {
			unsafe
			{
				fixed (Int32* textures_ptr = &textures) {
					Delegates.glGenTextures((Int32) n, (UInt32*) textures_ptr);
				}
			}
		}


		/// <summary>[requires: v1.0 and 1.0]
		/// Generate texture names
		/// </summary>
		/// <param name="n">
		/// <para>
		/// Specifies the number of texture names to be generated.
		/// </para>
		/// </param>
		/// <param name="textures">
		/// <para>
		/// Specifies an array in which the generated texture names are stored.
		/// </para>
		/// </param>
		[System.CLSCompliant(false)]
		//[AutoGenerated(Category = "1.0", Version = "1.0", EntryPoint = "glGenTextures")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
		unsafe void GenTextures(Int32 n, Int32* textures) {
			Delegates.glGenTextures((Int32) n, (UInt32*) textures);
		}


		/// <summary>[requires: v1.0 and 1.0]
		/// Generate texture names
		/// </summary>
		/// <param name="n">
		/// <para>
		/// Specifies the number of texture names to be generated.
		/// </para>
		/// </param>
		/// <param name="textures">
		/// <para>
		/// Specifies an array in which the generated texture names are stored.
		/// </para>
		/// </param>
		[System.CLSCompliant(false)]
		//[AutoGenerated(Category = "1.0", Version = "1.0", EntryPoint = "glGenTextures")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
		void GenTextures(Int32 n, UInt32[] textures) {
			unsafe
			{
				fixed (UInt32* textures_ptr = textures) {
					Delegates.glGenTextures((Int32) n, (UInt32*) textures_ptr);
				}
			}
		}


		/// <summary>[requires: v1.0 and 1.0]
		/// Generate texture names
		/// </summary>
		/// <param name="n">
		/// <para>
		/// Specifies the number of texture names to be generated.
		/// </para>
		/// </param>
		/// <param name="textures">
		/// <para>
		/// Specifies an array in which the generated texture names are stored.
		/// </para>
		/// </param>
		[System.CLSCompliant(false)]
		//[AutoGenerated(Category = "1.0", Version = "1.0", EntryPoint = "glGenTextures")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
		void GenTextures(Int32 n, ref UInt32 textures) {
			unsafe
			{
				fixed (UInt32* textures_ptr = &textures) {
					Delegates.glGenTextures((Int32) n, (UInt32*) textures_ptr);
				}
			}
		}


		/// <summary>[requires: v1.0 and 1.0]
		/// Generate texture names
		/// </summary>
		/// <param name="n">
		/// <para>
		/// Specifies the number of texture names to be generated.
		/// </para>
		/// </param>
		/// <param name="textures">
		/// <para>
		/// Specifies an array in which the generated texture names are stored.
		/// </para>
		/// </param>
		[System.CLSCompliant(false)]
		//[AutoGenerated(Category = "1.0", Version = "1.0", EntryPoint = "glGenTextures")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
		unsafe void GenTextures(Int32 n, UInt32* textures) {
			Delegates.glGenTextures((Int32) n, (UInt32*) textures);
		}


		/// <summary>[requires: v1.0 and 1.0]
		/// Return error information
		/// </summary>
		//[AutoGenerated(Category = "1.0", Version = "1.0", EntryPoint = "glGetError")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
				System.Graphics.ES10.All GetError() {
			return Delegates.glGetError();
		}

		/// <summary>[requires: v1.0 and 1.0]</summary>
		//[AutoGenerated(Category = "1.0", Version = "1.0", EntryPoint = "glGetIntegerv")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
				void GetInteger(System.Graphics.ES10.All pname, Int32[] @params) {
			unsafe
			{
				fixed (Int32* @params_ptr = @params) {
					Delegates.glGetIntegerv((System.Graphics.ES10.All) pname, (Int32*) @params_ptr);
				}
			}
		}

		/// <summary>[requires: v1.0 and 1.0]</summary>
		//[AutoGenerated(Category = "1.0", Version = "1.0", EntryPoint = "glGetIntegerv")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
				void GetInteger(System.Graphics.ES10.All pname, ref Int32 @params) {
			unsafe
			{
				fixed (Int32* @params_ptr = &@params) {
					Delegates.glGetIntegerv((System.Graphics.ES10.All) pname, (Int32*) @params_ptr);
				}
			}
		}

		/// <summary>[requires: v1.0 and 1.0]</summary>
		[System.CLSCompliant(false)]
		//[AutoGenerated(Category = "1.0", Version = "1.0", EntryPoint = "glGetIntegerv")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
		unsafe void GetInteger(System.Graphics.ES10.All pname, Int32* @params) {
			Delegates.glGetIntegerv((System.Graphics.ES10.All) pname, (Int32*) @params);
		}


		/// <summary>[requires: v1.0 and 1.0]
		/// Return a string describing the current GL connection
		/// </summary>
		/// <param name="name">
		/// <para>
		/// Specifies a symbolic constant, one of GL_VENDOR, GL_RENDERER, GL_VERSION, or GL_SHADING_LANGUAGE_VERSION. Additionally, glGetStringi accepts the GL_EXTENSIONS token.
		/// </para>
		/// </param>
		[System.CLSCompliant(false)]
		//[AutoGenerated(Category = "1.0", Version = "1.0", EntryPoint = "glGetString")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
		unsafe System.String GetString(System.Graphics.ES10.All name) {
			unsafe
			{
				return new string((sbyte*) Delegates.glGetString((System.Graphics.ES10.All) name));
			}
		}


		/// <summary>[requires: v1.0 and 1.0]
		/// Specify implementation-specific hints
		/// </summary>
		/// <param name="target">
		/// <para>
		/// Specifies a symbolic constant indicating the behavior to be controlled. GL_LINE_SMOOTH_HINT, GL_POLYGON_SMOOTH_HINT, GL_TEXTURE_COMPRESSION_HINT, and GL_FRAGMENT_SHADER_DERIVATIVE_HINT are accepted.
		/// </para>
		/// </param>
		/// <param name="mode">
		/// <para>
		/// Specifies a symbolic constant indicating the desired behavior. GL_FASTEST, GL_NICEST, and GL_DONT_CARE are accepted.
		/// </para>
		/// </param>
		//[AutoGenerated(Category = "1.0", Version = "1.0", EntryPoint = "glHint")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
				void Hint(System.Graphics.ES10.All target, System.Graphics.ES10.All mode) {
			Delegates.glHint((System.Graphics.ES10.All) target, (System.Graphics.ES10.All) mode);
		}


		/// <summary>[requires: v1.0 and 1.0]
		/// Set light source parameters
		/// </summary>
		/// <param name="light">
		/// <para>
		/// Specifies a light. The number of lights depends on the implementation, but at least eight lights are supported. They are identified by symbolic names of the form GL_LIGHT , where i ranges from 0 to the value of GL_MAX_LIGHTS - 1.
		/// </para>
		/// </param>
		/// <param name="pname">
		/// <para>
		/// Specifies a single-valued light source parameter for light. GL_SPOT_EXPONENT, GL_SPOT_CUTOFF, GL_CONSTANT_ATTENUATION, GL_LINEAR_ATTENUATION, and GL_QUADRATIC_ATTENUATION are accepted.
		/// </para>
		/// </param>
		/// <param name="param">
		/// <para>
		/// Specifies the value that parameter pname of light source light will be set to.
		/// </para>
		/// </param>
		//[AutoGenerated(Category = "1.0", Version = "1.0", EntryPoint = "glLightf")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
				void Light(System.Graphics.ES10.All light, System.Graphics.ES10.All pname, Single param) {
			Delegates.glLightf((System.Graphics.ES10.All) light, (System.Graphics.ES10.All) pname, (Single) param);
		}


		/// <summary>[requires: v1.0 and 1.0]
		/// Set light source parameters
		/// </summary>
		/// <param name="light">
		/// <para>
		/// Specifies a light. The number of lights depends on the implementation, but at least eight lights are supported. They are identified by symbolic names of the form GL_LIGHT , where i ranges from 0 to the value of GL_MAX_LIGHTS - 1.
		/// </para>
		/// </param>
		/// <param name="pname">
		/// <para>
		/// Specifies a single-valued light source parameter for light. GL_SPOT_EXPONENT, GL_SPOT_CUTOFF, GL_CONSTANT_ATTENUATION, GL_LINEAR_ATTENUATION, and GL_QUADRATIC_ATTENUATION are accepted.
		/// </para>
		/// </param>
		/// <param name="params">
		/// <para>
		/// Specifies the value that parameter pname of light source light will be set to.
		/// </para>
		/// </param>
		//[AutoGenerated(Category = "1.0", Version = "1.0", EntryPoint = "glLightfv")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
				void Light(System.Graphics.ES10.All light, System.Graphics.ES10.All pname, Single[] @params) {
			unsafe
			{
				fixed (Single* @params_ptr = @params) {
					Delegates.glLightfv((System.Graphics.ES10.All) light, (System.Graphics.ES10.All) pname, (Single*) @params_ptr);
				}
			}
		}


		/// <summary>[requires: v1.0 and 1.0]
		/// Set light source parameters
		/// </summary>
		/// <param name="light">
		/// <para>
		/// Specifies a light. The number of lights depends on the implementation, but at least eight lights are supported. They are identified by symbolic names of the form GL_LIGHT , where i ranges from 0 to the value of GL_MAX_LIGHTS - 1.
		/// </para>
		/// </param>
		/// <param name="pname">
		/// <para>
		/// Specifies a single-valued light source parameter for light. GL_SPOT_EXPONENT, GL_SPOT_CUTOFF, GL_CONSTANT_ATTENUATION, GL_LINEAR_ATTENUATION, and GL_QUADRATIC_ATTENUATION are accepted.
		/// </para>
		/// </param>
		/// <param name="params">
		/// <para>
		/// Specifies the value that parameter pname of light source light will be set to.
		/// </para>
		/// </param>
		[System.CLSCompliant(false)]
		//[AutoGenerated(Category = "1.0", Version = "1.0", EntryPoint = "glLightfv")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
		unsafe void Light(System.Graphics.ES10.All light, System.Graphics.ES10.All pname, Single* @params) {
			Delegates.glLightfv((System.Graphics.ES10.All) light, (System.Graphics.ES10.All) pname, (Single*) @params);
		}


		/// <summary>[requires: v1.0 and 1.0]
		/// Set the lighting model parameters
		/// </summary>
		/// <param name="pname">
		/// <para>
		/// Specifies a single-valued lighting model parameter. GL_LIGHT_MODEL_LOCAL_VIEWER, GL_LIGHT_MODEL_COLOR_CONTROL, and GL_LIGHT_MODEL_TWO_SIDE are accepted.
		/// </para>
		/// </param>
		/// <param name="param">
		/// <para>
		/// Specifies the value that param will be set to.
		/// </para>
		/// </param>
		//[AutoGenerated(Category = "1.0", Version = "1.0", EntryPoint = "glLightModelf")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
				void LightModel(System.Graphics.ES10.All pname, Single param) {
			Delegates.glLightModelf((System.Graphics.ES10.All) pname, (Single) param);
		}


		/// <summary>[requires: v1.0 and 1.0]
		/// Set the lighting model parameters
		/// </summary>
		/// <param name="pname">
		/// <para>
		/// Specifies a single-valued lighting model parameter. GL_LIGHT_MODEL_LOCAL_VIEWER, GL_LIGHT_MODEL_COLOR_CONTROL, and GL_LIGHT_MODEL_TWO_SIDE are accepted.
		/// </para>
		/// </param>
		/// <param name="params">
		/// <para>
		/// Specifies the value that param will be set to.
		/// </para>
		/// </param>
		//[AutoGenerated(Category = "1.0", Version = "1.0", EntryPoint = "glLightModelfv")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
				void LightModel(System.Graphics.ES10.All pname, Single[] @params) {
			unsafe
			{
				fixed (Single* @params_ptr = @params) {
					Delegates.glLightModelfv((System.Graphics.ES10.All) pname, (Single*) @params_ptr);
				}
			}
		}


		/// <summary>[requires: v1.0 and 1.0]
		/// Set the lighting model parameters
		/// </summary>
		/// <param name="pname">
		/// <para>
		/// Specifies a single-valued lighting model parameter. GL_LIGHT_MODEL_LOCAL_VIEWER, GL_LIGHT_MODEL_COLOR_CONTROL, and GL_LIGHT_MODEL_TWO_SIDE are accepted.
		/// </para>
		/// </param>
		/// <param name="params">
		/// <para>
		/// Specifies the value that param will be set to.
		/// </para>
		/// </param>
		[System.CLSCompliant(false)]
		//[AutoGenerated(Category = "1.0", Version = "1.0", EntryPoint = "glLightModelfv")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
		unsafe void LightModel(System.Graphics.ES10.All pname, Single* @params) {
			Delegates.glLightModelfv((System.Graphics.ES10.All) pname, (Single*) @params);
		}

		/// <summary>[requires: v1.0 and 1.0]</summary>
		//[AutoGenerated(Category = "1.0", Version = "1.0", EntryPoint = "glLightModelx")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
				void LightModelx(System.Graphics.ES10.All pname, int param) {
			Delegates.glLightModelx((System.Graphics.ES10.All) pname, (int) param);
		}

		/// <summary>[requires: v1.0 and 1.0]</summary>
		//[AutoGenerated(Category = "1.0", Version = "1.0", EntryPoint = "glLightModelxv")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
				void LightModelx(System.Graphics.ES10.All pname, int[] @params) {
			unsafe
			{
				fixed (int* @params_ptr = @params) {
					Delegates.glLightModelxv((System.Graphics.ES10.All) pname, (int*) @params_ptr);
				}
			}
		}

		/// <summary>[requires: v1.0 and 1.0]</summary>
		[System.CLSCompliant(false)]
		//[AutoGenerated(Category = "1.0", Version = "1.0", EntryPoint = "glLightModelxv")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
		unsafe void LightModelx(System.Graphics.ES10.All pname, int* @params) {
			Delegates.glLightModelxv((System.Graphics.ES10.All) pname, (int*) @params);
		}

		/// <summary>[requires: v1.0 and 1.0]</summary>
		//[AutoGenerated(Category = "1.0", Version = "1.0", EntryPoint = "glLightx")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
				void Lightx(System.Graphics.ES10.All light, System.Graphics.ES10.All pname, int param) {
			Delegates.glLightx((System.Graphics.ES10.All) light, (System.Graphics.ES10.All) pname, (int) param);
		}

		/// <summary>[requires: v1.0 and 1.0]</summary>
		//[AutoGenerated(Category = "1.0", Version = "1.0", EntryPoint = "glLightxv")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
				void Lightx(System.Graphics.ES10.All light, System.Graphics.ES10.All pname, int[] @params) {
			unsafe
			{
				fixed (int* @params_ptr = @params) {
					Delegates.glLightxv((System.Graphics.ES10.All) light, (System.Graphics.ES10.All) pname, (int*) @params_ptr);
				}
			}
		}

		/// <summary>[requires: v1.0 and 1.0]</summary>
		[System.CLSCompliant(false)]
		//[AutoGenerated(Category = "1.0", Version = "1.0", EntryPoint = "glLightxv")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
		unsafe void Lightx(System.Graphics.ES10.All light, System.Graphics.ES10.All pname, int* @params) {
			Delegates.glLightxv((System.Graphics.ES10.All) light, (System.Graphics.ES10.All) pname, (int*) @params);
		}


		/// <summary>[requires: v1.0 and 1.0]
		/// Specify the width of rasterized lines
		/// </summary>
		/// <param name="width">
		/// <para>
		/// Specifies the width of rasterized lines. The initial value is 1.
		/// </para>
		/// </param>
		//[AutoGenerated(Category = "1.0", Version = "1.0", EntryPoint = "glLineWidth")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
				void LineWidth(Single width) {
			Delegates.glLineWidth((Single) width);
		}

		/// <summary>[requires: v1.0 and 1.0]</summary>
		//[AutoGenerated(Category = "1.0", Version = "1.0", EntryPoint = "glLineWidthx")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
				void LineWidthx(int width) {
			Delegates.glLineWidthx((int) width);
		}


		/// <summary>[requires: v1.0 and 1.0]
		/// Replace the current matrix with the identity matrix
		/// </summary>
		//[AutoGenerated(Category = "1.0", Version = "1.0", EntryPoint = "glLoadIdentity")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
				void LoadIdentity() {
			Delegates.glLoadIdentity();
		}


		/// <summary>[requires: v1.0 and 1.0]
		/// Replace the current matrix with the specified matrix
		/// </summary>
		/// <param name="m">
		/// <para>
		/// Specifies a pointer to 16 consecutive values, which are used as the elements of a 4 times 4 column-major matrix.
		/// </para>
		/// </param>
		//[AutoGenerated(Category = "1.0", Version = "1.0", EntryPoint = "glLoadMatrixf")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
				void LoadMatrix(Single[] m) {
			unsafe
			{
				fixed (Single* m_ptr = m) {
					Delegates.glLoadMatrixf((Single*) m_ptr);
				}
			}
		}


		/// <summary>[requires: v1.0 and 1.0]
		/// Replace the current matrix with the specified matrix
		/// </summary>
		/// <param name="m">
		/// <para>
		/// Specifies a pointer to 16 consecutive values, which are used as the elements of a 4 times 4 column-major matrix.
		/// </para>
		/// </param>
		//[AutoGenerated(Category = "1.0", Version = "1.0", EntryPoint = "glLoadMatrixf")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
				void LoadMatrix(ref Single m) {
			unsafe
			{
				fixed (Single* m_ptr = &m) {
					Delegates.glLoadMatrixf((Single*) m_ptr);
				}
			}
		}


		/// <summary>[requires: v1.0 and 1.0]
		/// Replace the current matrix with the specified matrix
		/// </summary>
		/// <param name="m">
		/// <para>
		/// Specifies a pointer to 16 consecutive values, which are used as the elements of a 4 times 4 column-major matrix.
		/// </para>
		/// </param>
		[System.CLSCompliant(false)]
		//[AutoGenerated(Category = "1.0", Version = "1.0", EntryPoint = "glLoadMatrixf")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
		unsafe void LoadMatrix(Single* m) {
			Delegates.glLoadMatrixf((Single*) m);
		}

		/// <summary>[requires: v1.0 and 1.0]</summary>
		//[AutoGenerated(Category = "1.0", Version = "1.0", EntryPoint = "glLoadMatrixx")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
				void LoadMatrixx(int[] m) {
			unsafe
			{
				fixed (int* m_ptr = m) {
					Delegates.glLoadMatrixx((int*) m_ptr);
				}
			}
		}

		/// <summary>[requires: v1.0 and 1.0]</summary>
		//[AutoGenerated(Category = "1.0", Version = "1.0", EntryPoint = "glLoadMatrixx")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
				void LoadMatrixx(ref int m) {
			unsafe
			{
				fixed (int* m_ptr = &m) {
					Delegates.glLoadMatrixx((int*) m_ptr);
				}
			}
		}

		/// <summary>[requires: v1.0 and 1.0]</summary>
		[System.CLSCompliant(false)]
		//[AutoGenerated(Category = "1.0", Version = "1.0", EntryPoint = "glLoadMatrixx")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
		unsafe void LoadMatrixx(int* m) {
			Delegates.glLoadMatrixx((int*) m);
		}


		/// <summary>[requires: v1.0 and 1.0]
		/// Specify a logical pixel operation for rendering
		/// </summary>
		/// <param name="opcode">
		/// <para>
		/// Specifies a symbolic constant that selects a logical operation. The following symbols are accepted: GL_CLEAR, GL_SET, GL_COPY, GL_COPY_INVERTED, GL_NOOP, GL_INVERT, GL_AND, GL_NAND, GL_OR, GL_NOR, GL_XOR, GL_EQUIV, GL_AND_REVERSE, GL_AND_INVERTED, GL_OR_REVERSE, and GL_OR_INVERTED. The initial value is GL_COPY.
		/// </para>
		/// </param>
		//[AutoGenerated(Category = "1.0", Version = "1.0", EntryPoint = "glLogicOp")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
				void LogicOp(System.Graphics.ES10.All opcode) {
			Delegates.glLogicOp((System.Graphics.ES10.All) opcode);
		}


		/// <summary>[requires: v1.0 and 1.0]
		/// Specify material parameters for the lighting model
		/// </summary>
		/// <param name="face">
		/// <para>
		/// Specifies which face or faces are being updated. Must be one of GL_FRONT, GL_BACK, or GL_FRONT_AND_BACK.
		/// </para>
		/// </param>
		/// <param name="pname">
		/// <para>
		/// Specifies the single-valued material parameter of the face or faces that is being updated. Must be GL_SHININESS.
		/// </para>
		/// </param>
		/// <param name="param">
		/// <para>
		/// Specifies the value that parameter GL_SHININESS will be set to.
		/// </para>
		/// </param>
		//[AutoGenerated(Category = "1.0", Version = "1.0", EntryPoint = "glMaterialf")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
				void Material(System.Graphics.ES10.All face, System.Graphics.ES10.All pname, Single param) {
			Delegates.glMaterialf((System.Graphics.ES10.All) face, (System.Graphics.ES10.All) pname, (Single) param);
		}


		/// <summary>[requires: v1.0 and 1.0]
		/// Specify material parameters for the lighting model
		/// </summary>
		/// <param name="face">
		/// <para>
		/// Specifies which face or faces are being updated. Must be one of GL_FRONT, GL_BACK, or GL_FRONT_AND_BACK.
		/// </para>
		/// </param>
		/// <param name="pname">
		/// <para>
		/// Specifies the single-valued material parameter of the face or faces that is being updated. Must be GL_SHININESS.
		/// </para>
		/// </param>
		/// <param name="params">
		/// <para>
		/// Specifies the value that parameter GL_SHININESS will be set to.
		/// </para>
		/// </param>
		//[AutoGenerated(Category = "1.0", Version = "1.0", EntryPoint = "glMaterialfv")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
				void Material(System.Graphics.ES10.All face, System.Graphics.ES10.All pname, Single[] @params) {
			unsafe
			{
				fixed (Single* @params_ptr = @params) {
					Delegates.glMaterialfv((System.Graphics.ES10.All) face, (System.Graphics.ES10.All) pname, (Single*) @params_ptr);
				}
			}
		}


		/// <summary>[requires: v1.0 and 1.0]
		/// Specify material parameters for the lighting model
		/// </summary>
		/// <param name="face">
		/// <para>
		/// Specifies which face or faces are being updated. Must be one of GL_FRONT, GL_BACK, or GL_FRONT_AND_BACK.
		/// </para>
		/// </param>
		/// <param name="pname">
		/// <para>
		/// Specifies the single-valued material parameter of the face or faces that is being updated. Must be GL_SHININESS.
		/// </para>
		/// </param>
		/// <param name="params">
		/// <para>
		/// Specifies the value that parameter GL_SHININESS will be set to.
		/// </para>
		/// </param>
		[System.CLSCompliant(false)]
		//[AutoGenerated(Category = "1.0", Version = "1.0", EntryPoint = "glMaterialfv")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
		unsafe void Material(System.Graphics.ES10.All face, System.Graphics.ES10.All pname, Single* @params) {
			Delegates.glMaterialfv((System.Graphics.ES10.All) face, (System.Graphics.ES10.All) pname, (Single*) @params);
		}

		/// <summary>[requires: v1.0 and 1.0]</summary>
		//[AutoGenerated(Category = "1.0", Version = "1.0", EntryPoint = "glMaterialx")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
				void Materialx(System.Graphics.ES10.All face, System.Graphics.ES10.All pname, int param) {
			Delegates.glMaterialx((System.Graphics.ES10.All) face, (System.Graphics.ES10.All) pname, (int) param);
		}

		/// <summary>[requires: v1.0 and 1.0]</summary>
		//[AutoGenerated(Category = "1.0", Version = "1.0", EntryPoint = "glMaterialxv")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
				void Materialx(System.Graphics.ES10.All face, System.Graphics.ES10.All pname, int[] @params) {
			unsafe
			{
				fixed (int* @params_ptr = @params) {
					Delegates.glMaterialxv((System.Graphics.ES10.All) face, (System.Graphics.ES10.All) pname, (int*) @params_ptr);
				}
			}
		}

		/// <summary>[requires: v1.0 and 1.0]</summary>
		[System.CLSCompliant(false)]
		//[AutoGenerated(Category = "1.0", Version = "1.0", EntryPoint = "glMaterialxv")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
		unsafe void Materialx(System.Graphics.ES10.All face, System.Graphics.ES10.All pname, int* @params) {
			Delegates.glMaterialxv((System.Graphics.ES10.All) face, (System.Graphics.ES10.All) pname, (int*) @params);
		}


		/// <summary>[requires: v1.0 and 1.0]
		/// Specify which matrix is the current matrix
		/// </summary>
		/// <param name="mode">
		/// <para>
		/// Specifies which matrix stack is the target for subsequent matrix operations. Three values are accepted: GL_MODELVIEW, GL_PROJECTION, and GL_TEXTURE. The initial value is GL_MODELVIEW. Additionally, if the ARB_imaging extension is supported, GL_COLOR is also accepted.
		/// </para>
		/// </param>
		//[AutoGenerated(Category = "1.0", Version = "1.0", EntryPoint = "glMatrixMode")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
				void MatrixMode(System.Graphics.ES10.All mode) {
			Delegates.glMatrixMode((System.Graphics.ES10.All) mode);
		}


		/// <summary>[requires: v1.0 and 1.0]
		/// Set the current texture coordinates.
		/// The number of texture units is implementation dependent, but must be at least two. Symbolic constant must be one of GL_TEXTURE, where i ranges from 0 to GL_MAX_TEXTURE_COORDS - 1, which is an implementation-dependent value.
		/// </summary>
		//[AutoGenerated(Category = "1.0", Version = "1.0", EntryPoint = "glMultiTexCoord4f")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
				void MultiTexCoord4(System.Graphics.ES10.All target, Single s, Single t, Single r, Single q) {
			Delegates.glMultiTexCoord4f((System.Graphics.ES10.All) target, (Single) s, (Single) t, (Single) r, (Single) q);
		}

		/// <summary>[requires: v1.0 and 1.0]</summary>
		//[AutoGenerated(Category = "1.0", Version = "1.0", EntryPoint = "glMultiTexCoord4x")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
				void MultiTexCoord4x(System.Graphics.ES10.All target, int s, int t, int r, int q) {
			Delegates.glMultiTexCoord4x((System.Graphics.ES10.All) target, (int) s, (int) t, (int) r, (int) q);
		}


		/// <summary>[requires: v1.0 and 1.0]
		/// Multiply the current matrix with the specified matrix
		/// </summary>
		/// <param name="m">
		/// <para>
		/// Points to 16 consecutive values that are used as the elements of a 4 times 4 column-major matrix.
		/// </para>
		/// </param>
		//[AutoGenerated(Category = "1.0", Version = "1.0", EntryPoint = "glMultMatrixf")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
				void MultMatrix(Single[] m) {
			unsafe
			{
				fixed (Single* m_ptr = m) {
					Delegates.glMultMatrixf((Single*) m_ptr);
				}
			}
		}


		/// <summary>[requires: v1.0 and 1.0]
		/// Multiply the current matrix with the specified matrix
		/// </summary>
		/// <param name="m">
		/// <para>
		/// Points to 16 consecutive values that are used as the elements of a 4 times 4 column-major matrix.
		/// </para>
		/// </param>
		//[AutoGenerated(Category = "1.0", Version = "1.0", EntryPoint = "glMultMatrixf")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
				void MultMatrix(ref Single m) {
			unsafe
			{
				fixed (Single* m_ptr = &m) {
					Delegates.glMultMatrixf((Single*) m_ptr);
				}
			}
		}


		/// <summary>[requires: v1.0 and 1.0]
		/// Multiply the current matrix with the specified matrix
		/// </summary>
		/// <param name="m">
		/// <para>
		/// Points to 16 consecutive values that are used as the elements of a 4 times 4 column-major matrix.
		/// </para>
		/// </param>
		[System.CLSCompliant(false)]
		//[AutoGenerated(Category = "1.0", Version = "1.0", EntryPoint = "glMultMatrixf")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
		unsafe void MultMatrix(Single* m) {
			Delegates.glMultMatrixf((Single*) m);
		}

		/// <summary>[requires: v1.0 and 1.0]</summary>
		//[AutoGenerated(Category = "1.0", Version = "1.0", EntryPoint = "glMultMatrixx")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
				void MultMatrixx(int[] m) {
			unsafe
			{
				fixed (int* m_ptr = m) {
					Delegates.glMultMatrixx((int*) m_ptr);
				}
			}
		}

		/// <summary>[requires: v1.0 and 1.0]</summary>
		//[AutoGenerated(Category = "1.0", Version = "1.0", EntryPoint = "glMultMatrixx")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
				void MultMatrixx(ref int m) {
			unsafe
			{
				fixed (int* m_ptr = &m) {
					Delegates.glMultMatrixx((int*) m_ptr);
				}
			}
		}

		/// <summary>[requires: v1.0 and 1.0]</summary>
		[System.CLSCompliant(false)]
		//[AutoGenerated(Category = "1.0", Version = "1.0", EntryPoint = "glMultMatrixx")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
		unsafe void MultMatrixx(int* m) {
			Delegates.glMultMatrixx((int*) m);
		}


		/// <summary>[requires: v1.0 and 1.0]
		/// Set the current normal vector
		/// </summary>
		//[AutoGenerated(Category = "1.0", Version = "1.0", EntryPoint = "glNormal3f")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
				void Normal3(Single nx, Single ny, Single nz) {
			Delegates.glNormal3f((Single) nx, (Single) ny, (Single) nz);
		}

		/// <summary>[requires: v1.0 and 1.0]</summary>
		//[AutoGenerated(Category = "1.0", Version = "1.0", EntryPoint = "glNormal3x")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
				void Normal3x(int nx, int ny, int nz) {
			Delegates.glNormal3x((int) nx, (int) ny, (int) nz);
		}


		/// <summary>[requires: v1.0 and 1.0]
		/// Define an array of normals
		/// </summary>
		/// <param name="type">
		/// <para>
		/// Specifies the data type of each coordinate in the array. Symbolic constants GL_BYTE, GL_SHORT, GL_INT, GL_FLOAT, and GL_DOUBLE are accepted. The initial value is GL_FLOAT.
		/// </para>
		/// </param>
		/// <param name="stride">
		/// <para>
		/// Specifies the byte offset between consecutive normals. If stride is 0, the normals are understood to be tightly packed in the array. The initial value is 0.
		/// </para>
		/// </param>
		/// <param name="pointer">
		/// <para>
		/// Specifies a pointer to the first coordinate of the first normal in the array. The initial value is 0.
		/// </para>
		/// </param>
		//[AutoGenerated(Category = "1.0", Version = "1.0", EntryPoint = "glNormalPointer")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
				void NormalPointer(System.Graphics.ES10.All type, Int32 stride, IntPtr pointer) {
			Delegates.glNormalPointer((System.Graphics.ES10.All) type, (Int32) stride, (IntPtr) pointer);
		}


		/// <summary>[requires: v1.0 and 1.0]
		/// Define an array of normals
		/// </summary>
		/// <param name="type">
		/// <para>
		/// Specifies the data type of each coordinate in the array. Symbolic constants GL_BYTE, GL_SHORT, GL_INT, GL_FLOAT, and GL_DOUBLE are accepted. The initial value is GL_FLOAT.
		/// </para>
		/// </param>
		/// <param name="stride">
		/// <para>
		/// Specifies the byte offset between consecutive normals. If stride is 0, the normals are understood to be tightly packed in the array. The initial value is 0.
		/// </para>
		/// </param>
		/// <param name="pointer">
		/// <para>
		/// Specifies a pointer to the first coordinate of the first normal in the array. The initial value is 0.
		/// </para>
		/// </param>
		//[AutoGenerated(Category = "1.0", Version = "1.0", EntryPoint = "glNormalPointer")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
				void NormalPointer<T2>(System.Graphics.ES10.All type, Int32 stride, [InAttribute, OutAttribute] T2[] pointer)
					where T2 : struct {
			GCHandle pointer_ptr = GCHandle.Alloc(pointer, GCHandleType.Pinned);
			try {
				Delegates.glNormalPointer((System.Graphics.ES10.All) type, (Int32) stride, (IntPtr) pointer_ptr.AddrOfPinnedObject());
			} finally {
				pointer_ptr.Free();
			}
		}


		/// <summary>[requires: v1.0 and 1.0]
		/// Define an array of normals
		/// </summary>
		/// <param name="type">
		/// <para>
		/// Specifies the data type of each coordinate in the array. Symbolic constants GL_BYTE, GL_SHORT, GL_INT, GL_FLOAT, and GL_DOUBLE are accepted. The initial value is GL_FLOAT.
		/// </para>
		/// </param>
		/// <param name="stride">
		/// <para>
		/// Specifies the byte offset between consecutive normals. If stride is 0, the normals are understood to be tightly packed in the array. The initial value is 0.
		/// </para>
		/// </param>
		/// <param name="pointer">
		/// <para>
		/// Specifies a pointer to the first coordinate of the first normal in the array. The initial value is 0.
		/// </para>
		/// </param>
		//[AutoGenerated(Category = "1.0", Version = "1.0", EntryPoint = "glNormalPointer")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
				void NormalPointer<T2>(System.Graphics.ES10.All type, Int32 stride, [InAttribute, OutAttribute] T2[,] pointer)
					where T2 : struct {
			GCHandle pointer_ptr = GCHandle.Alloc(pointer, GCHandleType.Pinned);
			try {
				Delegates.glNormalPointer((System.Graphics.ES10.All) type, (Int32) stride, (IntPtr) pointer_ptr.AddrOfPinnedObject());
			} finally {
				pointer_ptr.Free();
			}
		}


		/// <summary>[requires: v1.0 and 1.0]
		/// Define an array of normals
		/// </summary>
		/// <param name="type">
		/// <para>
		/// Specifies the data type of each coordinate in the array. Symbolic constants GL_BYTE, GL_SHORT, GL_INT, GL_FLOAT, and GL_DOUBLE are accepted. The initial value is GL_FLOAT.
		/// </para>
		/// </param>
		/// <param name="stride">
		/// <para>
		/// Specifies the byte offset between consecutive normals. If stride is 0, the normals are understood to be tightly packed in the array. The initial value is 0.
		/// </para>
		/// </param>
		/// <param name="pointer">
		/// <para>
		/// Specifies a pointer to the first coordinate of the first normal in the array. The initial value is 0.
		/// </para>
		/// </param>
		//[AutoGenerated(Category = "1.0", Version = "1.0", EntryPoint = "glNormalPointer")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
				void NormalPointer<T2>(System.Graphics.ES10.All type, Int32 stride, [InAttribute, OutAttribute] T2[,,] pointer)
					where T2 : struct {
			GCHandle pointer_ptr = GCHandle.Alloc(pointer, GCHandleType.Pinned);
			try {
				Delegates.glNormalPointer((System.Graphics.ES10.All) type, (Int32) stride, (IntPtr) pointer_ptr.AddrOfPinnedObject());
			} finally {
				pointer_ptr.Free();
			}
		}


		/// <summary>[requires: v1.0 and 1.0]
		/// Define an array of normals
		/// </summary>
		/// <param name="type">
		/// <para>
		/// Specifies the data type of each coordinate in the array. Symbolic constants GL_BYTE, GL_SHORT, GL_INT, GL_FLOAT, and GL_DOUBLE are accepted. The initial value is GL_FLOAT.
		/// </para>
		/// </param>
		/// <param name="stride">
		/// <para>
		/// Specifies the byte offset between consecutive normals. If stride is 0, the normals are understood to be tightly packed in the array. The initial value is 0.
		/// </para>
		/// </param>
		/// <param name="pointer">
		/// <para>
		/// Specifies a pointer to the first coordinate of the first normal in the array. The initial value is 0.
		/// </para>
		/// </param>
		//[AutoGenerated(Category = "1.0", Version = "1.0", EntryPoint = "glNormalPointer")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
				void NormalPointer<T2>(System.Graphics.ES10.All type, Int32 stride, [InAttribute, OutAttribute] ref T2 pointer)
					where T2 : struct {
			GCHandle pointer_ptr = GCHandle.Alloc(pointer, GCHandleType.Pinned);
			try {
				Delegates.glNormalPointer((System.Graphics.ES10.All) type, (Int32) stride, (IntPtr) pointer_ptr.AddrOfPinnedObject());
				pointer = (T2) pointer_ptr.Target;
			} finally {
				pointer_ptr.Free();
			}
		}


		/// <summary>[requires: v1.0 and 1.0]
		/// Multiply the current matrix with an orthographic matrix
		/// </summary>
		//[AutoGenerated(Category = "1.0", Version = "1.0", EntryPoint = "glOrthof")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
				void Ortho(Single left, Single right, Single bottom, Single top, Single zNear, Single zFar) {
			Delegates.glOrthof((Single) left, (Single) right, (Single) bottom, (Single) top, (Single) zNear, (Single) zFar);
		}

		/// <summary>[requires: v1.0 and 1.0]</summary>
		//[AutoGenerated(Category = "1.0", Version = "1.0", EntryPoint = "glOrthox")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
				void Orthox(int left, int right, int bottom, int top, int zNear, int zFar) {
			Delegates.glOrthox((int) left, (int) right, (int) bottom, (int) top, (int) zNear, (int) zFar);
		}


		/// <summary>[requires: v1.0 and 1.0]
		/// Set pixel storage modes
		/// </summary>
		/// <param name="pname">
		/// <para>
		/// Specifies the symbolic name of the parameter to be set. Six values affect the packing of pixel data into memory: GL_PACK_SWAP_BYTES, GL_PACK_LSB_FIRST, GL_PACK_ROW_LENGTH, GL_PACK_IMAGE_HEIGHT, GL_PACK_SKIP_PIXELS, GL_PACK_SKIP_ROWS, GL_PACK_SKIP_IMAGES, and GL_PACK_ALIGNMENT. Six more affect the unpacking of pixel data from memory: GL_UNPACK_SWAP_BYTES, GL_UNPACK_LSB_FIRST, GL_UNPACK_ROW_LENGTH, GL_UNPACK_IMAGE_HEIGHT, GL_UNPACK_SKIP_PIXELS, GL_UNPACK_SKIP_ROWS, GL_UNPACK_SKIP_IMAGES, and GL_UNPACK_ALIGNMENT.
		/// </para>
		/// </param>
		/// <param name="param">
		/// <para>
		/// Specifies the value that pname is set to.
		/// </para>
		/// </param>
		//[AutoGenerated(Category = "1.0", Version = "1.0", EntryPoint = "glPixelStorei")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
				void PixelStore(System.Graphics.ES10.All pname, Int32 param) {
			Delegates.glPixelStorei((System.Graphics.ES10.All) pname, (Int32) param);
		}


		/// <summary>[requires: v1.0 and 1.0]
		/// Specify the diameter of rasterized points
		/// </summary>
		/// <param name="size">
		/// <para>
		/// Specifies the diameter of rasterized points. The initial value is 1.
		/// </para>
		/// </param>
		//[AutoGenerated(Category = "1.0", Version = "1.0", EntryPoint = "glPointSize")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
				void PointSize(Single size) {
			Delegates.glPointSize((Single) size);
		}

		/// <summary>[requires: v1.0 and 1.0]</summary>
		//[AutoGenerated(Category = "1.0", Version = "1.0", EntryPoint = "glPointSizex")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
				void PointSizex(int size) {
			Delegates.glPointSizex((int) size);
		}


		/// <summary>[requires: v1.0 and 1.0]
		/// Set the scale and units used to calculate depth values
		/// </summary>
		/// <param name="factor">
		/// <para>
		/// Specifies a scale factor that is used to create a variable depth offset for each polygon. The initial value is 0.
		/// </para>
		/// </param>
		/// <param name="units">
		/// <para>
		/// Is multiplied by an implementation-specific value to create a constant depth offset. The initial value is 0.
		/// </para>
		/// </param>
		//[AutoGenerated(Category = "1.0", Version = "1.0", EntryPoint = "glPolygonOffset")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
				void PolygonOffset(Single factor, Single units) {
			Delegates.glPolygonOffset((Single) factor, (Single) units);
		}

		/// <summary>[requires: v1.0 and 1.0]</summary>
		//[AutoGenerated(Category = "1.0", Version = "1.0", EntryPoint = "glPolygonOffsetx")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
				void PolygonOffsetx(int factor, int units) {
			Delegates.glPolygonOffsetx((int) factor, (int) units);
		}

		/// <summary>[requires: v1.0 and 1.0]</summary>
		//[AutoGenerated(Category = "1.0", Version = "1.0", EntryPoint = "glPopMatrix")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
				void PopMatrix() {
			Delegates.glPopMatrix();
		}


		/// <summary>[requires: v1.0 and 1.0]
		/// Push and pop the current matrix stack
		/// </summary>
		//[AutoGenerated(Category = "1.0", Version = "1.0", EntryPoint = "glPushMatrix")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
				void PushMatrix() {
			Delegates.glPushMatrix();
		}


		/// <summary>[requires: v1.0 and 1.0]
		/// Read a block of pixels from the frame buffer
		/// </summary>
		/// <param name="x">
		/// <para>
		/// Specify the window coordinates of the first pixel that is read from the frame buffer. This location is the lower left corner of a rectangular block of pixels.
		/// </para>
		/// </param>
		/// <param name="y">
		/// <para>
		/// Specify the window coordinates of the first pixel that is read from the frame buffer. This location is the lower left corner of a rectangular block of pixels.
		/// </para>
		/// </param>
		/// <param name="width">
		/// <para>
		/// Specify the dimensions of the pixel rectangle. width and height of one correspond to a single pixel.
		/// </para>
		/// </param>
		/// <param name="height">
		/// <para>
		/// Specify the dimensions of the pixel rectangle. width and height of one correspond to a single pixel.
		/// </para>
		/// </param>
		/// <param name="format">
		/// <para>
		/// Specifies the format of the pixel data. The following symbolic values are accepted: GL_STENCIL_INDEX, GL_DEPTH_COMPONENT, GL_DEPTH_STENCIL, GL_RED, GL_GREEN, GL_BLUE, GL_RGB, GL_BGR, GL_RGBA, and GL_BGRA.
		/// </para>
		/// </param>
		/// <param name="type">
		/// <para>
		/// Specifies the data type of the pixel data. Must be one of GL_UNSIGNED_BYTE, GL_BYTE, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_HALF_FLOAT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, GL_UNSIGNED_INT_2_10_10_10_REV, GL_UNSIGNED_INT_24_8, GL_UNSIGNED_INT_10F_11F_11F_REV, GL_UNSIGNED_INT_5_9_9_9_REV, or GL_FLOAT_32_UNSIGNED_INT_24_8_REV.
		/// </para>
		/// </param>
		/// <param name="pixels">
		/// <para>
		/// Returns the pixel data.
		/// </para>
		/// </param>
		//[AutoGenerated(Category = "1.0", Version = "1.0", EntryPoint = "glReadPixels")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
				void ReadPixels(Int32 x, Int32 y, Int32 width, Int32 height, System.Graphics.ES10.All format, System.Graphics.ES10.All type, IntPtr pixels) {
			Delegates.glReadPixels((Int32) x, (Int32) y, (Int32) width, (Int32) height, (System.Graphics.ES10.All) format, (System.Graphics.ES10.All) type, (IntPtr) pixels);
		}


		/// <summary>[requires: v1.0 and 1.0]
		/// Read a block of pixels from the frame buffer
		/// </summary>
		/// <param name="x">
		/// <para>
		/// Specify the window coordinates of the first pixel that is read from the frame buffer. This location is the lower left corner of a rectangular block of pixels.
		/// </para>
		/// </param>
		/// <param name="y">
		/// <para>
		/// Specify the window coordinates of the first pixel that is read from the frame buffer. This location is the lower left corner of a rectangular block of pixels.
		/// </para>
		/// </param>
		/// <param name="width">
		/// <para>
		/// Specify the dimensions of the pixel rectangle. width and height of one correspond to a single pixel.
		/// </para>
		/// </param>
		/// <param name="height">
		/// <para>
		/// Specify the dimensions of the pixel rectangle. width and height of one correspond to a single pixel.
		/// </para>
		/// </param>
		/// <param name="format">
		/// <para>
		/// Specifies the format of the pixel data. The following symbolic values are accepted: GL_STENCIL_INDEX, GL_DEPTH_COMPONENT, GL_DEPTH_STENCIL, GL_RED, GL_GREEN, GL_BLUE, GL_RGB, GL_BGR, GL_RGBA, and GL_BGRA.
		/// </para>
		/// </param>
		/// <param name="type">
		/// <para>
		/// Specifies the data type of the pixel data. Must be one of GL_UNSIGNED_BYTE, GL_BYTE, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_HALF_FLOAT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, GL_UNSIGNED_INT_2_10_10_10_REV, GL_UNSIGNED_INT_24_8, GL_UNSIGNED_INT_10F_11F_11F_REV, GL_UNSIGNED_INT_5_9_9_9_REV, or GL_FLOAT_32_UNSIGNED_INT_24_8_REV.
		/// </para>
		/// </param>
		/// <param name="pixels">
		/// <para>
		/// Returns the pixel data.
		/// </para>
		/// </param>
		//[AutoGenerated(Category = "1.0", Version = "1.0", EntryPoint = "glReadPixels")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
				void ReadPixels<T6>(Int32 x, Int32 y, Int32 width, Int32 height, System.Graphics.ES10.All format, System.Graphics.ES10.All type, [InAttribute, OutAttribute] T6[] pixels)
					where T6 : struct {
			GCHandle pixels_ptr = GCHandle.Alloc(pixels, GCHandleType.Pinned);
			try {
				Delegates.glReadPixels((Int32) x, (Int32) y, (Int32) width, (Int32) height, (System.Graphics.ES10.All) format, (System.Graphics.ES10.All) type, (IntPtr) pixels_ptr.AddrOfPinnedObject());
			} finally {
				pixels_ptr.Free();
			}
		}


		/// <summary>[requires: v1.0 and 1.0]
		/// Read a block of pixels from the frame buffer
		/// </summary>
		/// <param name="x">
		/// <para>
		/// Specify the window coordinates of the first pixel that is read from the frame buffer. This location is the lower left corner of a rectangular block of pixels.
		/// </para>
		/// </param>
		/// <param name="y">
		/// <para>
		/// Specify the window coordinates of the first pixel that is read from the frame buffer. This location is the lower left corner of a rectangular block of pixels.
		/// </para>
		/// </param>
		/// <param name="width">
		/// <para>
		/// Specify the dimensions of the pixel rectangle. width and height of one correspond to a single pixel.
		/// </para>
		/// </param>
		/// <param name="height">
		/// <para>
		/// Specify the dimensions of the pixel rectangle. width and height of one correspond to a single pixel.
		/// </para>
		/// </param>
		/// <param name="format">
		/// <para>
		/// Specifies the format of the pixel data. The following symbolic values are accepted: GL_STENCIL_INDEX, GL_DEPTH_COMPONENT, GL_DEPTH_STENCIL, GL_RED, GL_GREEN, GL_BLUE, GL_RGB, GL_BGR, GL_RGBA, and GL_BGRA.
		/// </para>
		/// </param>
		/// <param name="type">
		/// <para>
		/// Specifies the data type of the pixel data. Must be one of GL_UNSIGNED_BYTE, GL_BYTE, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_HALF_FLOAT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, GL_UNSIGNED_INT_2_10_10_10_REV, GL_UNSIGNED_INT_24_8, GL_UNSIGNED_INT_10F_11F_11F_REV, GL_UNSIGNED_INT_5_9_9_9_REV, or GL_FLOAT_32_UNSIGNED_INT_24_8_REV.
		/// </para>
		/// </param>
		/// <param name="pixels">
		/// <para>
		/// Returns the pixel data.
		/// </para>
		/// </param>
		//[AutoGenerated(Category = "1.0", Version = "1.0", EntryPoint = "glReadPixels")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
				void ReadPixels<T6>(Int32 x, Int32 y, Int32 width, Int32 height, System.Graphics.ES10.All format, System.Graphics.ES10.All type, [InAttribute, OutAttribute] T6[,] pixels)
					where T6 : struct {
			GCHandle pixels_ptr = GCHandle.Alloc(pixels, GCHandleType.Pinned);
			try {
				Delegates.glReadPixels((Int32) x, (Int32) y, (Int32) width, (Int32) height, (System.Graphics.ES10.All) format, (System.Graphics.ES10.All) type, (IntPtr) pixels_ptr.AddrOfPinnedObject());
			} finally {
				pixels_ptr.Free();
			}
		}


		/// <summary>[requires: v1.0 and 1.0]
		/// Read a block of pixels from the frame buffer
		/// </summary>
		/// <param name="x">
		/// <para>
		/// Specify the window coordinates of the first pixel that is read from the frame buffer. This location is the lower left corner of a rectangular block of pixels.
		/// </para>
		/// </param>
		/// <param name="y">
		/// <para>
		/// Specify the window coordinates of the first pixel that is read from the frame buffer. This location is the lower left corner of a rectangular block of pixels.
		/// </para>
		/// </param>
		/// <param name="width">
		/// <para>
		/// Specify the dimensions of the pixel rectangle. width and height of one correspond to a single pixel.
		/// </para>
		/// </param>
		/// <param name="height">
		/// <para>
		/// Specify the dimensions of the pixel rectangle. width and height of one correspond to a single pixel.
		/// </para>
		/// </param>
		/// <param name="format">
		/// <para>
		/// Specifies the format of the pixel data. The following symbolic values are accepted: GL_STENCIL_INDEX, GL_DEPTH_COMPONENT, GL_DEPTH_STENCIL, GL_RED, GL_GREEN, GL_BLUE, GL_RGB, GL_BGR, GL_RGBA, and GL_BGRA.
		/// </para>
		/// </param>
		/// <param name="type">
		/// <para>
		/// Specifies the data type of the pixel data. Must be one of GL_UNSIGNED_BYTE, GL_BYTE, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_HALF_FLOAT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, GL_UNSIGNED_INT_2_10_10_10_REV, GL_UNSIGNED_INT_24_8, GL_UNSIGNED_INT_10F_11F_11F_REV, GL_UNSIGNED_INT_5_9_9_9_REV, or GL_FLOAT_32_UNSIGNED_INT_24_8_REV.
		/// </para>
		/// </param>
		/// <param name="pixels">
		/// <para>
		/// Returns the pixel data.
		/// </para>
		/// </param>
		//[AutoGenerated(Category = "1.0", Version = "1.0", EntryPoint = "glReadPixels")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
				void ReadPixels<T6>(Int32 x, Int32 y, Int32 width, Int32 height, System.Graphics.ES10.All format, System.Graphics.ES10.All type, [InAttribute, OutAttribute] T6[,,] pixels)
					where T6 : struct {
			GCHandle pixels_ptr = GCHandle.Alloc(pixels, GCHandleType.Pinned);
			try {
				Delegates.glReadPixels((Int32) x, (Int32) y, (Int32) width, (Int32) height, (System.Graphics.ES10.All) format, (System.Graphics.ES10.All) type, (IntPtr) pixels_ptr.AddrOfPinnedObject());
			} finally {
				pixels_ptr.Free();
			}
		}


		/// <summary>[requires: v1.0 and 1.0]
		/// Read a block of pixels from the frame buffer
		/// </summary>
		/// <param name="x">
		/// <para>
		/// Specify the window coordinates of the first pixel that is read from the frame buffer. This location is the lower left corner of a rectangular block of pixels.
		/// </para>
		/// </param>
		/// <param name="y">
		/// <para>
		/// Specify the window coordinates of the first pixel that is read from the frame buffer. This location is the lower left corner of a rectangular block of pixels.
		/// </para>
		/// </param>
		/// <param name="width">
		/// <para>
		/// Specify the dimensions of the pixel rectangle. width and height of one correspond to a single pixel.
		/// </para>
		/// </param>
		/// <param name="height">
		/// <para>
		/// Specify the dimensions of the pixel rectangle. width and height of one correspond to a single pixel.
		/// </para>
		/// </param>
		/// <param name="format">
		/// <para>
		/// Specifies the format of the pixel data. The following symbolic values are accepted: GL_STENCIL_INDEX, GL_DEPTH_COMPONENT, GL_DEPTH_STENCIL, GL_RED, GL_GREEN, GL_BLUE, GL_RGB, GL_BGR, GL_RGBA, and GL_BGRA.
		/// </para>
		/// </param>
		/// <param name="type">
		/// <para>
		/// Specifies the data type of the pixel data. Must be one of GL_UNSIGNED_BYTE, GL_BYTE, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_HALF_FLOAT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, GL_UNSIGNED_INT_2_10_10_10_REV, GL_UNSIGNED_INT_24_8, GL_UNSIGNED_INT_10F_11F_11F_REV, GL_UNSIGNED_INT_5_9_9_9_REV, or GL_FLOAT_32_UNSIGNED_INT_24_8_REV.
		/// </para>
		/// </param>
		/// <param name="pixels">
		/// <para>
		/// Returns the pixel data.
		/// </para>
		/// </param>
		//[AutoGenerated(Category = "1.0", Version = "1.0", EntryPoint = "glReadPixels")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
				void ReadPixels<T6>(Int32 x, Int32 y, Int32 width, Int32 height, System.Graphics.ES10.All format, System.Graphics.ES10.All type, [InAttribute, OutAttribute] ref T6 pixels)
					where T6 : struct {
			GCHandle pixels_ptr = GCHandle.Alloc(pixels, GCHandleType.Pinned);
			try {
				Delegates.glReadPixels((Int32) x, (Int32) y, (Int32) width, (Int32) height, (System.Graphics.ES10.All) format, (System.Graphics.ES10.All) type, (IntPtr) pixels_ptr.AddrOfPinnedObject());
				pixels = (T6) pixels_ptr.Target;
			} finally {
				pixels_ptr.Free();
			}
		}


		/// <summary>[requires: v1.0 and 1.0]
		/// Multiply the current matrix by a rotation matrix
		/// </summary>
		//[AutoGenerated(Category = "1.0", Version = "1.0", EntryPoint = "glRotatef")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
				void Rotate(Single angle, Single x, Single y, Single z) {
			Delegates.glRotatef((Single) angle, (Single) x, (Single) y, (Single) z);
		}

		/// <summary>[requires: v1.0 and 1.0]</summary>
		//[AutoGenerated(Category = "1.0", Version = "1.0", EntryPoint = "glRotatex")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
				void Rotatex(int angle, int x, int y, int z) {
			Delegates.glRotatex((int) angle, (int) x, (int) y, (int) z);
		}


		/// <summary>[requires: v1.0 and 1.0]
		/// Specify multisample coverage parameters
		/// </summary>
		/// <param name="value">
		/// <para>
		/// Specify a single floating-point sample coverage value. The value is clamped to the range [0 ,1]. The initial value is 1.0.
		/// </para>
		/// </param>
		/// <param name="invert">
		/// <para>
		/// Specify a single boolean value representing if the coverage masks should be inverted. GL_TRUE and GL_FALSE are accepted. The initial value is GL_FALSE.
		/// </para>
		/// </param>
		//[AutoGenerated(Category = "1.0", Version = "1.0", EntryPoint = "glSampleCoverage")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
				void SampleCoverage(Single value, bool invert) {
			Delegates.glSampleCoverage((Single) value, (bool) invert);
		}

		/// <summary>[requires: v1.0 and 1.0]</summary>
		//[AutoGenerated(Category = "1.0", Version = "1.0", EntryPoint = "glSampleCoveragex")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
				void SampleCoveragex(int value, bool invert) {
			Delegates.glSampleCoveragex((int) value, (bool) invert);
		}


		/// <summary>[requires: v1.0 and 1.0]
		/// Multiply the current matrix by a general scaling matrix
		/// </summary>
		//[AutoGenerated(Category = "1.0", Version = "1.0", EntryPoint = "glScalef")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
				void Scale(Single x, Single y, Single z) {
			Delegates.glScalef((Single) x, (Single) y, (Single) z);
		}

		/// <summary>[requires: v1.0 and 1.0]</summary>
		//[AutoGenerated(Category = "1.0", Version = "1.0", EntryPoint = "glScalex")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
				void Scalex(int x, int y, int z) {
			Delegates.glScalex((int) x, (int) y, (int) z);
		}


		/// <summary>[requires: v1.0 and 1.0]
		/// Define the scissor box
		/// </summary>
		/// <param name="x">
		/// <para>
		/// Specify the lower left corner of the scissor box. Initially (0, 0).
		/// </para>
		/// </param>
		/// <param name="y">
		/// <para>
		/// Specify the lower left corner of the scissor box. Initially (0, 0).
		/// </para>
		/// </param>
		/// <param name="width">
		/// <para>
		/// Specify the width and height of the scissor box. When a GL context is first attached to a window, width and height are set to the dimensions of that window.
		/// </para>
		/// </param>
		/// <param name="height">
		/// <para>
		/// Specify the width and height of the scissor box. When a GL context is first attached to a window, width and height are set to the dimensions of that window.
		/// </para>
		/// </param>
		//[AutoGenerated(Category = "1.0", Version = "1.0", EntryPoint = "glScissor")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
				void Scissor(Int32 x, Int32 y, Int32 width, Int32 height) {
			Delegates.glScissor((Int32) x, (Int32) y, (Int32) width, (Int32) height);
		}


		/// <summary>[requires: v1.0 and 1.0]
		/// Select flat or smooth shading
		/// </summary>
		/// <param name="mode">
		/// <para>
		/// Specifies a symbolic value representing a shading technique. Accepted values are GL_FLAT and GL_SMOOTH. The initial value is GL_SMOOTH.
		/// </para>
		/// </param>
		//[AutoGenerated(Category = "1.0", Version = "1.0", EntryPoint = "glShadeModel")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
				void ShadeModel(System.Graphics.ES10.All mode) {
			Delegates.glShadeModel((System.Graphics.ES10.All) mode);
		}


		/// <summary>[requires: v1.0 and 1.0]
		/// Set front and back function and reference value for stencil testing
		/// </summary>
		/// <param name="func">
		/// <para>
		/// Specifies the test function. Eight symbolic constants are valid: GL_NEVER, GL_LESS, GL_LEQUAL, GL_GREATER, GL_GEQUAL, GL_EQUAL, GL_NOTEQUAL, and GL_ALWAYS. The initial value is GL_ALWAYS.
		/// </para>
		/// </param>
		/// <param name="ref">
		/// <para>
		/// Specifies the reference value for the stencil test. ref is clamped to the range [0, 2 sup n - 1], where is the number of bitplanes in the stencil buffer. The initial value is 0.
		/// </para>
		/// </param>
		/// <param name="mask">
		/// <para>
		/// Specifies a mask that is ANDed with both the reference value and the stored stencil value when the test is done. The initial value is all 1's.
		/// </para>
		/// </param>
		//[AutoGenerated(Category = "1.0", Version = "1.0", EntryPoint = "glStencilFunc")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
				void StencilFunc(System.Graphics.ES10.All func, Int32 @ref, Int32 mask) {
			Delegates.glStencilFunc((System.Graphics.ES10.All) func, (Int32) @ref, (UInt32) mask);
		}


		/// <summary>[requires: v1.0 and 1.0]
		/// Set front and back function and reference value for stencil testing
		/// </summary>
		/// <param name="func">
		/// <para>
		/// Specifies the test function. Eight symbolic constants are valid: GL_NEVER, GL_LESS, GL_LEQUAL, GL_GREATER, GL_GEQUAL, GL_EQUAL, GL_NOTEQUAL, and GL_ALWAYS. The initial value is GL_ALWAYS.
		/// </para>
		/// </param>
		/// <param name="ref">
		/// <para>
		/// Specifies the reference value for the stencil test. ref is clamped to the range [0, 2 sup n - 1], where is the number of bitplanes in the stencil buffer. The initial value is 0.
		/// </para>
		/// </param>
		/// <param name="mask">
		/// <para>
		/// Specifies a mask that is ANDed with both the reference value and the stored stencil value when the test is done. The initial value is all 1's.
		/// </para>
		/// </param>
		[System.CLSCompliant(false)]
		//[AutoGenerated(Category = "1.0", Version = "1.0", EntryPoint = "glStencilFunc")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
		void StencilFunc(System.Graphics.ES10.All func, Int32 @ref, UInt32 mask) {
			Delegates.glStencilFunc((System.Graphics.ES10.All) func, (Int32) @ref, (UInt32) mask);
		}


		/// <summary>[requires: v1.0 and 1.0]
		/// Control the front and back writing of individual bits in the stencil planes
		/// </summary>
		/// <param name="mask">
		/// <para>
		/// Specifies a bit mask to enable and disable writing of individual bits in the stencil planes. Initially, the mask is all 1's.
		/// </para>
		/// </param>
		//[AutoGenerated(Category = "1.0", Version = "1.0", EntryPoint = "glStencilMask")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
				void StencilMask(Int32 mask) {
			Delegates.glStencilMask((UInt32) mask);
		}


		/// <summary>[requires: v1.0 and 1.0]
		/// Control the front and back writing of individual bits in the stencil planes
		/// </summary>
		/// <param name="mask">
		/// <para>
		/// Specifies a bit mask to enable and disable writing of individual bits in the stencil planes. Initially, the mask is all 1's.
		/// </para>
		/// </param>
		[System.CLSCompliant(false)]
		//[AutoGenerated(Category = "1.0", Version = "1.0", EntryPoint = "glStencilMask")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
		void StencilMask(UInt32 mask) {
			Delegates.glStencilMask((UInt32) mask);
		}


		/// <summary>[requires: v1.0 and 1.0]
		/// Set front and back stencil test actions
		/// </summary>
		/// <param name="sfail">
		/// <para>
		/// Specifies the action to take when the stencil test fails. Eight symbolic constants are accepted: GL_KEEP, GL_ZERO, GL_REPLACE, GL_INCR, GL_INCR_WRAP, GL_DECR, GL_DECR_WRAP, and GL_INVERT. The initial value is GL_KEEP.
		/// </para>
		/// </param>
		/// <param name="dpfail">
		/// <para>
		/// Specifies the stencil action when the stencil test passes, but the depth test fails. dpfail accepts the same symbolic constants as sfail. The initial value is GL_KEEP.
		/// </para>
		/// </param>
		/// <param name="dppass">
		/// <para>
		/// Specifies the stencil action when both the stencil test and the depth test pass, or when the stencil test passes and either there is no depth buffer or depth testing is not enabled. dppass accepts the same symbolic constants as sfail. The initial value is GL_KEEP.
		/// </para>
		/// </param>
		//[AutoGenerated(Category = "1.0", Version = "1.0", EntryPoint = "glStencilOp")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
				void StencilOp(System.Graphics.ES10.All sfail, System.Graphics.ES10.All dpfail, System.Graphics.ES10.All dppass) {
			Delegates.glStencilOp((System.Graphics.ES10.All) sfail, (System.Graphics.ES10.All) dpfail, (System.Graphics.ES10.All) dppass);
		}


		/// <summary>[requires: v1.0 and 1.0]
		/// Define an array of texture coordinates
		/// </summary>
		/// <param name="size">
		/// <para>
		/// Specifies the number of coordinates per array element. Must be 1, 2, 3, or 4. The initial value is 4.
		/// </para>
		/// </param>
		/// <param name="type">
		/// <para>
		/// Specifies the data type of each texture coordinate. Symbolic constants GL_SHORT, GL_INT, GL_FLOAT, or GL_DOUBLE are accepted. The initial value is GL_FLOAT.
		/// </para>
		/// </param>
		/// <param name="stride">
		/// <para>
		/// Specifies the byte offset between consecutive texture coordinate sets. If stride is 0, the array elements are understood to be tightly packed. The initial value is 0.
		/// </para>
		/// </param>
		/// <param name="pointer">
		/// <para>
		/// Specifies a pointer to the first coordinate of the first texture coordinate set in the array. The initial value is 0.
		/// </para>
		/// </param>
		//[AutoGenerated(Category = "1.0", Version = "1.0", EntryPoint = "glTexCoordPointer")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
				void TexCoordPointer(Int32 size, System.Graphics.ES10.All type, Int32 stride, IntPtr pointer) {
			Delegates.glTexCoordPointer((Int32) size, (System.Graphics.ES10.All) type, (Int32) stride, (IntPtr) pointer);
		}


		/// <summary>[requires: v1.0 and 1.0]
		/// Define an array of texture coordinates
		/// </summary>
		/// <param name="size">
		/// <para>
		/// Specifies the number of coordinates per array element. Must be 1, 2, 3, or 4. The initial value is 4.
		/// </para>
		/// </param>
		/// <param name="type">
		/// <para>
		/// Specifies the data type of each texture coordinate. Symbolic constants GL_SHORT, GL_INT, GL_FLOAT, or GL_DOUBLE are accepted. The initial value is GL_FLOAT.
		/// </para>
		/// </param>
		/// <param name="stride">
		/// <para>
		/// Specifies the byte offset between consecutive texture coordinate sets. If stride is 0, the array elements are understood to be tightly packed. The initial value is 0.
		/// </para>
		/// </param>
		/// <param name="pointer">
		/// <para>
		/// Specifies a pointer to the first coordinate of the first texture coordinate set in the array. The initial value is 0.
		/// </para>
		/// </param>
		//[AutoGenerated(Category = "1.0", Version = "1.0", EntryPoint = "glTexCoordPointer")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
				void TexCoordPointer<T3>(Int32 size, System.Graphics.ES10.All type, Int32 stride, [InAttribute, OutAttribute] T3[] pointer)
					where T3 : struct {
			GCHandle pointer_ptr = GCHandle.Alloc(pointer, GCHandleType.Pinned);
			try {
				Delegates.glTexCoordPointer((Int32) size, (System.Graphics.ES10.All) type, (Int32) stride, (IntPtr) pointer_ptr.AddrOfPinnedObject());
			} finally {
				pointer_ptr.Free();
			}
		}


		/// <summary>[requires: v1.0 and 1.0]
		/// Define an array of texture coordinates
		/// </summary>
		/// <param name="size">
		/// <para>
		/// Specifies the number of coordinates per array element. Must be 1, 2, 3, or 4. The initial value is 4.
		/// </para>
		/// </param>
		/// <param name="type">
		/// <para>
		/// Specifies the data type of each texture coordinate. Symbolic constants GL_SHORT, GL_INT, GL_FLOAT, or GL_DOUBLE are accepted. The initial value is GL_FLOAT.
		/// </para>
		/// </param>
		/// <param name="stride">
		/// <para>
		/// Specifies the byte offset between consecutive texture coordinate sets. If stride is 0, the array elements are understood to be tightly packed. The initial value is 0.
		/// </para>
		/// </param>
		/// <param name="pointer">
		/// <para>
		/// Specifies a pointer to the first coordinate of the first texture coordinate set in the array. The initial value is 0.
		/// </para>
		/// </param>
		//[AutoGenerated(Category = "1.0", Version = "1.0", EntryPoint = "glTexCoordPointer")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
				void TexCoordPointer<T3>(Int32 size, System.Graphics.ES10.All type, Int32 stride, [InAttribute, OutAttribute] T3[,] pointer)
					where T3 : struct {
			GCHandle pointer_ptr = GCHandle.Alloc(pointer, GCHandleType.Pinned);
			try {
				Delegates.glTexCoordPointer((Int32) size, (System.Graphics.ES10.All) type, (Int32) stride, (IntPtr) pointer_ptr.AddrOfPinnedObject());
			} finally {
				pointer_ptr.Free();
			}
		}


		/// <summary>[requires: v1.0 and 1.0]
		/// Define an array of texture coordinates
		/// </summary>
		/// <param name="size">
		/// <para>
		/// Specifies the number of coordinates per array element. Must be 1, 2, 3, or 4. The initial value is 4.
		/// </para>
		/// </param>
		/// <param name="type">
		/// <para>
		/// Specifies the data type of each texture coordinate. Symbolic constants GL_SHORT, GL_INT, GL_FLOAT, or GL_DOUBLE are accepted. The initial value is GL_FLOAT.
		/// </para>
		/// </param>
		/// <param name="stride">
		/// <para>
		/// Specifies the byte offset between consecutive texture coordinate sets. If stride is 0, the array elements are understood to be tightly packed. The initial value is 0.
		/// </para>
		/// </param>
		/// <param name="pointer">
		/// <para>
		/// Specifies a pointer to the first coordinate of the first texture coordinate set in the array. The initial value is 0.
		/// </para>
		/// </param>
		//[AutoGenerated(Category = "1.0", Version = "1.0", EntryPoint = "glTexCoordPointer")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
				void TexCoordPointer<T3>(Int32 size, System.Graphics.ES10.All type, Int32 stride, [InAttribute, OutAttribute] T3[,,] pointer)
					where T3 : struct {
			GCHandle pointer_ptr = GCHandle.Alloc(pointer, GCHandleType.Pinned);
			try {
				Delegates.glTexCoordPointer((Int32) size, (System.Graphics.ES10.All) type, (Int32) stride, (IntPtr) pointer_ptr.AddrOfPinnedObject());
			} finally {
				pointer_ptr.Free();
			}
		}


		/// <summary>[requires: v1.0 and 1.0]
		/// Define an array of texture coordinates
		/// </summary>
		/// <param name="size">
		/// <para>
		/// Specifies the number of coordinates per array element. Must be 1, 2, 3, or 4. The initial value is 4.
		/// </para>
		/// </param>
		/// <param name="type">
		/// <para>
		/// Specifies the data type of each texture coordinate. Symbolic constants GL_SHORT, GL_INT, GL_FLOAT, or GL_DOUBLE are accepted. The initial value is GL_FLOAT.
		/// </para>
		/// </param>
		/// <param name="stride">
		/// <para>
		/// Specifies the byte offset between consecutive texture coordinate sets. If stride is 0, the array elements are understood to be tightly packed. The initial value is 0.
		/// </para>
		/// </param>
		/// <param name="pointer">
		/// <para>
		/// Specifies a pointer to the first coordinate of the first texture coordinate set in the array. The initial value is 0.
		/// </para>
		/// </param>
		//[AutoGenerated(Category = "1.0", Version = "1.0", EntryPoint = "glTexCoordPointer")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
				void TexCoordPointer<T3>(Int32 size, System.Graphics.ES10.All type, Int32 stride, [InAttribute, OutAttribute] ref T3 pointer)
					where T3 : struct {
			GCHandle pointer_ptr = GCHandle.Alloc(pointer, GCHandleType.Pinned);
			try {
				Delegates.glTexCoordPointer((Int32) size, (System.Graphics.ES10.All) type, (Int32) stride, (IntPtr) pointer_ptr.AddrOfPinnedObject());
				pointer = (T3) pointer_ptr.Target;
			} finally {
				pointer_ptr.Free();
			}
		}


		/// <summary>[requires: v1.0 and 1.0]
		/// Set texture environment parameters
		/// </summary>
		/// <param name="target">
		/// <para>
		/// Specifies a texture environment. May be GL_TEXTURE_ENV, GL_TEXTURE_FILTER_CONTROL or GL_POINT_SPRITE.
		/// </para>
		/// </param>
		/// <param name="pname">
		/// <para>
		/// Specifies the symbolic name of a single-valued texture environment parameter. May be either GL_TEXTURE_ENV_MODE, GL_TEXTURE_LOD_BIAS, GL_COMBINE_RGB, GL_COMBINE_ALPHA, GL_SRC0_RGB, GL_SRC1_RGB, GL_SRC2_RGB, GL_SRC0_ALPHA, GL_SRC1_ALPHA, GL_SRC2_ALPHA, GL_OPERAND0_RGB, GL_OPERAND1_RGB, GL_OPERAND2_RGB, GL_OPERAND0_ALPHA, GL_OPERAND1_ALPHA, GL_OPERAND2_ALPHA, GL_RGB_SCALE, GL_ALPHA_SCALE, or GL_COORD_REPLACE.
		/// </para>
		/// </param>
		/// <param name="param">
		/// <para>
		/// Specifies a single symbolic constant, one of GL_ADD, GL_ADD_SIGNED, GL_INTERPOLATE, GL_MODULATE, GL_DECAL, GL_BLEND, GL_REPLACE, GL_SUBTRACT, GL_COMBINE, GL_TEXTURE, GL_CONSTANT, GL_PRIMARY_COLOR, GL_PREVIOUS, GL_SRC_COLOR, GL_ONE_MINUS_SRC_COLOR, GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA, a single boolean value for the point sprite texture coordinate replacement, a single floating-point value for the texture level-of-detail bias, or 1.0, 2.0, or 4.0 when specifying the GL_RGB_SCALE or GL_ALPHA_SCALE.
		/// </para>
		/// </param>
		//[AutoGenerated(Category = "1.0", Version = "1.0", EntryPoint = "glTexEnvf")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
				void TexEnv(System.Graphics.ES10.All target, System.Graphics.ES10.All pname, Single param) {
			Delegates.glTexEnvf((System.Graphics.ES10.All) target, (System.Graphics.ES10.All) pname, (Single) param);
		}


		/// <summary>[requires: v1.0 and 1.0]
		/// Set texture environment parameters
		/// </summary>
		/// <param name="target">
		/// <para>
		/// Specifies a texture environment. May be GL_TEXTURE_ENV, GL_TEXTURE_FILTER_CONTROL or GL_POINT_SPRITE.
		/// </para>
		/// </param>
		/// <param name="pname">
		/// <para>
		/// Specifies the symbolic name of a single-valued texture environment parameter. May be either GL_TEXTURE_ENV_MODE, GL_TEXTURE_LOD_BIAS, GL_COMBINE_RGB, GL_COMBINE_ALPHA, GL_SRC0_RGB, GL_SRC1_RGB, GL_SRC2_RGB, GL_SRC0_ALPHA, GL_SRC1_ALPHA, GL_SRC2_ALPHA, GL_OPERAND0_RGB, GL_OPERAND1_RGB, GL_OPERAND2_RGB, GL_OPERAND0_ALPHA, GL_OPERAND1_ALPHA, GL_OPERAND2_ALPHA, GL_RGB_SCALE, GL_ALPHA_SCALE, or GL_COORD_REPLACE.
		/// </para>
		/// </param>
		/// <param name="params">
		/// <para>
		/// Specifies a single symbolic constant, one of GL_ADD, GL_ADD_SIGNED, GL_INTERPOLATE, GL_MODULATE, GL_DECAL, GL_BLEND, GL_REPLACE, GL_SUBTRACT, GL_COMBINE, GL_TEXTURE, GL_CONSTANT, GL_PRIMARY_COLOR, GL_PREVIOUS, GL_SRC_COLOR, GL_ONE_MINUS_SRC_COLOR, GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA, a single boolean value for the point sprite texture coordinate replacement, a single floating-point value for the texture level-of-detail bias, or 1.0, 2.0, or 4.0 when specifying the GL_RGB_SCALE or GL_ALPHA_SCALE.
		/// </para>
		/// </param>
		//[AutoGenerated(Category = "1.0", Version = "1.0", EntryPoint = "glTexEnvfv")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
				void TexEnv(System.Graphics.ES10.All target, System.Graphics.ES10.All pname, Single[] @params) {
			unsafe
			{
				fixed (Single* @params_ptr = @params) {
					Delegates.glTexEnvfv((System.Graphics.ES10.All) target, (System.Graphics.ES10.All) pname, (Single*) @params_ptr);
				}
			}
		}


		/// <summary>[requires: v1.0 and 1.0]
		/// Set texture environment parameters
		/// </summary>
		/// <param name="target">
		/// <para>
		/// Specifies a texture environment. May be GL_TEXTURE_ENV, GL_TEXTURE_FILTER_CONTROL or GL_POINT_SPRITE.
		/// </para>
		/// </param>
		/// <param name="pname">
		/// <para>
		/// Specifies the symbolic name of a single-valued texture environment parameter. May be either GL_TEXTURE_ENV_MODE, GL_TEXTURE_LOD_BIAS, GL_COMBINE_RGB, GL_COMBINE_ALPHA, GL_SRC0_RGB, GL_SRC1_RGB, GL_SRC2_RGB, GL_SRC0_ALPHA, GL_SRC1_ALPHA, GL_SRC2_ALPHA, GL_OPERAND0_RGB, GL_OPERAND1_RGB, GL_OPERAND2_RGB, GL_OPERAND0_ALPHA, GL_OPERAND1_ALPHA, GL_OPERAND2_ALPHA, GL_RGB_SCALE, GL_ALPHA_SCALE, or GL_COORD_REPLACE.
		/// </para>
		/// </param>
		/// <param name="params">
		/// <para>
		/// Specifies a single symbolic constant, one of GL_ADD, GL_ADD_SIGNED, GL_INTERPOLATE, GL_MODULATE, GL_DECAL, GL_BLEND, GL_REPLACE, GL_SUBTRACT, GL_COMBINE, GL_TEXTURE, GL_CONSTANT, GL_PRIMARY_COLOR, GL_PREVIOUS, GL_SRC_COLOR, GL_ONE_MINUS_SRC_COLOR, GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA, a single boolean value for the point sprite texture coordinate replacement, a single floating-point value for the texture level-of-detail bias, or 1.0, 2.0, or 4.0 when specifying the GL_RGB_SCALE or GL_ALPHA_SCALE.
		/// </para>
		/// </param>
		[System.CLSCompliant(false)]
		//[AutoGenerated(Category = "1.0", Version = "1.0", EntryPoint = "glTexEnvfv")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
		unsafe void TexEnv(System.Graphics.ES10.All target, System.Graphics.ES10.All pname, Single* @params) {
			Delegates.glTexEnvfv((System.Graphics.ES10.All) target, (System.Graphics.ES10.All) pname, (Single*) @params);
		}

		/// <summary>[requires: v1.0 and 1.0]</summary>
		//[AutoGenerated(Category = "1.0", Version = "1.0", EntryPoint = "glTexEnvx")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
				void TexEnvx(System.Graphics.ES10.All target, System.Graphics.ES10.All pname, int param) {
			Delegates.glTexEnvx((System.Graphics.ES10.All) target, (System.Graphics.ES10.All) pname, (int) param);
		}

		/// <summary>[requires: v1.0 and 1.0]</summary>
		//[AutoGenerated(Category = "1.0", Version = "1.0", EntryPoint = "glTexEnvxv")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
				void TexEnvx(System.Graphics.ES10.All target, System.Graphics.ES10.All pname, int[] @params) {
			unsafe
			{
				fixed (int* @params_ptr = @params) {
					Delegates.glTexEnvxv((System.Graphics.ES10.All) target, (System.Graphics.ES10.All) pname, (int*) @params_ptr);
				}
			}
		}

		/// <summary>[requires: v1.0 and 1.0]</summary>
		[System.CLSCompliant(false)]
		//[AutoGenerated(Category = "1.0", Version = "1.0", EntryPoint = "glTexEnvxv")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
		unsafe void TexEnvx(System.Graphics.ES10.All target, System.Graphics.ES10.All pname, int* @params) {
			Delegates.glTexEnvxv((System.Graphics.ES10.All) target, (System.Graphics.ES10.All) pname, (int*) @params);
		}


		/// <summary>[requires: v1.0 and 1.0]
		/// Specify a two-dimensional texture image
		/// </summary>
		/// <param name="target">
		/// <para>
		/// Specifies the target texture. Must be GL_TEXTURE_2D, GL_PROXY_TEXTURE_2D, GL_TEXTURE_1D_ARRAY, GL_PROXY_TEXTURE_1D_ARRAY, GL_TEXTURE_RECTANGLE, GL_PROXY_TEXTURE_RECTANGLE, GL_TEXTURE_CUBE_MAP_POSITIVE_X, GL_TEXTURE_CUBE_MAP_NEGATIVE_X, GL_TEXTURE_CUBE_MAP_POSITIVE_Y, GL_TEXTURE_CUBE_MAP_NEGATIVE_Y, GL_TEXTURE_CUBE_MAP_POSITIVE_Z, GL_TEXTURE_CUBE_MAP_NEGATIVE_Z, or GL_PROXY_TEXTURE_CUBE_MAP.
		/// </para>
		/// </param>
		/// <param name="level">
		/// <para>
		/// Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image. If target is GL_TEXTURE_RECTANGLE or GL_PROXY_TEXTURE_RECTANGLE, level must be 0.
		/// </para>
		/// </param>
		/// <param name="internalFormat">
		/// <para>
		/// Specifies the number of color components in the texture. Must be one of the following symbolic constants: GL_COMPRESSED_RED, GL_COMPRESSED_RG, GL_COMPRESSED_RGB, GL_COMPRESSED_RGBA, GL_COMPRESSED_SRGB, GL_COMPRESSED_SRGB_ALPHA, GL_DEPTH_COMPONENT, GL_DEPTH_COMPONENT16, GL_DEPTH_COMPONENT24, GL_DEPTH_COMPONENT32, GL_R3_G3_B2, GL_RED, GL_RG, GL_RGB, GL_RGB4, GL_RGB5, GL_RGB8, GL_RGB10, GL_RGB12, GL_RGB16, GL_RGBA, GL_RGBA2, GL_RGBA4, GL_RGB5_A1, GL_RGBA8, GL_RGB10_A2, GL_RGBA12, GL_RGBA16, GL_SRGB, GL_SRGB8, GL_SRGB_ALPHA, or GL_SRGB8_ALPHA8.
		/// </para>
		/// </param>
		/// <param name="width">
		/// <para>
		/// Specifies the width of the texture image. All implementations support texture images that are at least 1024 texels wide.
		/// </para>
		/// </param>
		/// <param name="height">
		/// <para>
		/// Specifies the height of the texture image, or the number of layers in a texture array, in the case of the GL_TEXTURE_1D_ARRAY and GL_PROXY_TEXTURE_1D_ARRAY targets. All implementations support 2D texture images that are at least 1024 texels high, and texture arrays that are at least 256 layers deep.
		/// </para>
		/// </param>
		/// <param name="border">
		/// <para>
		/// This value must be 0.
		/// </para>
		/// </param>
		/// <param name="format">
		/// <para>
		/// Specifies the format of the pixel data. The following symbolic values are accepted: GL_RED, GL_RG, GL_RGB, GL_BGR, GL_RGBA, and GL_BGRA.
		/// </para>
		/// </param>
		/// <param name="type">
		/// <para>
		/// Specifies the data type of the pixel data. The following symbolic values are accepted: GL_UNSIGNED_BYTE, GL_BYTE, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV.
		/// </para>
		/// </param>
		/// <param name="pixels">
		/// <para>
		/// Specifies a pointer to the image data in memory.
		/// </para>
		/// </param>
		//[AutoGenerated(Category = "1.0", Version = "1.0", EntryPoint = "glTexImage2D")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
				void TexImage2D(System.Graphics.ES10.All target, Int32 level, Int32 internalFormat, Int32 width, Int32 height, Int32 border, System.Graphics.ES10.All format, System.Graphics.ES10.All type, IntPtr pixels) {
			Delegates.glTexImage2D((System.Graphics.ES10.All) target, (Int32) level, (Int32) internalFormat, (Int32) width, (Int32) height, (Int32) border, (System.Graphics.ES10.All) format, (System.Graphics.ES10.All) type, (IntPtr) pixels);
		}


		/// <summary>[requires: v1.0 and 1.0]
		/// Specify a two-dimensional texture image
		/// </summary>
		/// <param name="target">
		/// <para>
		/// Specifies the target texture. Must be GL_TEXTURE_2D, GL_PROXY_TEXTURE_2D, GL_TEXTURE_1D_ARRAY, GL_PROXY_TEXTURE_1D_ARRAY, GL_TEXTURE_RECTANGLE, GL_PROXY_TEXTURE_RECTANGLE, GL_TEXTURE_CUBE_MAP_POSITIVE_X, GL_TEXTURE_CUBE_MAP_NEGATIVE_X, GL_TEXTURE_CUBE_MAP_POSITIVE_Y, GL_TEXTURE_CUBE_MAP_NEGATIVE_Y, GL_TEXTURE_CUBE_MAP_POSITIVE_Z, GL_TEXTURE_CUBE_MAP_NEGATIVE_Z, or GL_PROXY_TEXTURE_CUBE_MAP.
		/// </para>
		/// </param>
		/// <param name="level">
		/// <para>
		/// Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image. If target is GL_TEXTURE_RECTANGLE or GL_PROXY_TEXTURE_RECTANGLE, level must be 0.
		/// </para>
		/// </param>
		/// <param name="internalFormat">
		/// <para>
		/// Specifies the number of color components in the texture. Must be one of the following symbolic constants: GL_COMPRESSED_RED, GL_COMPRESSED_RG, GL_COMPRESSED_RGB, GL_COMPRESSED_RGBA, GL_COMPRESSED_SRGB, GL_COMPRESSED_SRGB_ALPHA, GL_DEPTH_COMPONENT, GL_DEPTH_COMPONENT16, GL_DEPTH_COMPONENT24, GL_DEPTH_COMPONENT32, GL_R3_G3_B2, GL_RED, GL_RG, GL_RGB, GL_RGB4, GL_RGB5, GL_RGB8, GL_RGB10, GL_RGB12, GL_RGB16, GL_RGBA, GL_RGBA2, GL_RGBA4, GL_RGB5_A1, GL_RGBA8, GL_RGB10_A2, GL_RGBA12, GL_RGBA16, GL_SRGB, GL_SRGB8, GL_SRGB_ALPHA, or GL_SRGB8_ALPHA8.
		/// </para>
		/// </param>
		/// <param name="width">
		/// <para>
		/// Specifies the width of the texture image. All implementations support texture images that are at least 1024 texels wide.
		/// </para>
		/// </param>
		/// <param name="height">
		/// <para>
		/// Specifies the height of the texture image, or the number of layers in a texture array, in the case of the GL_TEXTURE_1D_ARRAY and GL_PROXY_TEXTURE_1D_ARRAY targets. All implementations support 2D texture images that are at least 1024 texels high, and texture arrays that are at least 256 layers deep.
		/// </para>
		/// </param>
		/// <param name="border">
		/// <para>
		/// This value must be 0.
		/// </para>
		/// </param>
		/// <param name="format">
		/// <para>
		/// Specifies the format of the pixel data. The following symbolic values are accepted: GL_RED, GL_RG, GL_RGB, GL_BGR, GL_RGBA, and GL_BGRA.
		/// </para>
		/// </param>
		/// <param name="type">
		/// <para>
		/// Specifies the data type of the pixel data. The following symbolic values are accepted: GL_UNSIGNED_BYTE, GL_BYTE, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV.
		/// </para>
		/// </param>
		/// <param name="pixels">
		/// <para>
		/// Specifies a pointer to the image data in memory.
		/// </para>
		/// </param>
		//[AutoGenerated(Category = "1.0", Version = "1.0", EntryPoint = "glTexImage2D")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
				void TexImage2D<T8>(System.Graphics.ES10.All target, Int32 level, Int32 internalFormat, Int32 width, Int32 height, Int32 border, System.Graphics.ES10.All format, System.Graphics.ES10.All type, [InAttribute, OutAttribute] T8[] pixels)
					where T8 : struct {
			GCHandle pixels_ptr = GCHandle.Alloc(pixels, GCHandleType.Pinned);
			try {
				Delegates.glTexImage2D((System.Graphics.ES10.All) target, (Int32) level, (Int32) internalFormat, (Int32) width, (Int32) height, (Int32) border, (System.Graphics.ES10.All) format, (System.Graphics.ES10.All) type, (IntPtr) pixels_ptr.AddrOfPinnedObject());
			} finally {
				pixels_ptr.Free();
			}
		}


		/// <summary>[requires: v1.0 and 1.0]
		/// Specify a two-dimensional texture image
		/// </summary>
		/// <param name="target">
		/// <para>
		/// Specifies the target texture. Must be GL_TEXTURE_2D, GL_PROXY_TEXTURE_2D, GL_TEXTURE_1D_ARRAY, GL_PROXY_TEXTURE_1D_ARRAY, GL_TEXTURE_RECTANGLE, GL_PROXY_TEXTURE_RECTANGLE, GL_TEXTURE_CUBE_MAP_POSITIVE_X, GL_TEXTURE_CUBE_MAP_NEGATIVE_X, GL_TEXTURE_CUBE_MAP_POSITIVE_Y, GL_TEXTURE_CUBE_MAP_NEGATIVE_Y, GL_TEXTURE_CUBE_MAP_POSITIVE_Z, GL_TEXTURE_CUBE_MAP_NEGATIVE_Z, or GL_PROXY_TEXTURE_CUBE_MAP.
		/// </para>
		/// </param>
		/// <param name="level">
		/// <para>
		/// Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image. If target is GL_TEXTURE_RECTANGLE or GL_PROXY_TEXTURE_RECTANGLE, level must be 0.
		/// </para>
		/// </param>
		/// <param name="internalFormat">
		/// <para>
		/// Specifies the number of color components in the texture. Must be one of the following symbolic constants: GL_COMPRESSED_RED, GL_COMPRESSED_RG, GL_COMPRESSED_RGB, GL_COMPRESSED_RGBA, GL_COMPRESSED_SRGB, GL_COMPRESSED_SRGB_ALPHA, GL_DEPTH_COMPONENT, GL_DEPTH_COMPONENT16, GL_DEPTH_COMPONENT24, GL_DEPTH_COMPONENT32, GL_R3_G3_B2, GL_RED, GL_RG, GL_RGB, GL_RGB4, GL_RGB5, GL_RGB8, GL_RGB10, GL_RGB12, GL_RGB16, GL_RGBA, GL_RGBA2, GL_RGBA4, GL_RGB5_A1, GL_RGBA8, GL_RGB10_A2, GL_RGBA12, GL_RGBA16, GL_SRGB, GL_SRGB8, GL_SRGB_ALPHA, or GL_SRGB8_ALPHA8.
		/// </para>
		/// </param>
		/// <param name="width">
		/// <para>
		/// Specifies the width of the texture image. All implementations support texture images that are at least 1024 texels wide.
		/// </para>
		/// </param>
		/// <param name="height">
		/// <para>
		/// Specifies the height of the texture image, or the number of layers in a texture array, in the case of the GL_TEXTURE_1D_ARRAY and GL_PROXY_TEXTURE_1D_ARRAY targets. All implementations support 2D texture images that are at least 1024 texels high, and texture arrays that are at least 256 layers deep.
		/// </para>
		/// </param>
		/// <param name="border">
		/// <para>
		/// This value must be 0.
		/// </para>
		/// </param>
		/// <param name="format">
		/// <para>
		/// Specifies the format of the pixel data. The following symbolic values are accepted: GL_RED, GL_RG, GL_RGB, GL_BGR, GL_RGBA, and GL_BGRA.
		/// </para>
		/// </param>
		/// <param name="type">
		/// <para>
		/// Specifies the data type of the pixel data. The following symbolic values are accepted: GL_UNSIGNED_BYTE, GL_BYTE, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV.
		/// </para>
		/// </param>
		/// <param name="pixels">
		/// <para>
		/// Specifies a pointer to the image data in memory.
		/// </para>
		/// </param>
		//[AutoGenerated(Category = "1.0", Version = "1.0", EntryPoint = "glTexImage2D")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
				void TexImage2D<T8>(System.Graphics.ES10.All target, Int32 level, Int32 internalFormat, Int32 width, Int32 height, Int32 border, System.Graphics.ES10.All format, System.Graphics.ES10.All type, [InAttribute, OutAttribute] T8[,] pixels)
					where T8 : struct {
			GCHandle pixels_ptr = GCHandle.Alloc(pixels, GCHandleType.Pinned);
			try {
				Delegates.glTexImage2D((System.Graphics.ES10.All) target, (Int32) level, (Int32) internalFormat, (Int32) width, (Int32) height, (Int32) border, (System.Graphics.ES10.All) format, (System.Graphics.ES10.All) type, (IntPtr) pixels_ptr.AddrOfPinnedObject());
			} finally {
				pixels_ptr.Free();
			}
		}


		/// <summary>[requires: v1.0 and 1.0]
		/// Specify a two-dimensional texture image
		/// </summary>
		/// <param name="target">
		/// <para>
		/// Specifies the target texture. Must be GL_TEXTURE_2D, GL_PROXY_TEXTURE_2D, GL_TEXTURE_1D_ARRAY, GL_PROXY_TEXTURE_1D_ARRAY, GL_TEXTURE_RECTANGLE, GL_PROXY_TEXTURE_RECTANGLE, GL_TEXTURE_CUBE_MAP_POSITIVE_X, GL_TEXTURE_CUBE_MAP_NEGATIVE_X, GL_TEXTURE_CUBE_MAP_POSITIVE_Y, GL_TEXTURE_CUBE_MAP_NEGATIVE_Y, GL_TEXTURE_CUBE_MAP_POSITIVE_Z, GL_TEXTURE_CUBE_MAP_NEGATIVE_Z, or GL_PROXY_TEXTURE_CUBE_MAP.
		/// </para>
		/// </param>
		/// <param name="level">
		/// <para>
		/// Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image. If target is GL_TEXTURE_RECTANGLE or GL_PROXY_TEXTURE_RECTANGLE, level must be 0.
		/// </para>
		/// </param>
		/// <param name="internalFormat">
		/// <para>
		/// Specifies the number of color components in the texture. Must be one of the following symbolic constants: GL_COMPRESSED_RED, GL_COMPRESSED_RG, GL_COMPRESSED_RGB, GL_COMPRESSED_RGBA, GL_COMPRESSED_SRGB, GL_COMPRESSED_SRGB_ALPHA, GL_DEPTH_COMPONENT, GL_DEPTH_COMPONENT16, GL_DEPTH_COMPONENT24, GL_DEPTH_COMPONENT32, GL_R3_G3_B2, GL_RED, GL_RG, GL_RGB, GL_RGB4, GL_RGB5, GL_RGB8, GL_RGB10, GL_RGB12, GL_RGB16, GL_RGBA, GL_RGBA2, GL_RGBA4, GL_RGB5_A1, GL_RGBA8, GL_RGB10_A2, GL_RGBA12, GL_RGBA16, GL_SRGB, GL_SRGB8, GL_SRGB_ALPHA, or GL_SRGB8_ALPHA8.
		/// </para>
		/// </param>
		/// <param name="width">
		/// <para>
		/// Specifies the width of the texture image. All implementations support texture images that are at least 1024 texels wide.
		/// </para>
		/// </param>
		/// <param name="height">
		/// <para>
		/// Specifies the height of the texture image, or the number of layers in a texture array, in the case of the GL_TEXTURE_1D_ARRAY and GL_PROXY_TEXTURE_1D_ARRAY targets. All implementations support 2D texture images that are at least 1024 texels high, and texture arrays that are at least 256 layers deep.
		/// </para>
		/// </param>
		/// <param name="border">
		/// <para>
		/// This value must be 0.
		/// </para>
		/// </param>
		/// <param name="format">
		/// <para>
		/// Specifies the format of the pixel data. The following symbolic values are accepted: GL_RED, GL_RG, GL_RGB, GL_BGR, GL_RGBA, and GL_BGRA.
		/// </para>
		/// </param>
		/// <param name="type">
		/// <para>
		/// Specifies the data type of the pixel data. The following symbolic values are accepted: GL_UNSIGNED_BYTE, GL_BYTE, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV.
		/// </para>
		/// </param>
		/// <param name="pixels">
		/// <para>
		/// Specifies a pointer to the image data in memory.
		/// </para>
		/// </param>
		//[AutoGenerated(Category = "1.0", Version = "1.0", EntryPoint = "glTexImage2D")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
				void TexImage2D<T8>(System.Graphics.ES10.All target, Int32 level, Int32 internalFormat, Int32 width, Int32 height, Int32 border, System.Graphics.ES10.All format, System.Graphics.ES10.All type, [InAttribute, OutAttribute] T8[,,] pixels)
					where T8 : struct {
			GCHandle pixels_ptr = GCHandle.Alloc(pixels, GCHandleType.Pinned);
			try {
				Delegates.glTexImage2D((System.Graphics.ES10.All) target, (Int32) level, (Int32) internalFormat, (Int32) width, (Int32) height, (Int32) border, (System.Graphics.ES10.All) format, (System.Graphics.ES10.All) type, (IntPtr) pixels_ptr.AddrOfPinnedObject());
			} finally {
				pixels_ptr.Free();
			}
		}


		/// <summary>[requires: v1.0 and 1.0]
		/// Specify a two-dimensional texture image
		/// </summary>
		/// <param name="target">
		/// <para>
		/// Specifies the target texture. Must be GL_TEXTURE_2D, GL_PROXY_TEXTURE_2D, GL_TEXTURE_1D_ARRAY, GL_PROXY_TEXTURE_1D_ARRAY, GL_TEXTURE_RECTANGLE, GL_PROXY_TEXTURE_RECTANGLE, GL_TEXTURE_CUBE_MAP_POSITIVE_X, GL_TEXTURE_CUBE_MAP_NEGATIVE_X, GL_TEXTURE_CUBE_MAP_POSITIVE_Y, GL_TEXTURE_CUBE_MAP_NEGATIVE_Y, GL_TEXTURE_CUBE_MAP_POSITIVE_Z, GL_TEXTURE_CUBE_MAP_NEGATIVE_Z, or GL_PROXY_TEXTURE_CUBE_MAP.
		/// </para>
		/// </param>
		/// <param name="level">
		/// <para>
		/// Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image. If target is GL_TEXTURE_RECTANGLE or GL_PROXY_TEXTURE_RECTANGLE, level must be 0.
		/// </para>
		/// </param>
		/// <param name="internalFormat">
		/// <para>
		/// Specifies the number of color components in the texture. Must be one of the following symbolic constants: GL_COMPRESSED_RED, GL_COMPRESSED_RG, GL_COMPRESSED_RGB, GL_COMPRESSED_RGBA, GL_COMPRESSED_SRGB, GL_COMPRESSED_SRGB_ALPHA, GL_DEPTH_COMPONENT, GL_DEPTH_COMPONENT16, GL_DEPTH_COMPONENT24, GL_DEPTH_COMPONENT32, GL_R3_G3_B2, GL_RED, GL_RG, GL_RGB, GL_RGB4, GL_RGB5, GL_RGB8, GL_RGB10, GL_RGB12, GL_RGB16, GL_RGBA, GL_RGBA2, GL_RGBA4, GL_RGB5_A1, GL_RGBA8, GL_RGB10_A2, GL_RGBA12, GL_RGBA16, GL_SRGB, GL_SRGB8, GL_SRGB_ALPHA, or GL_SRGB8_ALPHA8.
		/// </para>
		/// </param>
		/// <param name="width">
		/// <para>
		/// Specifies the width of the texture image. All implementations support texture images that are at least 1024 texels wide.
		/// </para>
		/// </param>
		/// <param name="height">
		/// <para>
		/// Specifies the height of the texture image, or the number of layers in a texture array, in the case of the GL_TEXTURE_1D_ARRAY and GL_PROXY_TEXTURE_1D_ARRAY targets. All implementations support 2D texture images that are at least 1024 texels high, and texture arrays that are at least 256 layers deep.
		/// </para>
		/// </param>
		/// <param name="border">
		/// <para>
		/// This value must be 0.
		/// </para>
		/// </param>
		/// <param name="format">
		/// <para>
		/// Specifies the format of the pixel data. The following symbolic values are accepted: GL_RED, GL_RG, GL_RGB, GL_BGR, GL_RGBA, and GL_BGRA.
		/// </para>
		/// </param>
		/// <param name="type">
		/// <para>
		/// Specifies the data type of the pixel data. The following symbolic values are accepted: GL_UNSIGNED_BYTE, GL_BYTE, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV.
		/// </para>
		/// </param>
		/// <param name="pixels">
		/// <para>
		/// Specifies a pointer to the image data in memory.
		/// </para>
		/// </param>
		//[AutoGenerated(Category = "1.0", Version = "1.0", EntryPoint = "glTexImage2D")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
				void TexImage2D<T8>(System.Graphics.ES10.All target, Int32 level, Int32 internalFormat, Int32 width, Int32 height, Int32 border, System.Graphics.ES10.All format, System.Graphics.ES10.All type, [InAttribute, OutAttribute] ref T8 pixels)
					where T8 : struct {
			GCHandle pixels_ptr = GCHandle.Alloc(pixels, GCHandleType.Pinned);
			try {
				Delegates.glTexImage2D((System.Graphics.ES10.All) target, (Int32) level, (Int32) internalFormat, (Int32) width, (Int32) height, (Int32) border, (System.Graphics.ES10.All) format, (System.Graphics.ES10.All) type, (IntPtr) pixels_ptr.AddrOfPinnedObject());
				pixels = (T8) pixels_ptr.Target;
			} finally {
				pixels_ptr.Free();
			}
		}


		/// <summary>[requires: v1.0 and 1.0]
		/// Set texture parameters
		/// </summary>
		/// <param name="target">
		/// <para>
		/// Specifies the target texture, which must be either GL_TEXTURE_1D, GL_TEXTURE_2D, GL_TEXTURE_3D, GL_TEXTURE_1D_ARRAY, GL_TEXTURE_2D_ARRAY, GL_TEXTURE_RECTANGLE, or GL_TEXTURE_CUBE_MAP.
		/// </para>
		/// </param>
		/// <param name="pname">
		/// <para>
		/// Specifies the symbolic name of a single-valued texture parameter. pname can be one of the following: GL_TEXTURE_BASE_LEVEL, GL_TEXTURE_COMPARE_FUNC, GL_TEXTURE_COMPARE_MODE, GL_TEXTURE_LOD_BIAS, GL_TEXTURE_MIN_FILTER, GL_TEXTURE_MAG_FILTER, GL_TEXTURE_MIN_LOD, GL_TEXTURE_MAX_LOD, GL_TEXTURE_MAX_LEVEL, GL_TEXTURE_SWIZZLE_R, GL_TEXTURE_SWIZZLE_G, GL_TEXTURE_SWIZZLE_B, GL_TEXTURE_SWIZZLE_A, GL_TEXTURE_WRAP_S, GL_TEXTURE_WRAP_T, or GL_TEXTURE_WRAP_R.
		/// </para>
		/// </param>
		/// <param name="param">
		/// <para>
		/// Specifies the value of pname.
		/// </para>
		/// </param>
		//[AutoGenerated(Category = "1.0", Version = "1.0", EntryPoint = "glTexParameterf")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
				void TexParameter(System.Graphics.ES10.All target, System.Graphics.ES10.All pname, Single param) {
			Delegates.glTexParameterf((System.Graphics.ES10.All) target, (System.Graphics.ES10.All) pname, (Single) param);
		}

		/// <summary>[requires: v1.0 and 1.0]</summary>
		//[AutoGenerated(Category = "1.0", Version = "1.0", EntryPoint = "glTexParameterx")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
				void TexParameterx(System.Graphics.ES10.All target, System.Graphics.ES10.All pname, int param) {
			Delegates.glTexParameterx((System.Graphics.ES10.All) target, (System.Graphics.ES10.All) pname, (int) param);
		}


		/// <summary>[requires: v1.0 and 1.0]
		/// Specify a two-dimensional texture subimage
		/// </summary>
		/// <param name="target">
		/// <para>
		/// Specifies the target texture. Must be GL_TEXTURE_2D, GL_TEXTURE_CUBE_MAP_POSITIVE_X, GL_TEXTURE_CUBE_MAP_NEGATIVE_X, GL_TEXTURE_CUBE_MAP_POSITIVE_Y, GL_TEXTURE_CUBE_MAP_NEGATIVE_Y, GL_TEXTURE_CUBE_MAP_POSITIVE_Z, or GL_TEXTURE_CUBE_MAP_NEGATIVE_Z.
		/// </para>
		/// </param>
		/// <param name="level">
		/// <para>
		/// Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.
		/// </para>
		/// </param>
		/// <param name="xoffset">
		/// <para>
		/// Specifies a texel offset in the x direction within the texture array.
		/// </para>
		/// </param>
		/// <param name="yoffset">
		/// <para>
		/// Specifies a texel offset in the y direction within the texture array.
		/// </para>
		/// </param>
		/// <param name="width">
		/// <para>
		/// Specifies the width of the texture subimage.
		/// </para>
		/// </param>
		/// <param name="height">
		/// <para>
		/// Specifies the height of the texture subimage.
		/// </para>
		/// </param>
		/// <param name="format">
		/// <para>
		/// Specifies the format of the pixel data. The following symbolic values are accepted: GL_RED, GL_RG, GL_RGB, GL_BGR, GL_RGBA, and GL_BGRA.
		/// </para>
		/// </param>
		/// <param name="type">
		/// <para>
		/// Specifies the data type of the pixel data. The following symbolic values are accepted: GL_UNSIGNED_BYTE, GL_BYTE, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV.
		/// </para>
		/// </param>
		/// <param name="pixels">
		/// <para>
		/// Specifies a pointer to the image data in memory.
		/// </para>
		/// </param>
		//[AutoGenerated(Category = "1.0", Version = "1.0", EntryPoint = "glTexSubImage2D")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
				void TexSubImage2D(System.Graphics.ES10.All target, Int32 level, Int32 xoffset, Int32 yoffset, Int32 width, Int32 height, System.Graphics.ES10.All format, System.Graphics.ES10.All type, IntPtr pixels) {
			Delegates.glTexSubImage2D((System.Graphics.ES10.All) target, (Int32) level, (Int32) xoffset, (Int32) yoffset, (Int32) width, (Int32) height, (System.Graphics.ES10.All) format, (System.Graphics.ES10.All) type, (IntPtr) pixels);
		}


		/// <summary>[requires: v1.0 and 1.0]
		/// Specify a two-dimensional texture subimage
		/// </summary>
		/// <param name="target">
		/// <para>
		/// Specifies the target texture. Must be GL_TEXTURE_2D, GL_TEXTURE_CUBE_MAP_POSITIVE_X, GL_TEXTURE_CUBE_MAP_NEGATIVE_X, GL_TEXTURE_CUBE_MAP_POSITIVE_Y, GL_TEXTURE_CUBE_MAP_NEGATIVE_Y, GL_TEXTURE_CUBE_MAP_POSITIVE_Z, or GL_TEXTURE_CUBE_MAP_NEGATIVE_Z.
		/// </para>
		/// </param>
		/// <param name="level">
		/// <para>
		/// Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.
		/// </para>
		/// </param>
		/// <param name="xoffset">
		/// <para>
		/// Specifies a texel offset in the x direction within the texture array.
		/// </para>
		/// </param>
		/// <param name="yoffset">
		/// <para>
		/// Specifies a texel offset in the y direction within the texture array.
		/// </para>
		/// </param>
		/// <param name="width">
		/// <para>
		/// Specifies the width of the texture subimage.
		/// </para>
		/// </param>
		/// <param name="height">
		/// <para>
		/// Specifies the height of the texture subimage.
		/// </para>
		/// </param>
		/// <param name="format">
		/// <para>
		/// Specifies the format of the pixel data. The following symbolic values are accepted: GL_RED, GL_RG, GL_RGB, GL_BGR, GL_RGBA, and GL_BGRA.
		/// </para>
		/// </param>
		/// <param name="type">
		/// <para>
		/// Specifies the data type of the pixel data. The following symbolic values are accepted: GL_UNSIGNED_BYTE, GL_BYTE, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV.
		/// </para>
		/// </param>
		/// <param name="pixels">
		/// <para>
		/// Specifies a pointer to the image data in memory.
		/// </para>
		/// </param>
		//[AutoGenerated(Category = "1.0", Version = "1.0", EntryPoint = "glTexSubImage2D")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
				void TexSubImage2D<T8>(System.Graphics.ES10.All target, Int32 level, Int32 xoffset, Int32 yoffset, Int32 width, Int32 height, System.Graphics.ES10.All format, System.Graphics.ES10.All type, [InAttribute, OutAttribute] T8[] pixels)
					where T8 : struct {
			GCHandle pixels_ptr = GCHandle.Alloc(pixels, GCHandleType.Pinned);
			try {
				Delegates.glTexSubImage2D((System.Graphics.ES10.All) target, (Int32) level, (Int32) xoffset, (Int32) yoffset, (Int32) width, (Int32) height, (System.Graphics.ES10.All) format, (System.Graphics.ES10.All) type, (IntPtr) pixels_ptr.AddrOfPinnedObject());
			} finally {
				pixels_ptr.Free();
			}
		}


		/// <summary>[requires: v1.0 and 1.0]
		/// Specify a two-dimensional texture subimage
		/// </summary>
		/// <param name="target">
		/// <para>
		/// Specifies the target texture. Must be GL_TEXTURE_2D, GL_TEXTURE_CUBE_MAP_POSITIVE_X, GL_TEXTURE_CUBE_MAP_NEGATIVE_X, GL_TEXTURE_CUBE_MAP_POSITIVE_Y, GL_TEXTURE_CUBE_MAP_NEGATIVE_Y, GL_TEXTURE_CUBE_MAP_POSITIVE_Z, or GL_TEXTURE_CUBE_MAP_NEGATIVE_Z.
		/// </para>
		/// </param>
		/// <param name="level">
		/// <para>
		/// Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.
		/// </para>
		/// </param>
		/// <param name="xoffset">
		/// <para>
		/// Specifies a texel offset in the x direction within the texture array.
		/// </para>
		/// </param>
		/// <param name="yoffset">
		/// <para>
		/// Specifies a texel offset in the y direction within the texture array.
		/// </para>
		/// </param>
		/// <param name="width">
		/// <para>
		/// Specifies the width of the texture subimage.
		/// </para>
		/// </param>
		/// <param name="height">
		/// <para>
		/// Specifies the height of the texture subimage.
		/// </para>
		/// </param>
		/// <param name="format">
		/// <para>
		/// Specifies the format of the pixel data. The following symbolic values are accepted: GL_RED, GL_RG, GL_RGB, GL_BGR, GL_RGBA, and GL_BGRA.
		/// </para>
		/// </param>
		/// <param name="type">
		/// <para>
		/// Specifies the data type of the pixel data. The following symbolic values are accepted: GL_UNSIGNED_BYTE, GL_BYTE, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV.
		/// </para>
		/// </param>
		/// <param name="pixels">
		/// <para>
		/// Specifies a pointer to the image data in memory.
		/// </para>
		/// </param>
		//[AutoGenerated(Category = "1.0", Version = "1.0", EntryPoint = "glTexSubImage2D")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
				void TexSubImage2D<T8>(System.Graphics.ES10.All target, Int32 level, Int32 xoffset, Int32 yoffset, Int32 width, Int32 height, System.Graphics.ES10.All format, System.Graphics.ES10.All type, [InAttribute, OutAttribute] T8[,] pixels)
					where T8 : struct {
			GCHandle pixels_ptr = GCHandle.Alloc(pixels, GCHandleType.Pinned);
			try {
				Delegates.glTexSubImage2D((System.Graphics.ES10.All) target, (Int32) level, (Int32) xoffset, (Int32) yoffset, (Int32) width, (Int32) height, (System.Graphics.ES10.All) format, (System.Graphics.ES10.All) type, (IntPtr) pixels_ptr.AddrOfPinnedObject());
			} finally {
				pixels_ptr.Free();
			}
		}


		/// <summary>[requires: v1.0 and 1.0]
		/// Specify a two-dimensional texture subimage
		/// </summary>
		/// <param name="target">
		/// <para>
		/// Specifies the target texture. Must be GL_TEXTURE_2D, GL_TEXTURE_CUBE_MAP_POSITIVE_X, GL_TEXTURE_CUBE_MAP_NEGATIVE_X, GL_TEXTURE_CUBE_MAP_POSITIVE_Y, GL_TEXTURE_CUBE_MAP_NEGATIVE_Y, GL_TEXTURE_CUBE_MAP_POSITIVE_Z, or GL_TEXTURE_CUBE_MAP_NEGATIVE_Z.
		/// </para>
		/// </param>
		/// <param name="level">
		/// <para>
		/// Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.
		/// </para>
		/// </param>
		/// <param name="xoffset">
		/// <para>
		/// Specifies a texel offset in the x direction within the texture array.
		/// </para>
		/// </param>
		/// <param name="yoffset">
		/// <para>
		/// Specifies a texel offset in the y direction within the texture array.
		/// </para>
		/// </param>
		/// <param name="width">
		/// <para>
		/// Specifies the width of the texture subimage.
		/// </para>
		/// </param>
		/// <param name="height">
		/// <para>
		/// Specifies the height of the texture subimage.
		/// </para>
		/// </param>
		/// <param name="format">
		/// <para>
		/// Specifies the format of the pixel data. The following symbolic values are accepted: GL_RED, GL_RG, GL_RGB, GL_BGR, GL_RGBA, and GL_BGRA.
		/// </para>
		/// </param>
		/// <param name="type">
		/// <para>
		/// Specifies the data type of the pixel data. The following symbolic values are accepted: GL_UNSIGNED_BYTE, GL_BYTE, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV.
		/// </para>
		/// </param>
		/// <param name="pixels">
		/// <para>
		/// Specifies a pointer to the image data in memory.
		/// </para>
		/// </param>
		//[AutoGenerated(Category = "1.0", Version = "1.0", EntryPoint = "glTexSubImage2D")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
				void TexSubImage2D<T8>(System.Graphics.ES10.All target, Int32 level, Int32 xoffset, Int32 yoffset, Int32 width, Int32 height, System.Graphics.ES10.All format, System.Graphics.ES10.All type, [InAttribute, OutAttribute] T8[,,] pixels)
					where T8 : struct {
			GCHandle pixels_ptr = GCHandle.Alloc(pixels, GCHandleType.Pinned);
			try {
				Delegates.glTexSubImage2D((System.Graphics.ES10.All) target, (Int32) level, (Int32) xoffset, (Int32) yoffset, (Int32) width, (Int32) height, (System.Graphics.ES10.All) format, (System.Graphics.ES10.All) type, (IntPtr) pixels_ptr.AddrOfPinnedObject());
			} finally {
				pixels_ptr.Free();
			}
		}


		/// <summary>[requires: v1.0 and 1.0]
		/// Specify a two-dimensional texture subimage
		/// </summary>
		/// <param name="target">
		/// <para>
		/// Specifies the target texture. Must be GL_TEXTURE_2D, GL_TEXTURE_CUBE_MAP_POSITIVE_X, GL_TEXTURE_CUBE_MAP_NEGATIVE_X, GL_TEXTURE_CUBE_MAP_POSITIVE_Y, GL_TEXTURE_CUBE_MAP_NEGATIVE_Y, GL_TEXTURE_CUBE_MAP_POSITIVE_Z, or GL_TEXTURE_CUBE_MAP_NEGATIVE_Z.
		/// </para>
		/// </param>
		/// <param name="level">
		/// <para>
		/// Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.
		/// </para>
		/// </param>
		/// <param name="xoffset">
		/// <para>
		/// Specifies a texel offset in the x direction within the texture array.
		/// </para>
		/// </param>
		/// <param name="yoffset">
		/// <para>
		/// Specifies a texel offset in the y direction within the texture array.
		/// </para>
		/// </param>
		/// <param name="width">
		/// <para>
		/// Specifies the width of the texture subimage.
		/// </para>
		/// </param>
		/// <param name="height">
		/// <para>
		/// Specifies the height of the texture subimage.
		/// </para>
		/// </param>
		/// <param name="format">
		/// <para>
		/// Specifies the format of the pixel data. The following symbolic values are accepted: GL_RED, GL_RG, GL_RGB, GL_BGR, GL_RGBA, and GL_BGRA.
		/// </para>
		/// </param>
		/// <param name="type">
		/// <para>
		/// Specifies the data type of the pixel data. The following symbolic values are accepted: GL_UNSIGNED_BYTE, GL_BYTE, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV.
		/// </para>
		/// </param>
		/// <param name="pixels">
		/// <para>
		/// Specifies a pointer to the image data in memory.
		/// </para>
		/// </param>
		//[AutoGenerated(Category = "1.0", Version = "1.0", EntryPoint = "glTexSubImage2D")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
				void TexSubImage2D<T8>(System.Graphics.ES10.All target, Int32 level, Int32 xoffset, Int32 yoffset, Int32 width, Int32 height, System.Graphics.ES10.All format, System.Graphics.ES10.All type, [InAttribute, OutAttribute] ref T8 pixels)
					where T8 : struct {
			GCHandle pixels_ptr = GCHandle.Alloc(pixels, GCHandleType.Pinned);
			try {
				Delegates.glTexSubImage2D((System.Graphics.ES10.All) target, (Int32) level, (Int32) xoffset, (Int32) yoffset, (Int32) width, (Int32) height, (System.Graphics.ES10.All) format, (System.Graphics.ES10.All) type, (IntPtr) pixels_ptr.AddrOfPinnedObject());
				pixels = (T8) pixels_ptr.Target;
			} finally {
				pixels_ptr.Free();
			}
		}


		/// <summary>[requires: v1.0 and 1.0]
		/// Multiply the current matrix by a translation matrix
		/// </summary>
		//[AutoGenerated(Category = "1.0", Version = "1.0", EntryPoint = "glTranslatef")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
				void Translate(Single x, Single y, Single z) {
			Delegates.glTranslatef((Single) x, (Single) y, (Single) z);
		}

		/// <summary>[requires: v1.0 and 1.0]</summary>
		//[AutoGenerated(Category = "1.0", Version = "1.0", EntryPoint = "glTranslatex")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
				void Translatex(int x, int y, int z) {
			Delegates.glTranslatex((int) x, (int) y, (int) z);
		}


		/// <summary>[requires: v1.0 and 1.0]
		/// Define an array of vertex data
		/// </summary>
		/// <param name="size">
		/// <para>
		/// Specifies the number of coordinates per vertex. Must be 2, 3, or 4. The initial value is 4.
		/// </para>
		/// </param>
		/// <param name="type">
		/// <para>
		/// Specifies the data type of each coordinate in the array. Symbolic constants GL_SHORT, GL_INT, GL_FLOAT, or GL_DOUBLE are accepted. The initial value is GL_FLOAT.
		/// </para>
		/// </param>
		/// <param name="stride">
		/// <para>
		/// Specifies the byte offset between consecutive points. If stride is 0, the points are understood to be tightly packed in the array. The initial value is 0.
		/// </para>
		/// </param>
		/// <param name="pointer">
		/// <para>
		/// Specifies a pointer to the first coordinate of the first vertex in the array. The initial value is 0.
		/// </para>
		/// </param>
		//[AutoGenerated(Category = "1.0", Version = "1.0", EntryPoint = "glVertexPointer")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
				void VertexPointer(Int32 size, System.Graphics.ES10.All type, Int32 stride, IntPtr pointer) {
			Delegates.glVertexPointer((Int32) size, (System.Graphics.ES10.All) type, (Int32) stride, (IntPtr) pointer);
		}


		/// <summary>[requires: v1.0 and 1.0]
		/// Define an array of vertex data
		/// </summary>
		/// <param name="size">
		/// <para>
		/// Specifies the number of coordinates per vertex. Must be 2, 3, or 4. The initial value is 4.
		/// </para>
		/// </param>
		/// <param name="type">
		/// <para>
		/// Specifies the data type of each coordinate in the array. Symbolic constants GL_SHORT, GL_INT, GL_FLOAT, or GL_DOUBLE are accepted. The initial value is GL_FLOAT.
		/// </para>
		/// </param>
		/// <param name="stride">
		/// <para>
		/// Specifies the byte offset between consecutive points. If stride is 0, the points are understood to be tightly packed in the array. The initial value is 0.
		/// </para>
		/// </param>
		/// <param name="pointer">
		/// <para>
		/// Specifies a pointer to the first coordinate of the first vertex in the array. The initial value is 0.
		/// </para>
		/// </param>
		//[AutoGenerated(Category = "1.0", Version = "1.0", EntryPoint = "glVertexPointer")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
				void VertexPointer<T3>(Int32 size, System.Graphics.ES10.All type, Int32 stride, [InAttribute, OutAttribute] T3[] pointer)
					where T3 : struct {
			GCHandle pointer_ptr = GCHandle.Alloc(pointer, GCHandleType.Pinned);
			try {
				Delegates.glVertexPointer((Int32) size, (System.Graphics.ES10.All) type, (Int32) stride, (IntPtr) pointer_ptr.AddrOfPinnedObject());
			} finally {
				pointer_ptr.Free();
			}
		}


		/// <summary>[requires: v1.0 and 1.0]
		/// Define an array of vertex data
		/// </summary>
		/// <param name="size">
		/// <para>
		/// Specifies the number of coordinates per vertex. Must be 2, 3, or 4. The initial value is 4.
		/// </para>
		/// </param>
		/// <param name="type">
		/// <para>
		/// Specifies the data type of each coordinate in the array. Symbolic constants GL_SHORT, GL_INT, GL_FLOAT, or GL_DOUBLE are accepted. The initial value is GL_FLOAT.
		/// </para>
		/// </param>
		/// <param name="stride">
		/// <para>
		/// Specifies the byte offset between consecutive points. If stride is 0, the points are understood to be tightly packed in the array. The initial value is 0.
		/// </para>
		/// </param>
		/// <param name="pointer">
		/// <para>
		/// Specifies a pointer to the first coordinate of the first vertex in the array. The initial value is 0.
		/// </para>
		/// </param>
		//[AutoGenerated(Category = "1.0", Version = "1.0", EntryPoint = "glVertexPointer")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
				void VertexPointer<T3>(Int32 size, System.Graphics.ES10.All type, Int32 stride, [InAttribute, OutAttribute] T3[,] pointer)
					where T3 : struct {
			GCHandle pointer_ptr = GCHandle.Alloc(pointer, GCHandleType.Pinned);
			try {
				Delegates.glVertexPointer((Int32) size, (System.Graphics.ES10.All) type, (Int32) stride, (IntPtr) pointer_ptr.AddrOfPinnedObject());
			} finally {
				pointer_ptr.Free();
			}
		}


		/// <summary>[requires: v1.0 and 1.0]
		/// Define an array of vertex data
		/// </summary>
		/// <param name="size">
		/// <para>
		/// Specifies the number of coordinates per vertex. Must be 2, 3, or 4. The initial value is 4.
		/// </para>
		/// </param>
		/// <param name="type">
		/// <para>
		/// Specifies the data type of each coordinate in the array. Symbolic constants GL_SHORT, GL_INT, GL_FLOAT, or GL_DOUBLE are accepted. The initial value is GL_FLOAT.
		/// </para>
		/// </param>
		/// <param name="stride">
		/// <para>
		/// Specifies the byte offset between consecutive points. If stride is 0, the points are understood to be tightly packed in the array. The initial value is 0.
		/// </para>
		/// </param>
		/// <param name="pointer">
		/// <para>
		/// Specifies a pointer to the first coordinate of the first vertex in the array. The initial value is 0.
		/// </para>
		/// </param>
		//[AutoGenerated(Category = "1.0", Version = "1.0", EntryPoint = "glVertexPointer")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
				void VertexPointer<T3>(Int32 size, System.Graphics.ES10.All type, Int32 stride, [InAttribute, OutAttribute] T3[,,] pointer)
					where T3 : struct {
			GCHandle pointer_ptr = GCHandle.Alloc(pointer, GCHandleType.Pinned);
			try {
				Delegates.glVertexPointer((Int32) size, (System.Graphics.ES10.All) type, (Int32) stride, (IntPtr) pointer_ptr.AddrOfPinnedObject());
			} finally {
				pointer_ptr.Free();
			}
		}


		/// <summary>[requires: v1.0 and 1.0]
		/// Define an array of vertex data
		/// </summary>
		/// <param name="size">
		/// <para>
		/// Specifies the number of coordinates per vertex. Must be 2, 3, or 4. The initial value is 4.
		/// </para>
		/// </param>
		/// <param name="type">
		/// <para>
		/// Specifies the data type of each coordinate in the array. Symbolic constants GL_SHORT, GL_INT, GL_FLOAT, or GL_DOUBLE are accepted. The initial value is GL_FLOAT.
		/// </para>
		/// </param>
		/// <param name="stride">
		/// <para>
		/// Specifies the byte offset between consecutive points. If stride is 0, the points are understood to be tightly packed in the array. The initial value is 0.
		/// </para>
		/// </param>
		/// <param name="pointer">
		/// <para>
		/// Specifies a pointer to the first coordinate of the first vertex in the array. The initial value is 0.
		/// </para>
		/// </param>
		//[AutoGenerated(Category = "1.0", Version = "1.0", EntryPoint = "glVertexPointer")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
				void VertexPointer<T3>(Int32 size, System.Graphics.ES10.All type, Int32 stride, [InAttribute, OutAttribute] ref T3 pointer)
					where T3 : struct {
			GCHandle pointer_ptr = GCHandle.Alloc(pointer, GCHandleType.Pinned);
			try {
				Delegates.glVertexPointer((Int32) size, (System.Graphics.ES10.All) type, (Int32) stride, (IntPtr) pointer_ptr.AddrOfPinnedObject());
				pointer = (T3) pointer_ptr.Target;
			} finally {
				pointer_ptr.Free();
			}
		}


		/// <summary>[requires: v1.0 and 1.0]
		/// Set the viewport
		/// </summary>
		/// <param name="x">
		/// <para>
		/// Specify the lower left corner of the viewport rectangle, in pixels. The initial value is (0,0).
		/// </para>
		/// </param>
		/// <param name="y">
		/// <para>
		/// Specify the lower left corner of the viewport rectangle, in pixels. The initial value is (0,0).
		/// </para>
		/// </param>
		/// <param name="width">
		/// <para>
		/// Specify the width and height of the viewport. When a GL context is first attached to a window, width and height are set to the dimensions of that window.
		/// </para>
		/// </param>
		/// <param name="height">
		/// <para>
		/// Specify the width and height of the viewport. When a GL context is first attached to a window, width and height are set to the dimensions of that window.
		/// </para>
		/// </param>
		//[AutoGenerated(Category = "1.0", Version = "1.0", EntryPoint = "glViewport")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
				void Viewport(Int32 x, Int32 y, Int32 width, Int32 height) {
			Delegates.glViewport((Int32) x, (Int32) y, (Int32) width, (Int32) height);
		}


	}
}

#pragma warning restore 1572
#pragma warning restore 1573