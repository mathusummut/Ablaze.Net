//Ported from OpenTK, and excellent library.

using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

namespace System.Graphics.ES11 {
	/// <summary>
	/// An abstraction layer for all OpenGL|ES 1.1 functions.
	/// </summary>
	[Security.SuppressUnmanagedCodeSecurity]
	public static partial class GL {
		/// <summary>
		/// The name of the OpenGL|ES library.
		/// </summary>
		public const string Library = "libGLES.dll";
		/// <summary>
		/// The native prefix of every GL function.
		/// </summary>
		public const string Prefix = "gl";

		/// <summary>[requires: v1.1 and 1.1]
		/// Select active texture unit
		/// </summary>
		/// <param name="texture">
		/// <para>
		/// Specifies which texture unit to make active. The number of texture units is implementation dependent, but must be at least two. texture must be one of GL_TEXTUREi, where i ranges from 0 (GL_MAX_COMBINED_TEXTURE_IMAGE_UNITS - 1). The initial value is GL_TEXTURE0.
		/// </para>
		/// </param>
		//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glActiveTexture")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
				void ActiveTexture(System.Graphics.ES11.All texture) {
			Delegates.glActiveTexture((System.Graphics.ES11.All) texture);
		}


		/// <summary>[requires: v1.1 and 1.1]
		/// Specify the alpha test function
		/// </summary>
		/// <param name="func">
		/// <para>
		/// Specifies the alpha comparison function. Symbolic constants GL_NEVER, GL_LESS, GL_EQUAL, GL_LEQUAL, GL_GREATER, GL_NOTEQUAL, GL_GEQUAL, and GL_ALWAYS are accepted. The initial value is GL_ALWAYS.
		/// </para>
		/// </param>
		/// <param name="ref">
		/// <para>
		/// Specifies the reference value that incoming alpha values are compared to. This value is clamped to the range [0,1], where 0 represents the lowest possible alpha value and 1 the highest possible value. The initial reference value is 0.
		/// </para>
		/// </param>
		//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glAlphaFunc")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
				void AlphaFunc(System.Graphics.ES11.All func, Single @ref) {
			Delegates.glAlphaFunc((System.Graphics.ES11.All) func, (Single) @ref);
		}

		/// <summary>[requires: v1.1 and 1.1]</summary>
		//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glAlphaFuncx")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
				void AlphaFuncx(System.Graphics.ES11.All func, int @ref) {
			Delegates.glAlphaFuncx((System.Graphics.ES11.All) func, (int) @ref);
		}


		/// <summary>[requires: v1.1 and 1.1]
		/// Bind a named buffer object
		/// </summary>
		/// <param name="target">
		/// <para>
		/// Specifies the target to which the buffer object is bound. The symbolic constant must be GL_ARRAY_BUFFER, GL_COPY_READ_BUFFER, GL_COPY_WRITE_BUFFER, GL_ELEMENT_ARRAY_BUFFER, GL_PIXEL_PACK_BUFFER, GL_PIXEL_UNPACK_BUFFER, GL_TEXTURE_BUFFER, GL_TRANSFORM_FEEDBACK_BUFFER, or GL_UNIFORM_BUFFER.
		/// </para>
		/// </param>
		/// <param name="buffer">
		/// <para>
		/// Specifies the name of a buffer object.
		/// </para>
		/// </param>
		//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glBindBuffer")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
				void BindBuffer(System.Graphics.ES11.All target, Int32 buffer) {
			Delegates.glBindBuffer((System.Graphics.ES11.All) target, (UInt32) buffer);
		}


		/// <summary>[requires: v1.1 and 1.1]
		/// Bind a named buffer object
		/// </summary>
		/// <param name="target">
		/// <para>
		/// Specifies the target to which the buffer object is bound. The symbolic constant must be GL_ARRAY_BUFFER, GL_COPY_READ_BUFFER, GL_COPY_WRITE_BUFFER, GL_ELEMENT_ARRAY_BUFFER, GL_PIXEL_PACK_BUFFER, GL_PIXEL_UNPACK_BUFFER, GL_TEXTURE_BUFFER, GL_TRANSFORM_FEEDBACK_BUFFER, or GL_UNIFORM_BUFFER.
		/// </para>
		/// </param>
		/// <param name="buffer">
		/// <para>
		/// Specifies the name of a buffer object.
		/// </para>
		/// </param>
		[System.CLSCompliant(false)]
		//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glBindBuffer")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
		void BindBuffer(System.Graphics.ES11.All target, UInt32 buffer) {
			Delegates.glBindBuffer((System.Graphics.ES11.All) target, (UInt32) buffer);
		}


		/// <summary>[requires: v1.1 and 1.1]
		/// Bind a named texture to a texturing target
		/// </summary>
		/// <param name="target">
		/// <para>
		/// Specifies the target to which the texture is bound. Must be either GL_TEXTURE_1D, GL_TEXTURE_2D, GL_TEXTURE_3D, or GL_TEXTURE_1D_ARRAY, GL_TEXTURE_2D_ARRAY, GL_TEXTURE_RECTANGLE, GL_TEXTURE_CUBE_MAP, GL_TEXTURE_2D_MULTISAMPLE or GL_TEXTURE_2D_MULTISAMPLE_ARRAY.
		/// </para>
		/// </param>
		/// <param name="texture">
		/// <para>
		/// Specifies the name of a texture.
		/// </para>
		/// </param>
		//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glBindTexture")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
				void BindTexture(System.Graphics.ES11.All target, Int32 texture) {
			Delegates.glBindTexture((System.Graphics.ES11.All) target, (UInt32) texture);
		}


		/// <summary>[requires: v1.1 and 1.1]
		/// Bind a named texture to a texturing target
		/// </summary>
		/// <param name="target">
		/// <para>
		/// Specifies the target to which the texture is bound. Must be either GL_TEXTURE_1D, GL_TEXTURE_2D, GL_TEXTURE_3D, or GL_TEXTURE_1D_ARRAY, GL_TEXTURE_2D_ARRAY, GL_TEXTURE_RECTANGLE, GL_TEXTURE_CUBE_MAP, GL_TEXTURE_2D_MULTISAMPLE or GL_TEXTURE_2D_MULTISAMPLE_ARRAY.
		/// </para>
		/// </param>
		/// <param name="texture">
		/// <para>
		/// Specifies the name of a texture.
		/// </para>
		/// </param>
		[System.CLSCompliant(false)]
		//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glBindTexture")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
		void BindTexture(System.Graphics.ES11.All target, UInt32 texture) {
			Delegates.glBindTexture((System.Graphics.ES11.All) target, (UInt32) texture);
		}


		/// <summary>[requires: v1.1 and 1.1]
		/// Specify pixel arithmetic
		/// </summary>
		/// <param name="sfactor">
		/// <para>
		/// Specifies how the red, green, blue, and alpha source blending factors are computed. The initial value is GL_ONE.
		/// </para>
		/// </param>
		/// <param name="dfactor">
		/// <para>
		/// Specifies how the red, green, blue, and alpha destination blending factors are computed. The following symbolic constants are accepted: GL_ZERO, GL_ONE, GL_SRC_COLOR, GL_ONE_MINUS_SRC_COLOR, GL_DST_COLOR, GL_ONE_MINUS_DST_COLOR, GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA, GL_DST_ALPHA, GL_ONE_MINUS_DST_ALPHA. GL_CONSTANT_COLOR, GL_ONE_MINUS_CONSTANT_COLOR, GL_CONSTANT_ALPHA, and GL_ONE_MINUS_CONSTANT_ALPHA. The initial value is GL_ZERO.
		/// </para>
		/// </param>
		//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glBlendFunc")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
				void BlendFunc(System.Graphics.ES11.All sfactor, System.Graphics.ES11.All dfactor) {
			Delegates.glBlendFunc((System.Graphics.ES11.All) sfactor, (System.Graphics.ES11.All) dfactor);
		}


		/// <summary>[requires: v1.1 and 1.1]
		/// Creates and initializes a buffer object's data store
		/// </summary>
		/// <param name="target">
		/// <para>
		/// Specifies the target buffer object. The symbolic constant must be GL_ARRAY_BUFFER, GL_COPY_READ_BUFFER, GL_COPY_WRITE_BUFFER, GL_ELEMENT_ARRAY_BUFFER, GL_PIXEL_PACK_BUFFER, GL_PIXEL_UNPACK_BUFFER, GL_TEXTURE_BUFFER, GL_TRANSFORM_FEEDBACK_BUFFER, or GL_UNIFORM_BUFFER.
		/// </para>
		/// </param>
		/// <param name="size">
		/// <para>
		/// Specifies the size in bytes of the buffer object's new data store.
		/// </para>
		/// </param>
		/// <param name="data">
		/// <para>
		/// Specifies a pointer to data that will be copied into the data store for initialization, or NULL if no data is to be copied.
		/// </para>
		/// </param>
		/// <param name="usage">
		/// <para>
		/// Specifies the expected usage pattern of the data store. The symbolic constant must be GL_STREAM_DRAW, GL_STREAM_READ, GL_STREAM_COPY, GL_STATIC_DRAW, GL_STATIC_READ, GL_STATIC_COPY, GL_DYNAMIC_DRAW, GL_DYNAMIC_READ, or GL_DYNAMIC_COPY.
		/// </para>
		/// </param>
		//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glBufferData")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
				void BufferData(System.Graphics.ES11.All target, IntPtr size, IntPtr data, System.Graphics.ES11.All usage) {
			Delegates.glBufferData((System.Graphics.ES11.All) target, (IntPtr) size, (IntPtr) data, (System.Graphics.ES11.All) usage);
		}


		/// <summary>[requires: v1.1 and 1.1]
		/// Creates and initializes a buffer object's data store
		/// </summary>
		/// <param name="target">
		/// <para>
		/// Specifies the target buffer object. The symbolic constant must be GL_ARRAY_BUFFER, GL_COPY_READ_BUFFER, GL_COPY_WRITE_BUFFER, GL_ELEMENT_ARRAY_BUFFER, GL_PIXEL_PACK_BUFFER, GL_PIXEL_UNPACK_BUFFER, GL_TEXTURE_BUFFER, GL_TRANSFORM_FEEDBACK_BUFFER, or GL_UNIFORM_BUFFER.
		/// </para>
		/// </param>
		/// <param name="size">
		/// <para>
		/// Specifies the size in bytes of the buffer object's new data store.
		/// </para>
		/// </param>
		/// <param name="data">
		/// <para>
		/// Specifies a pointer to data that will be copied into the data store for initialization, or NULL if no data is to be copied.
		/// </para>
		/// </param>
		/// <param name="usage">
		/// <para>
		/// Specifies the expected usage pattern of the data store. The symbolic constant must be GL_STREAM_DRAW, GL_STREAM_READ, GL_STREAM_COPY, GL_STATIC_DRAW, GL_STATIC_READ, GL_STATIC_COPY, GL_DYNAMIC_DRAW, GL_DYNAMIC_READ, or GL_DYNAMIC_COPY.
		/// </para>
		/// </param>
		//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glBufferData")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
				void BufferData<T2>(System.Graphics.ES11.All target, IntPtr size, [InAttribute, OutAttribute] T2[] data, System.Graphics.ES11.All usage)
					where T2 : struct {
			GCHandle data_ptr = GCHandle.Alloc(data, GCHandleType.Pinned);
			try {
				Delegates.glBufferData((System.Graphics.ES11.All) target, (IntPtr) size, (IntPtr) data_ptr.AddrOfPinnedObject(), (System.Graphics.ES11.All) usage);
			} finally {
				data_ptr.Free();
			}
		}


		/// <summary>[requires: v1.1 and 1.1]
		/// Creates and initializes a buffer object's data store
		/// </summary>
		/// <param name="target">
		/// <para>
		/// Specifies the target buffer object. The symbolic constant must be GL_ARRAY_BUFFER, GL_COPY_READ_BUFFER, GL_COPY_WRITE_BUFFER, GL_ELEMENT_ARRAY_BUFFER, GL_PIXEL_PACK_BUFFER, GL_PIXEL_UNPACK_BUFFER, GL_TEXTURE_BUFFER, GL_TRANSFORM_FEEDBACK_BUFFER, or GL_UNIFORM_BUFFER.
		/// </para>
		/// </param>
		/// <param name="size">
		/// <para>
		/// Specifies the size in bytes of the buffer object's new data store.
		/// </para>
		/// </param>
		/// <param name="data">
		/// <para>
		/// Specifies a pointer to data that will be copied into the data store for initialization, or NULL if no data is to be copied.
		/// </para>
		/// </param>
		/// <param name="usage">
		/// <para>
		/// Specifies the expected usage pattern of the data store. The symbolic constant must be GL_STREAM_DRAW, GL_STREAM_READ, GL_STREAM_COPY, GL_STATIC_DRAW, GL_STATIC_READ, GL_STATIC_COPY, GL_DYNAMIC_DRAW, GL_DYNAMIC_READ, or GL_DYNAMIC_COPY.
		/// </para>
		/// </param>
		//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glBufferData")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
				void BufferData<T2>(System.Graphics.ES11.All target, IntPtr size, [InAttribute, OutAttribute] T2[,] data, System.Graphics.ES11.All usage)
					where T2 : struct {
			GCHandle data_ptr = GCHandle.Alloc(data, GCHandleType.Pinned);
			try {
				Delegates.glBufferData((System.Graphics.ES11.All) target, (IntPtr) size, (IntPtr) data_ptr.AddrOfPinnedObject(), (System.Graphics.ES11.All) usage);
			} finally {
				data_ptr.Free();
			}
		}


		/// <summary>[requires: v1.1 and 1.1]
		/// Creates and initializes a buffer object's data store
		/// </summary>
		/// <param name="target">
		/// <para>
		/// Specifies the target buffer object. The symbolic constant must be GL_ARRAY_BUFFER, GL_COPY_READ_BUFFER, GL_COPY_WRITE_BUFFER, GL_ELEMENT_ARRAY_BUFFER, GL_PIXEL_PACK_BUFFER, GL_PIXEL_UNPACK_BUFFER, GL_TEXTURE_BUFFER, GL_TRANSFORM_FEEDBACK_BUFFER, or GL_UNIFORM_BUFFER.
		/// </para>
		/// </param>
		/// <param name="size">
		/// <para>
		/// Specifies the size in bytes of the buffer object's new data store.
		/// </para>
		/// </param>
		/// <param name="data">
		/// <para>
		/// Specifies a pointer to data that will be copied into the data store for initialization, or NULL if no data is to be copied.
		/// </para>
		/// </param>
		/// <param name="usage">
		/// <para>
		/// Specifies the expected usage pattern of the data store. The symbolic constant must be GL_STREAM_DRAW, GL_STREAM_READ, GL_STREAM_COPY, GL_STATIC_DRAW, GL_STATIC_READ, GL_STATIC_COPY, GL_DYNAMIC_DRAW, GL_DYNAMIC_READ, or GL_DYNAMIC_COPY.
		/// </para>
		/// </param>
		//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glBufferData")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
				void BufferData<T2>(System.Graphics.ES11.All target, IntPtr size, [InAttribute, OutAttribute] T2[,,] data, System.Graphics.ES11.All usage)
					where T2 : struct {
			GCHandle data_ptr = GCHandle.Alloc(data, GCHandleType.Pinned);
			try {
				Delegates.glBufferData((System.Graphics.ES11.All) target, (IntPtr) size, (IntPtr) data_ptr.AddrOfPinnedObject(), (System.Graphics.ES11.All) usage);
			} finally {
				data_ptr.Free();
			}
		}


		/// <summary>[requires: v1.1 and 1.1]
		/// Creates and initializes a buffer object's data store
		/// </summary>
		/// <param name="target">
		/// <para>
		/// Specifies the target buffer object. The symbolic constant must be GL_ARRAY_BUFFER, GL_COPY_READ_BUFFER, GL_COPY_WRITE_BUFFER, GL_ELEMENT_ARRAY_BUFFER, GL_PIXEL_PACK_BUFFER, GL_PIXEL_UNPACK_BUFFER, GL_TEXTURE_BUFFER, GL_TRANSFORM_FEEDBACK_BUFFER, or GL_UNIFORM_BUFFER.
		/// </para>
		/// </param>
		/// <param name="size">
		/// <para>
		/// Specifies the size in bytes of the buffer object's new data store.
		/// </para>
		/// </param>
		/// <param name="data">
		/// <para>
		/// Specifies a pointer to data that will be copied into the data store for initialization, or NULL if no data is to be copied.
		/// </para>
		/// </param>
		/// <param name="usage">
		/// <para>
		/// Specifies the expected usage pattern of the data store. The symbolic constant must be GL_STREAM_DRAW, GL_STREAM_READ, GL_STREAM_COPY, GL_STATIC_DRAW, GL_STATIC_READ, GL_STATIC_COPY, GL_DYNAMIC_DRAW, GL_DYNAMIC_READ, or GL_DYNAMIC_COPY.
		/// </para>
		/// </param>
		//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glBufferData")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
				void BufferData<T2>(System.Graphics.ES11.All target, IntPtr size, [InAttribute, OutAttribute] ref T2 data, System.Graphics.ES11.All usage)
					where T2 : struct {
			GCHandle data_ptr = GCHandle.Alloc(data, GCHandleType.Pinned);
			try {
				Delegates.glBufferData((System.Graphics.ES11.All) target, (IntPtr) size, (IntPtr) data_ptr.AddrOfPinnedObject(), (System.Graphics.ES11.All) usage);
				data = (T2) data_ptr.Target;
			} finally {
				data_ptr.Free();
			}
		}


		/// <summary>[requires: v1.1 and 1.1]
		/// Updates a subset of a buffer object's data store
		/// </summary>
		/// <param name="target">
		/// <para>
		/// Specifies the target buffer object. The symbolic constant must be GL_ARRAY_BUFFER, GL_COPY_READ_BUFFER, GL_COPY_WRITE_BUFFER, GL_ELEMENT_ARRAY_BUFFER, GL_PIXEL_PACK_BUFFER, GL_PIXEL_UNPACK_BUFFER, GL_TEXTURE_BUFFER, GL_TRANSFORM_FEEDBACK_BUFFER, or GL_UNIFORM_BUFFER.
		/// </para>
		/// </param>
		/// <param name="offset">
		/// <para>
		/// Specifies the offset into the buffer object's data store where data replacement will begin, measured in bytes.
		/// </para>
		/// </param>
		/// <param name="size">
		/// <para>
		/// Specifies the size in bytes of the data store region being replaced.
		/// </para>
		/// </param>
		/// <param name="data">
		/// <para>
		/// Specifies a pointer to the new data that will be copied into the data store.
		/// </para>
		/// </param>
		//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glBufferSubData")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
				void BufferSubData(System.Graphics.ES11.All target, IntPtr offset, IntPtr size, IntPtr data) {
			Delegates.glBufferSubData((System.Graphics.ES11.All) target, (IntPtr) offset, (IntPtr) size, (IntPtr) data);
		}


		/// <summary>[requires: v1.1 and 1.1]
		/// Updates a subset of a buffer object's data store
		/// </summary>
		/// <param name="target">
		/// <para>
		/// Specifies the target buffer object. The symbolic constant must be GL_ARRAY_BUFFER, GL_COPY_READ_BUFFER, GL_COPY_WRITE_BUFFER, GL_ELEMENT_ARRAY_BUFFER, GL_PIXEL_PACK_BUFFER, GL_PIXEL_UNPACK_BUFFER, GL_TEXTURE_BUFFER, GL_TRANSFORM_FEEDBACK_BUFFER, or GL_UNIFORM_BUFFER.
		/// </para>
		/// </param>
		/// <param name="offset">
		/// <para>
		/// Specifies the offset into the buffer object's data store where data replacement will begin, measured in bytes.
		/// </para>
		/// </param>
		/// <param name="size">
		/// <para>
		/// Specifies the size in bytes of the data store region being replaced.
		/// </para>
		/// </param>
		/// <param name="data">
		/// <para>
		/// Specifies a pointer to the new data that will be copied into the data store.
		/// </para>
		/// </param>
		//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glBufferSubData")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
				void BufferSubData<T3>(System.Graphics.ES11.All target, IntPtr offset, IntPtr size, [InAttribute, OutAttribute] T3[] data)
					where T3 : struct {
			GCHandle data_ptr = GCHandle.Alloc(data, GCHandleType.Pinned);
			try {
				Delegates.glBufferSubData((System.Graphics.ES11.All) target, (IntPtr) offset, (IntPtr) size, (IntPtr) data_ptr.AddrOfPinnedObject());
			} finally {
				data_ptr.Free();
			}
		}


		/// <summary>[requires: v1.1 and 1.1]
		/// Updates a subset of a buffer object's data store
		/// </summary>
		/// <param name="target">
		/// <para>
		/// Specifies the target buffer object. The symbolic constant must be GL_ARRAY_BUFFER, GL_COPY_READ_BUFFER, GL_COPY_WRITE_BUFFER, GL_ELEMENT_ARRAY_BUFFER, GL_PIXEL_PACK_BUFFER, GL_PIXEL_UNPACK_BUFFER, GL_TEXTURE_BUFFER, GL_TRANSFORM_FEEDBACK_BUFFER, or GL_UNIFORM_BUFFER.
		/// </para>
		/// </param>
		/// <param name="offset">
		/// <para>
		/// Specifies the offset into the buffer object's data store where data replacement will begin, measured in bytes.
		/// </para>
		/// </param>
		/// <param name="size">
		/// <para>
		/// Specifies the size in bytes of the data store region being replaced.
		/// </para>
		/// </param>
		/// <param name="data">
		/// <para>
		/// Specifies a pointer to the new data that will be copied into the data store.
		/// </para>
		/// </param>
		//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glBufferSubData")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
				void BufferSubData<T3>(System.Graphics.ES11.All target, IntPtr offset, IntPtr size, [InAttribute, OutAttribute] T3[,] data)
					where T3 : struct {
			GCHandle data_ptr = GCHandle.Alloc(data, GCHandleType.Pinned);
			try {
				Delegates.glBufferSubData((System.Graphics.ES11.All) target, (IntPtr) offset, (IntPtr) size, (IntPtr) data_ptr.AddrOfPinnedObject());
			} finally {
				data_ptr.Free();
			}
		}


		/// <summary>[requires: v1.1 and 1.1]
		/// Updates a subset of a buffer object's data store
		/// </summary>
		/// <param name="target">
		/// <para>
		/// Specifies the target buffer object. The symbolic constant must be GL_ARRAY_BUFFER, GL_COPY_READ_BUFFER, GL_COPY_WRITE_BUFFER, GL_ELEMENT_ARRAY_BUFFER, GL_PIXEL_PACK_BUFFER, GL_PIXEL_UNPACK_BUFFER, GL_TEXTURE_BUFFER, GL_TRANSFORM_FEEDBACK_BUFFER, or GL_UNIFORM_BUFFER.
		/// </para>
		/// </param>
		/// <param name="offset">
		/// <para>
		/// Specifies the offset into the buffer object's data store where data replacement will begin, measured in bytes.
		/// </para>
		/// </param>
		/// <param name="size">
		/// <para>
		/// Specifies the size in bytes of the data store region being replaced.
		/// </para>
		/// </param>
		/// <param name="data">
		/// <para>
		/// Specifies a pointer to the new data that will be copied into the data store.
		/// </para>
		/// </param>
		//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glBufferSubData")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
				void BufferSubData<T3>(System.Graphics.ES11.All target, IntPtr offset, IntPtr size, [InAttribute, OutAttribute] T3[,,] data)
					where T3 : struct {
			GCHandle data_ptr = GCHandle.Alloc(data, GCHandleType.Pinned);
			try {
				Delegates.glBufferSubData((System.Graphics.ES11.All) target, (IntPtr) offset, (IntPtr) size, (IntPtr) data_ptr.AddrOfPinnedObject());
			} finally {
				data_ptr.Free();
			}
		}


		/// <summary>[requires: v1.1 and 1.1]
		/// Updates a subset of a buffer object's data store
		/// </summary>
		/// <param name="target">
		/// <para>
		/// Specifies the target buffer object. The symbolic constant must be GL_ARRAY_BUFFER, GL_COPY_READ_BUFFER, GL_COPY_WRITE_BUFFER, GL_ELEMENT_ARRAY_BUFFER, GL_PIXEL_PACK_BUFFER, GL_PIXEL_UNPACK_BUFFER, GL_TEXTURE_BUFFER, GL_TRANSFORM_FEEDBACK_BUFFER, or GL_UNIFORM_BUFFER.
		/// </para>
		/// </param>
		/// <param name="offset">
		/// <para>
		/// Specifies the offset into the buffer object's data store where data replacement will begin, measured in bytes.
		/// </para>
		/// </param>
		/// <param name="size">
		/// <para>
		/// Specifies the size in bytes of the data store region being replaced.
		/// </para>
		/// </param>
		/// <param name="data">
		/// <para>
		/// Specifies a pointer to the new data that will be copied into the data store.
		/// </para>
		/// </param>
		//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glBufferSubData")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
				void BufferSubData<T3>(System.Graphics.ES11.All target, IntPtr offset, IntPtr size, [InAttribute, OutAttribute] ref T3 data)
					where T3 : struct {
			GCHandle data_ptr = GCHandle.Alloc(data, GCHandleType.Pinned);
			try {
				Delegates.glBufferSubData((System.Graphics.ES11.All) target, (IntPtr) offset, (IntPtr) size, (IntPtr) data_ptr.AddrOfPinnedObject());
				data = (T3) data_ptr.Target;
			} finally {
				data_ptr.Free();
			}
		}


		/// <summary>[requires: v1.1 and 1.1]
		/// Clear buffers to preset values
		/// </summary>
		/// <param name="mask">
		/// <para>
		/// Bitwise OR of masks that indicate the buffers to be cleared. The three masks are GL_COLOR_BUFFER_BIT, GL_DEPTH_BUFFER_BIT, and GL_STENCIL_BUFFER_BIT.
		/// </para>
		/// </param>
		//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glClear")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
				void Clear(Int32 mask) {
			Delegates.glClear((UInt32) mask);
		}


		/// <summary>[requires: v1.1 and 1.1]
		/// Clear buffers to preset values
		/// </summary>
		/// <param name="mask">
		/// <para>
		/// Bitwise OR of masks that indicate the buffers to be cleared. The three masks are GL_COLOR_BUFFER_BIT, GL_DEPTH_BUFFER_BIT, and GL_STENCIL_BUFFER_BIT.
		/// </para>
		/// </param>
		[System.CLSCompliant(false)]
		//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glClear")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
		void Clear(UInt32 mask) {
			Delegates.glClear((UInt32) mask);
		}


		/// <summary>[requires: v1.1 and 1.1]
		/// Specify clear values for the color buffers
		/// </summary>
		//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glClearColor")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
				void ClearColor(Single red, Single green, Single blue, Single alpha) {
			Delegates.glClearColor((Single) red, (Single) green, (Single) blue, (Single) alpha);
		}

		/// <summary>[requires: v1.1 and 1.1]</summary>
		//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glClearColorx")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
				void ClearColorx(int red, int green, int blue, int alpha) {
			Delegates.glClearColorx((int) red, (int) green, (int) blue, (int) alpha);
		}


		/// <summary>[requires: v1.1 and 1.1]
		/// Specify the clear value for the depth buffer
		/// </summary>
		/// <param name="depth">
		/// <para>
		/// Specifies the depth value used when the depth buffer is cleared. The initial value is 1.
		/// </para>
		/// </param>
		//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glClearDepthf")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
				void ClearDepth(Single depth) {
			Delegates.glClearDepthf((Single) depth);
		}

		/// <summary>[requires: v1.1 and 1.1]</summary>
		//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glClearDepthx")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
				void ClearDepthx(int depth) {
			Delegates.glClearDepthx((int) depth);
		}


		/// <summary>[requires: v1.1 and 1.1]
		/// Specify the clear value for the stencil buffer
		/// </summary>
		/// <param name="s">
		/// <para>
		/// Specifies the index used when the stencil buffer is cleared. The initial value is 0.
		/// </para>
		/// </param>
		//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glClearStencil")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
				void ClearStencil(Int32 s) {
			Delegates.glClearStencil((Int32) s);
		}


		/// <summary>[requires: v1.1 and 1.1]
		/// Select active texture unit
		/// </summary>
		/// <param name="texture">
		/// <para>
		/// Specifies which texture unit to make active. The number of texture units is implementation dependent, but must be at least two. texture must be one of GL_TEXTURE, where i ranges from 0 to the value of GL_MAX_TEXTURE_COORDS - 1, which is an implementation-dependent value. The initial value is GL_TEXTURE0.
		/// </para>
		/// </param>
		//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glClientActiveTexture")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
				void ClientActiveTexture(System.Graphics.ES11.All texture) {
			Delegates.glClientActiveTexture((System.Graphics.ES11.All) texture);
		}


		/// <summary>[requires: v1.1 and 1.1]
		/// Specify a plane against which all geometry is clipped
		/// </summary>
		/// <param name="plane">
		/// <para>
		/// Specifies which clipping plane is being positioned. Symbolic names of the form GL_CLIP_PLANEi, where i is an integer between 0 and GL_MAX_CLIP_PLANES - 1, are accepted.
		/// </para>
		/// </param>
		/// <param name="equation">
		/// <para>
		/// Specifies the address of an array of four double-precision floating-point values. These values are interpreted as a plane equation.
		/// </para>
		/// </param>
		//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glClipPlanef")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
				void ClipPlane(System.Graphics.ES11.All plane, Single[] equation) {
			unsafe
			{
				fixed (Single* equation_ptr = equation) {
					Delegates.glClipPlanef((System.Graphics.ES11.All) plane, (Single*) equation_ptr);
				}
			}
		}


		/// <summary>[requires: v1.1 and 1.1]
		/// Specify a plane against which all geometry is clipped
		/// </summary>
		/// <param name="plane">
		/// <para>
		/// Specifies which clipping plane is being positioned. Symbolic names of the form GL_CLIP_PLANEi, where i is an integer between 0 and GL_MAX_CLIP_PLANES - 1, are accepted.
		/// </para>
		/// </param>
		/// <param name="equation">
		/// <para>
		/// Specifies the address of an array of four double-precision floating-point values. These values are interpreted as a plane equation.
		/// </para>
		/// </param>
		//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glClipPlanef")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
				void ClipPlane(System.Graphics.ES11.All plane, ref Single equation) {
			unsafe
			{
				fixed (Single* equation_ptr = &equation) {
					Delegates.glClipPlanef((System.Graphics.ES11.All) plane, (Single*) equation_ptr);
				}
			}
		}


		/// <summary>[requires: v1.1 and 1.1]
		/// Specify a plane against which all geometry is clipped
		/// </summary>
		/// <param name="plane">
		/// <para>
		/// Specifies which clipping plane is being positioned. Symbolic names of the form GL_CLIP_PLANEi, where i is an integer between 0 and GL_MAX_CLIP_PLANES - 1, are accepted.
		/// </para>
		/// </param>
		/// <param name="equation">
		/// <para>
		/// Specifies the address of an array of four double-precision floating-point values. These values are interpreted as a plane equation.
		/// </para>
		/// </param>
		[System.CLSCompliant(false)]
		//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glClipPlanef")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
		unsafe void ClipPlane(System.Graphics.ES11.All plane, Single* equation) {
			Delegates.glClipPlanef((System.Graphics.ES11.All) plane, (Single*) equation);
		}

		/// <summary>[requires: v1.1 and 1.1]</summary>
		//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glClipPlanefIMG")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
				void ClipPlanefIMG(System.Graphics.ES11.All p, Single[] eqn) {
			unsafe
			{
				fixed (Single* eqn_ptr = eqn) {
					Delegates.glClipPlanefIMG((System.Graphics.ES11.All) p, (Single*) eqn_ptr);
				}
			}
		}

		/// <summary>[requires: v1.1 and 1.1]</summary>
		//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glClipPlanefIMG")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
				void ClipPlanefIMG(System.Graphics.ES11.All p, ref Single eqn) {
			unsafe
			{
				fixed (Single* eqn_ptr = &eqn) {
					Delegates.glClipPlanefIMG((System.Graphics.ES11.All) p, (Single*) eqn_ptr);
				}
			}
		}

		/// <summary>[requires: v1.1 and 1.1]</summary>
		[System.CLSCompliant(false)]
		//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glClipPlanefIMG")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
		unsafe void ClipPlanefIMG(System.Graphics.ES11.All p, Single* eqn) {
			Delegates.glClipPlanefIMG((System.Graphics.ES11.All) p, (Single*) eqn);
		}

		/// <summary>[requires: v1.1 and 1.1]</summary>
		//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glClipPlanex")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
				void ClipPlanex(System.Graphics.ES11.All plane, int[] equation) {
			unsafe
			{
				fixed (int* equation_ptr = equation) {
					Delegates.glClipPlanex((System.Graphics.ES11.All) plane, (int*) equation_ptr);
				}
			}
		}

		/// <summary>[requires: v1.1 and 1.1]</summary>
		//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glClipPlanex")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
				void ClipPlanex(System.Graphics.ES11.All plane, ref int equation) {
			unsafe
			{
				fixed (int* equation_ptr = &equation) {
					Delegates.glClipPlanex((System.Graphics.ES11.All) plane, (int*) equation_ptr);
				}
			}
		}

		/// <summary>[requires: v1.1 and 1.1]</summary>
		[System.CLSCompliant(false)]
		//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glClipPlanex")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
		unsafe void ClipPlanex(System.Graphics.ES11.All plane, int* equation) {
			Delegates.glClipPlanex((System.Graphics.ES11.All) plane, (int*) equation);
		}

		/// <summary>[requires: v1.1 and 1.1]</summary>
		//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glClipPlanexIMG")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
				void ClipPlanexIMG(System.Graphics.ES11.All p, int[] eqn) {
			unsafe
			{
				fixed (int* eqn_ptr = eqn) {
					Delegates.glClipPlanexIMG((System.Graphics.ES11.All) p, (int*) eqn_ptr);
				}
			}
		}

		/// <summary>[requires: v1.1 and 1.1]</summary>
		//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glClipPlanexIMG")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
				void ClipPlanexIMG(System.Graphics.ES11.All p, ref int eqn) {
			unsafe
			{
				fixed (int* eqn_ptr = &eqn) {
					Delegates.glClipPlanexIMG((System.Graphics.ES11.All) p, (int*) eqn_ptr);
				}
			}
		}

		/// <summary>[requires: v1.1 and 1.1]</summary>
		[System.CLSCompliant(false)]
		//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glClipPlanexIMG")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
		unsafe void ClipPlanexIMG(System.Graphics.ES11.All p, int* eqn) {
			Delegates.glClipPlanexIMG((System.Graphics.ES11.All) p, (int*) eqn);
		}


		/// <summary>[requires: v1.1 and 1.1]
		/// Set the current color
		/// </summary>
		//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glColor4f")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
				void Color4(Single red, Single green, Single blue, Single alpha) {
			Delegates.glColor4f((Single) red, (Single) green, (Single) blue, (Single) alpha);
		}


		/// <summary>[requires: v1.1 and 1.1]
		/// Set the current color
		/// </summary>
		//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glColor4ub")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
				void Color4(Byte red, Byte green, Byte blue, Byte alpha) {
			Delegates.glColor4ub((Byte) red, (Byte) green, (Byte) blue, (Byte) alpha);
		}

		/// <summary>[requires: v1.1 and 1.1]</summary>
		//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glColor4x")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
				void Color4x(int red, int green, int blue, int alpha) {
			Delegates.glColor4x((int) red, (int) green, (int) blue, (int) alpha);
		}


		/// <summary>[requires: v1.1 and 1.1]
		/// Enable and disable writing of frame buffer color components
		/// </summary>
		//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glColorMask")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
				void ColorMask(bool red, bool green, bool blue, bool alpha) {
			Delegates.glColorMask((bool) red, (bool) green, (bool) blue, (bool) alpha);
		}


		/// <summary>[requires: v1.1 and 1.1]
		/// Define an array of colors
		/// </summary>
		/// <param name="size">
		/// <para>
		/// Specifies the number of components per color. Must be 3 or 4. The initial value is 4.
		/// </para>
		/// </param>
		/// <param name="type">
		/// <para>
		/// Specifies the data type of each color component in the array. Symbolic constants GL_BYTE, GL_UNSIGNED_BYTE, GL_SHORT, GL_UNSIGNED_SHORT, GL_INT, GL_UNSIGNED_INT, GL_FLOAT, and GL_DOUBLE are accepted. The initial value is GL_FLOAT.
		/// </para>
		/// </param>
		/// <param name="stride">
		/// <para>
		/// Specifies the byte offset between consecutive colors. If stride is 0, the colors are understood to be tightly packed in the array. The initial value is 0.
		/// </para>
		/// </param>
		/// <param name="pointer">
		/// <para>
		/// Specifies a pointer to the first component of the first color element in the array. The initial value is 0.
		/// </para>
		/// </param>
		//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glColorPointer")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
				void ColorPointer(Int32 size, System.Graphics.ES11.All type, Int32 stride, IntPtr pointer) {
			Delegates.glColorPointer((Int32) size, (System.Graphics.ES11.All) type, (Int32) stride, (IntPtr) pointer);
		}


		/// <summary>[requires: v1.1 and 1.1]
		/// Define an array of colors
		/// </summary>
		/// <param name="size">
		/// <para>
		/// Specifies the number of components per color. Must be 3 or 4. The initial value is 4.
		/// </para>
		/// </param>
		/// <param name="type">
		/// <para>
		/// Specifies the data type of each color component in the array. Symbolic constants GL_BYTE, GL_UNSIGNED_BYTE, GL_SHORT, GL_UNSIGNED_SHORT, GL_INT, GL_UNSIGNED_INT, GL_FLOAT, and GL_DOUBLE are accepted. The initial value is GL_FLOAT.
		/// </para>
		/// </param>
		/// <param name="stride">
		/// <para>
		/// Specifies the byte offset between consecutive colors. If stride is 0, the colors are understood to be tightly packed in the array. The initial value is 0.
		/// </para>
		/// </param>
		/// <param name="pointer">
		/// <para>
		/// Specifies a pointer to the first component of the first color element in the array. The initial value is 0.
		/// </para>
		/// </param>
		//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glColorPointer")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
				void ColorPointer<T3>(Int32 size, System.Graphics.ES11.All type, Int32 stride, [InAttribute, OutAttribute] T3[] pointer)
					where T3 : struct {
			GCHandle pointer_ptr = GCHandle.Alloc(pointer, GCHandleType.Pinned);
			try {
				Delegates.glColorPointer((Int32) size, (System.Graphics.ES11.All) type, (Int32) stride, (IntPtr) pointer_ptr.AddrOfPinnedObject());
			} finally {
				pointer_ptr.Free();
			}
		}


		/// <summary>[requires: v1.1 and 1.1]
		/// Define an array of colors
		/// </summary>
		/// <param name="size">
		/// <para>
		/// Specifies the number of components per color. Must be 3 or 4. The initial value is 4.
		/// </para>
		/// </param>
		/// <param name="type">
		/// <para>
		/// Specifies the data type of each color component in the array. Symbolic constants GL_BYTE, GL_UNSIGNED_BYTE, GL_SHORT, GL_UNSIGNED_SHORT, GL_INT, GL_UNSIGNED_INT, GL_FLOAT, and GL_DOUBLE are accepted. The initial value is GL_FLOAT.
		/// </para>
		/// </param>
		/// <param name="stride">
		/// <para>
		/// Specifies the byte offset between consecutive colors. If stride is 0, the colors are understood to be tightly packed in the array. The initial value is 0.
		/// </para>
		/// </param>
		/// <param name="pointer">
		/// <para>
		/// Specifies a pointer to the first component of the first color element in the array. The initial value is 0.
		/// </para>
		/// </param>
		//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glColorPointer")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
				void ColorPointer<T3>(Int32 size, System.Graphics.ES11.All type, Int32 stride, [InAttribute, OutAttribute] T3[,] pointer)
					where T3 : struct {
			GCHandle pointer_ptr = GCHandle.Alloc(pointer, GCHandleType.Pinned);
			try {
				Delegates.glColorPointer((Int32) size, (System.Graphics.ES11.All) type, (Int32) stride, (IntPtr) pointer_ptr.AddrOfPinnedObject());
			} finally {
				pointer_ptr.Free();
			}
		}


		/// <summary>[requires: v1.1 and 1.1]
		/// Define an array of colors
		/// </summary>
		/// <param name="size">
		/// <para>
		/// Specifies the number of components per color. Must be 3 or 4. The initial value is 4.
		/// </para>
		/// </param>
		/// <param name="type">
		/// <para>
		/// Specifies the data type of each color component in the array. Symbolic constants GL_BYTE, GL_UNSIGNED_BYTE, GL_SHORT, GL_UNSIGNED_SHORT, GL_INT, GL_UNSIGNED_INT, GL_FLOAT, and GL_DOUBLE are accepted. The initial value is GL_FLOAT.
		/// </para>
		/// </param>
		/// <param name="stride">
		/// <para>
		/// Specifies the byte offset between consecutive colors. If stride is 0, the colors are understood to be tightly packed in the array. The initial value is 0.
		/// </para>
		/// </param>
		/// <param name="pointer">
		/// <para>
		/// Specifies a pointer to the first component of the first color element in the array. The initial value is 0.
		/// </para>
		/// </param>
		//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glColorPointer")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
				void ColorPointer<T3>(Int32 size, System.Graphics.ES11.All type, Int32 stride, [InAttribute, OutAttribute] T3[,,] pointer)
					where T3 : struct {
			GCHandle pointer_ptr = GCHandle.Alloc(pointer, GCHandleType.Pinned);
			try {
				Delegates.glColorPointer((Int32) size, (System.Graphics.ES11.All) type, (Int32) stride, (IntPtr) pointer_ptr.AddrOfPinnedObject());
			} finally {
				pointer_ptr.Free();
			}
		}


		/// <summary>[requires: v1.1 and 1.1]
		/// Define an array of colors
		/// </summary>
		/// <param name="size">
		/// <para>
		/// Specifies the number of components per color. Must be 3 or 4. The initial value is 4.
		/// </para>
		/// </param>
		/// <param name="type">
		/// <para>
		/// Specifies the data type of each color component in the array. Symbolic constants GL_BYTE, GL_UNSIGNED_BYTE, GL_SHORT, GL_UNSIGNED_SHORT, GL_INT, GL_UNSIGNED_INT, GL_FLOAT, and GL_DOUBLE are accepted. The initial value is GL_FLOAT.
		/// </para>
		/// </param>
		/// <param name="stride">
		/// <para>
		/// Specifies the byte offset between consecutive colors. If stride is 0, the colors are understood to be tightly packed in the array. The initial value is 0.
		/// </para>
		/// </param>
		/// <param name="pointer">
		/// <para>
		/// Specifies a pointer to the first component of the first color element in the array. The initial value is 0.
		/// </para>
		/// </param>
		//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glColorPointer")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
				void ColorPointer<T3>(Int32 size, System.Graphics.ES11.All type, Int32 stride, [InAttribute, OutAttribute] ref T3 pointer)
					where T3 : struct {
			GCHandle pointer_ptr = GCHandle.Alloc(pointer, GCHandleType.Pinned);
			try {
				Delegates.glColorPointer((Int32) size, (System.Graphics.ES11.All) type, (Int32) stride, (IntPtr) pointer_ptr.AddrOfPinnedObject());
				pointer = (T3) pointer_ptr.Target;
			} finally {
				pointer_ptr.Free();
			}
		}


		/// <summary>[requires: v1.1 and 1.1]
		/// Specify a two-dimensional texture image in a compressed format
		/// </summary>
		/// <param name="target">
		/// <para>
		/// Specifies the target texture. Must be GL_TEXTURE_2D, GL_PROXY_TEXTURE_2D, GL_TEXTURE_1D_ARRAY, GL_PROXY_TEXTURE_1D_ARRAY, GL_TEXTURE_CUBE_MAP_POSITIVE_X, GL_TEXTURE_CUBE_MAP_NEGATIVE_X, GL_TEXTURE_CUBE_MAP_POSITIVE_Y, GL_TEXTURE_CUBE_MAP_NEGATIVE_Y, GL_TEXTURE_CUBE_MAP_POSITIVE_Z, GL_TEXTURE_CUBE_MAP_NEGATIVE_Z, or GL_PROXY_TEXTURE_CUBE_MAP.
		/// </para>
		/// </param>
		/// <param name="level">
		/// <para>
		/// Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.
		/// </para>
		/// </param>
		/// <param name="internalformat">
		/// <para>
		/// Specifies the format of the compressed image data stored at address data.
		/// </para>
		/// </param>
		/// <param name="width">
		/// <para>
		/// Specifies the width of the texture image. All implementations support 2D texture images that are at least 64 texels wide and cube-mapped texture images that are at least 16 texels wide.
		/// </para>
		/// </param>
		/// <param name="height">
		/// <para>
		/// Specifies the height of the texture image. All implementations support 2D texture images that are at least 64 texels high and cube-mapped texture images that are at least 16 texels high.
		/// </para>
		/// </param>
		/// <param name="border">
		/// <para>
		/// This value must be 0.
		/// </para>
		/// </param>
		/// <param name="imageSize">
		/// <para>
		/// Specifies the number of unsigned bytes of image data starting at the address specified by data.
		/// </para>
		/// </param>
		/// <param name="data">
		/// <para>
		/// Specifies a pointer to the compressed image data in memory.
		/// </para>
		/// </param>
		//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glCompressedTexImage2D")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
				void CompressedTexImage2D(System.Graphics.ES11.All target, Int32 level, System.Graphics.ES11.All internalformat, Int32 width, Int32 height, Int32 border, Int32 imageSize, IntPtr data) {
			Delegates.glCompressedTexImage2D((System.Graphics.ES11.All) target, (Int32) level, (System.Graphics.ES11.All) internalformat, (Int32) width, (Int32) height, (Int32) border, (Int32) imageSize, (IntPtr) data);
		}


		/// <summary>[requires: v1.1 and 1.1]
		/// Specify a two-dimensional texture image in a compressed format
		/// </summary>
		/// <param name="target">
		/// <para>
		/// Specifies the target texture. Must be GL_TEXTURE_2D, GL_PROXY_TEXTURE_2D, GL_TEXTURE_1D_ARRAY, GL_PROXY_TEXTURE_1D_ARRAY, GL_TEXTURE_CUBE_MAP_POSITIVE_X, GL_TEXTURE_CUBE_MAP_NEGATIVE_X, GL_TEXTURE_CUBE_MAP_POSITIVE_Y, GL_TEXTURE_CUBE_MAP_NEGATIVE_Y, GL_TEXTURE_CUBE_MAP_POSITIVE_Z, GL_TEXTURE_CUBE_MAP_NEGATIVE_Z, or GL_PROXY_TEXTURE_CUBE_MAP.
		/// </para>
		/// </param>
		/// <param name="level">
		/// <para>
		/// Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.
		/// </para>
		/// </param>
		/// <param name="internalformat">
		/// <para>
		/// Specifies the format of the compressed image data stored at address data.
		/// </para>
		/// </param>
		/// <param name="width">
		/// <para>
		/// Specifies the width of the texture image. All implementations support 2D texture images that are at least 64 texels wide and cube-mapped texture images that are at least 16 texels wide.
		/// </para>
		/// </param>
		/// <param name="height">
		/// <para>
		/// Specifies the height of the texture image. All implementations support 2D texture images that are at least 64 texels high and cube-mapped texture images that are at least 16 texels high.
		/// </para>
		/// </param>
		/// <param name="border">
		/// <para>
		/// This value must be 0.
		/// </para>
		/// </param>
		/// <param name="imageSize">
		/// <para>
		/// Specifies the number of unsigned bytes of image data starting at the address specified by data.
		/// </para>
		/// </param>
		/// <param name="data">
		/// <para>
		/// Specifies a pointer to the compressed image data in memory.
		/// </para>
		/// </param>
		//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glCompressedTexImage2D")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
				void CompressedTexImage2D<T7>(System.Graphics.ES11.All target, Int32 level, System.Graphics.ES11.All internalformat, Int32 width, Int32 height, Int32 border, Int32 imageSize, [InAttribute, OutAttribute] T7[] data)
					where T7 : struct {
			GCHandle data_ptr = GCHandle.Alloc(data, GCHandleType.Pinned);
			try {
				Delegates.glCompressedTexImage2D((System.Graphics.ES11.All) target, (Int32) level, (System.Graphics.ES11.All) internalformat, (Int32) width, (Int32) height, (Int32) border, (Int32) imageSize, (IntPtr) data_ptr.AddrOfPinnedObject());
			} finally {
				data_ptr.Free();
			}
		}


		/// <summary>[requires: v1.1 and 1.1]
		/// Specify a two-dimensional texture image in a compressed format
		/// </summary>
		/// <param name="target">
		/// <para>
		/// Specifies the target texture. Must be GL_TEXTURE_2D, GL_PROXY_TEXTURE_2D, GL_TEXTURE_1D_ARRAY, GL_PROXY_TEXTURE_1D_ARRAY, GL_TEXTURE_CUBE_MAP_POSITIVE_X, GL_TEXTURE_CUBE_MAP_NEGATIVE_X, GL_TEXTURE_CUBE_MAP_POSITIVE_Y, GL_TEXTURE_CUBE_MAP_NEGATIVE_Y, GL_TEXTURE_CUBE_MAP_POSITIVE_Z, GL_TEXTURE_CUBE_MAP_NEGATIVE_Z, or GL_PROXY_TEXTURE_CUBE_MAP.
		/// </para>
		/// </param>
		/// <param name="level">
		/// <para>
		/// Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.
		/// </para>
		/// </param>
		/// <param name="internalformat">
		/// <para>
		/// Specifies the format of the compressed image data stored at address data.
		/// </para>
		/// </param>
		/// <param name="width">
		/// <para>
		/// Specifies the width of the texture image. All implementations support 2D texture images that are at least 64 texels wide and cube-mapped texture images that are at least 16 texels wide.
		/// </para>
		/// </param>
		/// <param name="height">
		/// <para>
		/// Specifies the height of the texture image. All implementations support 2D texture images that are at least 64 texels high and cube-mapped texture images that are at least 16 texels high.
		/// </para>
		/// </param>
		/// <param name="border">
		/// <para>
		/// This value must be 0.
		/// </para>
		/// </param>
		/// <param name="imageSize">
		/// <para>
		/// Specifies the number of unsigned bytes of image data starting at the address specified by data.
		/// </para>
		/// </param>
		/// <param name="data">
		/// <para>
		/// Specifies a pointer to the compressed image data in memory.
		/// </para>
		/// </param>
		//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glCompressedTexImage2D")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
				void CompressedTexImage2D<T7>(System.Graphics.ES11.All target, Int32 level, System.Graphics.ES11.All internalformat, Int32 width, Int32 height, Int32 border, Int32 imageSize, [InAttribute, OutAttribute] T7[,] data)
					where T7 : struct {
			GCHandle data_ptr = GCHandle.Alloc(data, GCHandleType.Pinned);
			try {
				Delegates.glCompressedTexImage2D((System.Graphics.ES11.All) target, (Int32) level, (System.Graphics.ES11.All) internalformat, (Int32) width, (Int32) height, (Int32) border, (Int32) imageSize, (IntPtr) data_ptr.AddrOfPinnedObject());
			} finally {
				data_ptr.Free();
			}
		}


		/// <summary>[requires: v1.1 and 1.1]
		/// Specify a two-dimensional texture image in a compressed format
		/// </summary>
		/// <param name="target">
		/// <para>
		/// Specifies the target texture. Must be GL_TEXTURE_2D, GL_PROXY_TEXTURE_2D, GL_TEXTURE_1D_ARRAY, GL_PROXY_TEXTURE_1D_ARRAY, GL_TEXTURE_CUBE_MAP_POSITIVE_X, GL_TEXTURE_CUBE_MAP_NEGATIVE_X, GL_TEXTURE_CUBE_MAP_POSITIVE_Y, GL_TEXTURE_CUBE_MAP_NEGATIVE_Y, GL_TEXTURE_CUBE_MAP_POSITIVE_Z, GL_TEXTURE_CUBE_MAP_NEGATIVE_Z, or GL_PROXY_TEXTURE_CUBE_MAP.
		/// </para>
		/// </param>
		/// <param name="level">
		/// <para>
		/// Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.
		/// </para>
		/// </param>
		/// <param name="internalformat">
		/// <para>
		/// Specifies the format of the compressed image data stored at address data.
		/// </para>
		/// </param>
		/// <param name="width">
		/// <para>
		/// Specifies the width of the texture image. All implementations support 2D texture images that are at least 64 texels wide and cube-mapped texture images that are at least 16 texels wide.
		/// </para>
		/// </param>
		/// <param name="height">
		/// <para>
		/// Specifies the height of the texture image. All implementations support 2D texture images that are at least 64 texels high and cube-mapped texture images that are at least 16 texels high.
		/// </para>
		/// </param>
		/// <param name="border">
		/// <para>
		/// This value must be 0.
		/// </para>
		/// </param>
		/// <param name="imageSize">
		/// <para>
		/// Specifies the number of unsigned bytes of image data starting at the address specified by data.
		/// </para>
		/// </param>
		/// <param name="data">
		/// <para>
		/// Specifies a pointer to the compressed image data in memory.
		/// </para>
		/// </param>
		//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glCompressedTexImage2D")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
				void CompressedTexImage2D<T7>(System.Graphics.ES11.All target, Int32 level, System.Graphics.ES11.All internalformat, Int32 width, Int32 height, Int32 border, Int32 imageSize, [InAttribute, OutAttribute] T7[,,] data)
					where T7 : struct {
			GCHandle data_ptr = GCHandle.Alloc(data, GCHandleType.Pinned);
			try {
				Delegates.glCompressedTexImage2D((System.Graphics.ES11.All) target, (Int32) level, (System.Graphics.ES11.All) internalformat, (Int32) width, (Int32) height, (Int32) border, (Int32) imageSize, (IntPtr) data_ptr.AddrOfPinnedObject());
			} finally {
				data_ptr.Free();
			}
		}


		/// <summary>[requires: v1.1 and 1.1]
		/// Specify a two-dimensional texture image in a compressed format
		/// </summary>
		/// <param name="target">
		/// <para>
		/// Specifies the target texture. Must be GL_TEXTURE_2D, GL_PROXY_TEXTURE_2D, GL_TEXTURE_1D_ARRAY, GL_PROXY_TEXTURE_1D_ARRAY, GL_TEXTURE_CUBE_MAP_POSITIVE_X, GL_TEXTURE_CUBE_MAP_NEGATIVE_X, GL_TEXTURE_CUBE_MAP_POSITIVE_Y, GL_TEXTURE_CUBE_MAP_NEGATIVE_Y, GL_TEXTURE_CUBE_MAP_POSITIVE_Z, GL_TEXTURE_CUBE_MAP_NEGATIVE_Z, or GL_PROXY_TEXTURE_CUBE_MAP.
		/// </para>
		/// </param>
		/// <param name="level">
		/// <para>
		/// Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.
		/// </para>
		/// </param>
		/// <param name="internalformat">
		/// <para>
		/// Specifies the format of the compressed image data stored at address data.
		/// </para>
		/// </param>
		/// <param name="width">
		/// <para>
		/// Specifies the width of the texture image. All implementations support 2D texture images that are at least 64 texels wide and cube-mapped texture images that are at least 16 texels wide.
		/// </para>
		/// </param>
		/// <param name="height">
		/// <para>
		/// Specifies the height of the texture image. All implementations support 2D texture images that are at least 64 texels high and cube-mapped texture images that are at least 16 texels high.
		/// </para>
		/// </param>
		/// <param name="border">
		/// <para>
		/// This value must be 0.
		/// </para>
		/// </param>
		/// <param name="imageSize">
		/// <para>
		/// Specifies the number of unsigned bytes of image data starting at the address specified by data.
		/// </para>
		/// </param>
		/// <param name="data">
		/// <para>
		/// Specifies a pointer to the compressed image data in memory.
		/// </para>
		/// </param>
		//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glCompressedTexImage2D")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
				void CompressedTexImage2D<T7>(System.Graphics.ES11.All target, Int32 level, System.Graphics.ES11.All internalformat, Int32 width, Int32 height, Int32 border, Int32 imageSize, [InAttribute, OutAttribute] ref T7 data)
					where T7 : struct {
			GCHandle data_ptr = GCHandle.Alloc(data, GCHandleType.Pinned);
			try {
				Delegates.glCompressedTexImage2D((System.Graphics.ES11.All) target, (Int32) level, (System.Graphics.ES11.All) internalformat, (Int32) width, (Int32) height, (Int32) border, (Int32) imageSize, (IntPtr) data_ptr.AddrOfPinnedObject());
				data = (T7) data_ptr.Target;
			} finally {
				data_ptr.Free();
			}
		}


		/// <summary>[requires: v1.1 and 1.1]
		/// Specify a two-dimensional texture subimage in a compressed format
		/// </summary>
		/// <param name="target">
		/// <para>
		/// Specifies the target texture. Must be GL_TEXTURE_2D, GL_TEXTURE_CUBE_MAP_POSITIVE_X, GL_TEXTURE_CUBE_MAP_NEGATIVE_X, GL_TEXTURE_CUBE_MAP_POSITIVE_Y, GL_TEXTURE_CUBE_MAP_NEGATIVE_Y, GL_TEXTURE_CUBE_MAP_POSITIVE_Z, or GL_TEXTURE_CUBE_MAP_NEGATIVE_Z.
		/// </para>
		/// </param>
		/// <param name="level">
		/// <para>
		/// Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.
		/// </para>
		/// </param>
		/// <param name="xoffset">
		/// <para>
		/// Specifies a texel offset in the x direction within the texture array.
		/// </para>
		/// </param>
		/// <param name="yoffset">
		/// <para>
		/// Specifies a texel offset in the y direction within the texture array.
		/// </para>
		/// </param>
		/// <param name="width">
		/// <para>
		/// Specifies the width of the texture subimage.
		/// </para>
		/// </param>
		/// <param name="height">
		/// <para>
		/// Specifies the height of the texture subimage.
		/// </para>
		/// </param>
		/// <param name="format">
		/// <para>
		/// Specifies the format of the compressed image data stored at address data.
		/// </para>
		/// </param>
		/// <param name="imageSize">
		/// <para>
		/// Specifies the number of unsigned bytes of image data starting at the address specified by data.
		/// </para>
		/// </param>
		/// <param name="data">
		/// <para>
		/// Specifies a pointer to the compressed image data in memory.
		/// </para>
		/// </param>
		//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glCompressedTexSubImage2D")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
				void CompressedTexSubImage2D(System.Graphics.ES11.All target, Int32 level, Int32 xoffset, Int32 yoffset, Int32 width, Int32 height, System.Graphics.ES11.All format, Int32 imageSize, IntPtr data) {
			Delegates.glCompressedTexSubImage2D((System.Graphics.ES11.All) target, (Int32) level, (Int32) xoffset, (Int32) yoffset, (Int32) width, (Int32) height, (System.Graphics.ES11.All) format, (Int32) imageSize, (IntPtr) data);
		}


		/// <summary>[requires: v1.1 and 1.1]
		/// Specify a two-dimensional texture subimage in a compressed format
		/// </summary>
		/// <param name="target">
		/// <para>
		/// Specifies the target texture. Must be GL_TEXTURE_2D, GL_TEXTURE_CUBE_MAP_POSITIVE_X, GL_TEXTURE_CUBE_MAP_NEGATIVE_X, GL_TEXTURE_CUBE_MAP_POSITIVE_Y, GL_TEXTURE_CUBE_MAP_NEGATIVE_Y, GL_TEXTURE_CUBE_MAP_POSITIVE_Z, or GL_TEXTURE_CUBE_MAP_NEGATIVE_Z.
		/// </para>
		/// </param>
		/// <param name="level">
		/// <para>
		/// Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.
		/// </para>
		/// </param>
		/// <param name="xoffset">
		/// <para>
		/// Specifies a texel offset in the x direction within the texture array.
		/// </para>
		/// </param>
		/// <param name="yoffset">
		/// <para>
		/// Specifies a texel offset in the y direction within the texture array.
		/// </para>
		/// </param>
		/// <param name="width">
		/// <para>
		/// Specifies the width of the texture subimage.
		/// </para>
		/// </param>
		/// <param name="height">
		/// <para>
		/// Specifies the height of the texture subimage.
		/// </para>
		/// </param>
		/// <param name="format">
		/// <para>
		/// Specifies the format of the compressed image data stored at address data.
		/// </para>
		/// </param>
		/// <param name="imageSize">
		/// <para>
		/// Specifies the number of unsigned bytes of image data starting at the address specified by data.
		/// </para>
		/// </param>
		/// <param name="data">
		/// <para>
		/// Specifies a pointer to the compressed image data in memory.
		/// </para>
		/// </param>
		//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glCompressedTexSubImage2D")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
				void CompressedTexSubImage2D<T8>(System.Graphics.ES11.All target, Int32 level, Int32 xoffset, Int32 yoffset, Int32 width, Int32 height, System.Graphics.ES11.All format, Int32 imageSize, [InAttribute, OutAttribute] T8[] data)
					where T8 : struct {
			GCHandle data_ptr = GCHandle.Alloc(data, GCHandleType.Pinned);
			try {
				Delegates.glCompressedTexSubImage2D((System.Graphics.ES11.All) target, (Int32) level, (Int32) xoffset, (Int32) yoffset, (Int32) width, (Int32) height, (System.Graphics.ES11.All) format, (Int32) imageSize, (IntPtr) data_ptr.AddrOfPinnedObject());
			} finally {
				data_ptr.Free();
			}
		}


		/// <summary>[requires: v1.1 and 1.1]
		/// Specify a two-dimensional texture subimage in a compressed format
		/// </summary>
		/// <param name="target">
		/// <para>
		/// Specifies the target texture. Must be GL_TEXTURE_2D, GL_TEXTURE_CUBE_MAP_POSITIVE_X, GL_TEXTURE_CUBE_MAP_NEGATIVE_X, GL_TEXTURE_CUBE_MAP_POSITIVE_Y, GL_TEXTURE_CUBE_MAP_NEGATIVE_Y, GL_TEXTURE_CUBE_MAP_POSITIVE_Z, or GL_TEXTURE_CUBE_MAP_NEGATIVE_Z.
		/// </para>
		/// </param>
		/// <param name="level">
		/// <para>
		/// Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.
		/// </para>
		/// </param>
		/// <param name="xoffset">
		/// <para>
		/// Specifies a texel offset in the x direction within the texture array.
		/// </para>
		/// </param>
		/// <param name="yoffset">
		/// <para>
		/// Specifies a texel offset in the y direction within the texture array.
		/// </para>
		/// </param>
		/// <param name="width">
		/// <para>
		/// Specifies the width of the texture subimage.
		/// </para>
		/// </param>
		/// <param name="height">
		/// <para>
		/// Specifies the height of the texture subimage.
		/// </para>
		/// </param>
		/// <param name="format">
		/// <para>
		/// Specifies the format of the compressed image data stored at address data.
		/// </para>
		/// </param>
		/// <param name="imageSize">
		/// <para>
		/// Specifies the number of unsigned bytes of image data starting at the address specified by data.
		/// </para>
		/// </param>
		/// <param name="data">
		/// <para>
		/// Specifies a pointer to the compressed image data in memory.
		/// </para>
		/// </param>
		//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glCompressedTexSubImage2D")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
				void CompressedTexSubImage2D<T8>(System.Graphics.ES11.All target, Int32 level, Int32 xoffset, Int32 yoffset, Int32 width, Int32 height, System.Graphics.ES11.All format, Int32 imageSize, [InAttribute, OutAttribute] T8[,] data)
					where T8 : struct {
			GCHandle data_ptr = GCHandle.Alloc(data, GCHandleType.Pinned);
			try {
				Delegates.glCompressedTexSubImage2D((System.Graphics.ES11.All) target, (Int32) level, (Int32) xoffset, (Int32) yoffset, (Int32) width, (Int32) height, (System.Graphics.ES11.All) format, (Int32) imageSize, (IntPtr) data_ptr.AddrOfPinnedObject());
			} finally {
				data_ptr.Free();
			}
		}


		/// <summary>[requires: v1.1 and 1.1]
		/// Specify a two-dimensional texture subimage in a compressed format
		/// </summary>
		/// <param name="target">
		/// <para>
		/// Specifies the target texture. Must be GL_TEXTURE_2D, GL_TEXTURE_CUBE_MAP_POSITIVE_X, GL_TEXTURE_CUBE_MAP_NEGATIVE_X, GL_TEXTURE_CUBE_MAP_POSITIVE_Y, GL_TEXTURE_CUBE_MAP_NEGATIVE_Y, GL_TEXTURE_CUBE_MAP_POSITIVE_Z, or GL_TEXTURE_CUBE_MAP_NEGATIVE_Z.
		/// </para>
		/// </param>
		/// <param name="level">
		/// <para>
		/// Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.
		/// </para>
		/// </param>
		/// <param name="xoffset">
		/// <para>
		/// Specifies a texel offset in the x direction within the texture array.
		/// </para>
		/// </param>
		/// <param name="yoffset">
		/// <para>
		/// Specifies a texel offset in the y direction within the texture array.
		/// </para>
		/// </param>
		/// <param name="width">
		/// <para>
		/// Specifies the width of the texture subimage.
		/// </para>
		/// </param>
		/// <param name="height">
		/// <para>
		/// Specifies the height of the texture subimage.
		/// </para>
		/// </param>
		/// <param name="format">
		/// <para>
		/// Specifies the format of the compressed image data stored at address data.
		/// </para>
		/// </param>
		/// <param name="imageSize">
		/// <para>
		/// Specifies the number of unsigned bytes of image data starting at the address specified by data.
		/// </para>
		/// </param>
		/// <param name="data">
		/// <para>
		/// Specifies a pointer to the compressed image data in memory.
		/// </para>
		/// </param>
		//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glCompressedTexSubImage2D")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
				void CompressedTexSubImage2D<T8>(System.Graphics.ES11.All target, Int32 level, Int32 xoffset, Int32 yoffset, Int32 width, Int32 height, System.Graphics.ES11.All format, Int32 imageSize, [InAttribute, OutAttribute] T8[,,] data)
					where T8 : struct {
			GCHandle data_ptr = GCHandle.Alloc(data, GCHandleType.Pinned);
			try {
				Delegates.glCompressedTexSubImage2D((System.Graphics.ES11.All) target, (Int32) level, (Int32) xoffset, (Int32) yoffset, (Int32) width, (Int32) height, (System.Graphics.ES11.All) format, (Int32) imageSize, (IntPtr) data_ptr.AddrOfPinnedObject());
			} finally {
				data_ptr.Free();
			}
		}


		/// <summary>[requires: v1.1 and 1.1]
		/// Specify a two-dimensional texture subimage in a compressed format
		/// </summary>
		/// <param name="target">
		/// <para>
		/// Specifies the target texture. Must be GL_TEXTURE_2D, GL_TEXTURE_CUBE_MAP_POSITIVE_X, GL_TEXTURE_CUBE_MAP_NEGATIVE_X, GL_TEXTURE_CUBE_MAP_POSITIVE_Y, GL_TEXTURE_CUBE_MAP_NEGATIVE_Y, GL_TEXTURE_CUBE_MAP_POSITIVE_Z, or GL_TEXTURE_CUBE_MAP_NEGATIVE_Z.
		/// </para>
		/// </param>
		/// <param name="level">
		/// <para>
		/// Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.
		/// </para>
		/// </param>
		/// <param name="xoffset">
		/// <para>
		/// Specifies a texel offset in the x direction within the texture array.
		/// </para>
		/// </param>
		/// <param name="yoffset">
		/// <para>
		/// Specifies a texel offset in the y direction within the texture array.
		/// </para>
		/// </param>
		/// <param name="width">
		/// <para>
		/// Specifies the width of the texture subimage.
		/// </para>
		/// </param>
		/// <param name="height">
		/// <para>
		/// Specifies the height of the texture subimage.
		/// </para>
		/// </param>
		/// <param name="format">
		/// <para>
		/// Specifies the format of the compressed image data stored at address data.
		/// </para>
		/// </param>
		/// <param name="imageSize">
		/// <para>
		/// Specifies the number of unsigned bytes of image data starting at the address specified by data.
		/// </para>
		/// </param>
		/// <param name="data">
		/// <para>
		/// Specifies a pointer to the compressed image data in memory.
		/// </para>
		/// </param>
		//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glCompressedTexSubImage2D")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
				void CompressedTexSubImage2D<T8>(System.Graphics.ES11.All target, Int32 level, Int32 xoffset, Int32 yoffset, Int32 width, Int32 height, System.Graphics.ES11.All format, Int32 imageSize, [InAttribute, OutAttribute] ref T8 data)
					where T8 : struct {
			GCHandle data_ptr = GCHandle.Alloc(data, GCHandleType.Pinned);
			try {
				Delegates.glCompressedTexSubImage2D((System.Graphics.ES11.All) target, (Int32) level, (Int32) xoffset, (Int32) yoffset, (Int32) width, (Int32) height, (System.Graphics.ES11.All) format, (Int32) imageSize, (IntPtr) data_ptr.AddrOfPinnedObject());
				data = (T8) data_ptr.Target;
			} finally {
				data_ptr.Free();
			}
		}


		/// <summary>[requires: v1.1 and 1.1]
		/// Copy pixels into a 2D texture image
		/// </summary>
		/// <param name="target">
		/// <para>
		/// Specifies the target texture. Must be GL_TEXTURE_2D, GL_TEXTURE_CUBE_MAP_POSITIVE_X, GL_TEXTURE_CUBE_MAP_NEGATIVE_X, GL_TEXTURE_CUBE_MAP_POSITIVE_Y, GL_TEXTURE_CUBE_MAP_NEGATIVE_Y, GL_TEXTURE_CUBE_MAP_POSITIVE_Z, or GL_TEXTURE_CUBE_MAP_NEGATIVE_Z.
		/// </para>
		/// </param>
		/// <param name="level">
		/// <para>
		/// Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.
		/// </para>
		/// </param>
		/// <param name="internalformat">
		/// <para>
		/// Specifies the internal format of the texture. Must be one of the following symbolic constants: GL_COMPRESSED_RED, GL_COMPRESSED_RG, GL_COMPRESSED_RGB, GL_COMPRESSED_RGBA. GL_COMPRESSED_SRGB, GL_COMPRESSED_SRGB_ALPHA. GL_DEPTH_COMPONENT, GL_DEPTH_COMPONENT16, GL_DEPTH_COMPONENT24, GL_DEPTH_COMPONENT32, GL_RED, GL_RG, GL_RGB, GL_R3_G3_B2, GL_RGB4, GL_RGB5, GL_RGB8, GL_RGB10, GL_RGB12, GL_RGB16, GL_RGBA, GL_RGBA2, GL_RGBA4, GL_RGB5_A1, GL_RGBA8, GL_RGB10_A2, GL_RGBA12, GL_RGBA16, GL_SRGB, GL_SRGB8, GL_SRGB_ALPHA, or GL_SRGB8_ALPHA8.
		/// </para>
		/// </param>
		/// <param name="x">
		/// <para>
		/// Specify the window coordinates of the lower left corner of the rectangular region of pixels to be copied.
		/// </para>
		/// </param>
		/// <param name="y">
		/// <para>
		/// Specify the window coordinates of the lower left corner of the rectangular region of pixels to be copied.
		/// </para>
		/// </param>
		/// <param name="width">
		/// <para>
		/// Specifies the width of the texture image. Must be 0 or 2 sup n + 2 ( border ) for some integer .
		/// </para>
		/// </param>
		/// <param name="height">
		/// <para>
		/// Specifies the height of the texture image. Must be 0 or 2 sup m + 2 ( border ) for some integer .
		/// </para>
		/// </param>
		/// <param name="border">
		/// <para>
		/// Specifies the width of the border. Must be either 0 or 1.
		/// </para>
		/// </param>
		//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glCopyTexImage2D")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
				void CopyTexImage2D(System.Graphics.ES11.All target, Int32 level, System.Graphics.ES11.All internalformat, Int32 x, Int32 y, Int32 width, Int32 height, Int32 border) {
			Delegates.glCopyTexImage2D((System.Graphics.ES11.All) target, (Int32) level, (System.Graphics.ES11.All) internalformat, (Int32) x, (Int32) y, (Int32) width, (Int32) height, (Int32) border);
		}


		/// <summary>[requires: v1.1 and 1.1]
		/// Copy a two-dimensional texture subimage
		/// </summary>
		/// <param name="target">
		/// <para>
		/// Specifies the target texture. Must be GL_TEXTURE_2D, GL_TEXTURE_CUBE_MAP_POSITIVE_X, GL_TEXTURE_CUBE_MAP_NEGATIVE_X, GL_TEXTURE_CUBE_MAP_POSITIVE_Y, GL_TEXTURE_CUBE_MAP_NEGATIVE_Y, GL_TEXTURE_CUBE_MAP_POSITIVE_Z, or GL_TEXTURE_CUBE_MAP_NEGATIVE_Z.
		/// </para>
		/// </param>
		/// <param name="level">
		/// <para>
		/// Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.
		/// </para>
		/// </param>
		/// <param name="xoffset">
		/// <para>
		/// Specifies a texel offset in the x direction within the texture array.
		/// </para>
		/// </param>
		/// <param name="yoffset">
		/// <para>
		/// Specifies a texel offset in the y direction within the texture array.
		/// </para>
		/// </param>
		/// <param name="x">
		/// <para>
		/// Specify the window coordinates of the lower left corner of the rectangular region of pixels to be copied.
		/// </para>
		/// </param>
		/// <param name="y">
		/// <para>
		/// Specify the window coordinates of the lower left corner of the rectangular region of pixels to be copied.
		/// </para>
		/// </param>
		/// <param name="width">
		/// <para>
		/// Specifies the width of the texture subimage.
		/// </para>
		/// </param>
		/// <param name="height">
		/// <para>
		/// Specifies the height of the texture subimage.
		/// </para>
		/// </param>
		//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glCopyTexSubImage2D")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
				void CopyTexSubImage2D(System.Graphics.ES11.All target, Int32 level, Int32 xoffset, Int32 yoffset, Int32 x, Int32 y, Int32 width, Int32 height) {
			Delegates.glCopyTexSubImage2D((System.Graphics.ES11.All) target, (Int32) level, (Int32) xoffset, (Int32) yoffset, (Int32) x, (Int32) y, (Int32) width, (Int32) height);
		}


		/// <summary>[requires: v1.1 and 1.1]
		/// Specify whether front- or back-facing facets can be culled
		/// </summary>
		/// <param name="mode">
		/// <para>
		/// Specifies whether front- or back-facing facets are candidates for culling. Symbolic constants GL_FRONT, GL_BACK, and GL_FRONT_AND_BACK are accepted. The initial value is GL_BACK.
		/// </para>
		/// </param>
		//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glCullFace")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
				void CullFace(System.Graphics.ES11.All mode) {
			Delegates.glCullFace((System.Graphics.ES11.All) mode);
		}


		/// <summary>[requires: v1.1 and 1.1]
		/// Delete named buffer objects
		/// </summary>
		/// <param name="n">
		/// <para>
		/// Specifies the number of buffer objects to be deleted.
		/// </para>
		/// </param>
		/// <param name="buffers">
		/// <para>
		/// Specifies an array of buffer objects to be deleted.
		/// </para>
		/// </param>
		//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glDeleteBuffers")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
				void DeleteBuffers(Int32 n, Int32[] buffers) {
			unsafe
			{
				fixed (Int32* buffers_ptr = buffers) {
					Delegates.glDeleteBuffers((Int32) n, (UInt32*) buffers_ptr);
				}
			}
		}


		/// <summary>[requires: v1.1 and 1.1]
		/// Delete named buffer objects
		/// </summary>
		/// <param name="n">
		/// <para>
		/// Specifies the number of buffer objects to be deleted.
		/// </para>
		/// </param>
		/// <param name="buffers">
		/// <para>
		/// Specifies an array of buffer objects to be deleted.
		/// </para>
		/// </param>
		//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glDeleteBuffers")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
				void DeleteBuffers(Int32 n, ref Int32 buffers) {
			unsafe
			{
				fixed (Int32* buffers_ptr = &buffers) {
					Delegates.glDeleteBuffers((Int32) n, (UInt32*) buffers_ptr);
				}
			}
		}


		/// <summary>[requires: v1.1 and 1.1]
		/// Delete named buffer objects
		/// </summary>
		/// <param name="n">
		/// <para>
		/// Specifies the number of buffer objects to be deleted.
		/// </para>
		/// </param>
		/// <param name="buffers">
		/// <para>
		/// Specifies an array of buffer objects to be deleted.
		/// </para>
		/// </param>
		[System.CLSCompliant(false)]
		//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glDeleteBuffers")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
		unsafe void DeleteBuffers(Int32 n, Int32* buffers) {
			Delegates.glDeleteBuffers((Int32) n, (UInt32*) buffers);
		}


		/// <summary>[requires: v1.1 and 1.1]
		/// Delete named buffer objects
		/// </summary>
		/// <param name="n">
		/// <para>
		/// Specifies the number of buffer objects to be deleted.
		/// </para>
		/// </param>
		/// <param name="buffers">
		/// <para>
		/// Specifies an array of buffer objects to be deleted.
		/// </para>
		/// </param>
		[System.CLSCompliant(false)]
		//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glDeleteBuffers")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
		void DeleteBuffers(Int32 n, UInt32[] buffers) {
			unsafe
			{
				fixed (UInt32* buffers_ptr = buffers) {
					Delegates.glDeleteBuffers((Int32) n, (UInt32*) buffers_ptr);
				}
			}
		}


		/// <summary>[requires: v1.1 and 1.1]
		/// Delete named buffer objects
		/// </summary>
		/// <param name="n">
		/// <para>
		/// Specifies the number of buffer objects to be deleted.
		/// </para>
		/// </param>
		/// <param name="buffers">
		/// <para>
		/// Specifies an array of buffer objects to be deleted.
		/// </para>
		/// </param>
		[System.CLSCompliant(false)]
		//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glDeleteBuffers")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
		void DeleteBuffers(Int32 n, ref UInt32 buffers) {
			unsafe
			{
				fixed (UInt32* buffers_ptr = &buffers) {
					Delegates.glDeleteBuffers((Int32) n, (UInt32*) buffers_ptr);
				}
			}
		}


		/// <summary>[requires: v1.1 and 1.1]
		/// Delete named buffer objects
		/// </summary>
		/// <param name="n">
		/// <para>
		/// Specifies the number of buffer objects to be deleted.
		/// </para>
		/// </param>
		/// <param name="buffers">
		/// <para>
		/// Specifies an array of buffer objects to be deleted.
		/// </para>
		/// </param>
		[System.CLSCompliant(false)]
		//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glDeleteBuffers")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
		unsafe void DeleteBuffers(Int32 n, UInt32* buffers) {
			Delegates.glDeleteBuffers((Int32) n, (UInt32*) buffers);
		}


		/// <summary>[requires: v1.1 and 1.1]
		/// Delete named textures
		/// </summary>
		/// <param name="n">
		/// <para>
		/// Specifies the number of textures to be deleted.
		/// </para>
		/// </param>
		/// <param name="textures">
		/// <para>
		/// Specifies an array of textures to be deleted.
		/// </para>
		/// </param>
		//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glDeleteTextures")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
				void DeleteTextures(Int32 n, Int32[] textures) {
			unsafe
			{
				fixed (Int32* textures_ptr = textures) {
					Delegates.glDeleteTextures((Int32) n, (UInt32*) textures_ptr);
				}
			}
		}


		/// <summary>[requires: v1.1 and 1.1]
		/// Delete named textures
		/// </summary>
		/// <param name="n">
		/// <para>
		/// Specifies the number of textures to be deleted.
		/// </para>
		/// </param>
		/// <param name="textures">
		/// <para>
		/// Specifies an array of textures to be deleted.
		/// </para>
		/// </param>
		//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glDeleteTextures")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
				void DeleteTextures(Int32 n, ref Int32 textures) {
			unsafe
			{
				fixed (Int32* textures_ptr = &textures) {
					Delegates.glDeleteTextures((Int32) n, (UInt32*) textures_ptr);
				}
			}
		}


		/// <summary>[requires: v1.1 and 1.1]
		/// Delete named textures
		/// </summary>
		/// <param name="n">
		/// <para>
		/// Specifies the number of textures to be deleted.
		/// </para>
		/// </param>
		/// <param name="textures">
		/// <para>
		/// Specifies an array of textures to be deleted.
		/// </para>
		/// </param>
		[System.CLSCompliant(false)]
		//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glDeleteTextures")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
		unsafe void DeleteTextures(Int32 n, Int32* textures) {
			Delegates.glDeleteTextures((Int32) n, (UInt32*) textures);
		}


		/// <summary>[requires: v1.1 and 1.1]
		/// Delete named textures
		/// </summary>
		/// <param name="n">
		/// <para>
		/// Specifies the number of textures to be deleted.
		/// </para>
		/// </param>
		/// <param name="textures">
		/// <para>
		/// Specifies an array of textures to be deleted.
		/// </para>
		/// </param>
		[System.CLSCompliant(false)]
		//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glDeleteTextures")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
		void DeleteTextures(Int32 n, UInt32[] textures) {
			unsafe
			{
				fixed (UInt32* textures_ptr = textures) {
					Delegates.glDeleteTextures((Int32) n, (UInt32*) textures_ptr);
				}
			}
		}


		/// <summary>[requires: v1.1 and 1.1]
		/// Delete named textures
		/// </summary>
		/// <param name="n">
		/// <para>
		/// Specifies the number of textures to be deleted.
		/// </para>
		/// </param>
		/// <param name="textures">
		/// <para>
		/// Specifies an array of textures to be deleted.
		/// </para>
		/// </param>
		[System.CLSCompliant(false)]
		//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glDeleteTextures")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
		void DeleteTextures(Int32 n, ref UInt32 textures) {
			unsafe
			{
				fixed (UInt32* textures_ptr = &textures) {
					Delegates.glDeleteTextures((Int32) n, (UInt32*) textures_ptr);
				}
			}
		}


		/// <summary>[requires: v1.1 and 1.1]
		/// Delete named textures
		/// </summary>
		/// <param name="n">
		/// <para>
		/// Specifies the number of textures to be deleted.
		/// </para>
		/// </param>
		/// <param name="textures">
		/// <para>
		/// Specifies an array of textures to be deleted.
		/// </para>
		/// </param>
		[System.CLSCompliant(false)]
		//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glDeleteTextures")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
		unsafe void DeleteTextures(Int32 n, UInt32* textures) {
			Delegates.glDeleteTextures((Int32) n, (UInt32*) textures);
		}


		/// <summary>[requires: v1.1 and 1.1]
		/// Specify the value used for depth buffer comparisons
		/// </summary>
		/// <param name="func">
		/// <para>
		/// Specifies the depth comparison function. Symbolic constants GL_NEVER, GL_LESS, GL_EQUAL, GL_LEQUAL, GL_GREATER, GL_NOTEQUAL, GL_GEQUAL, and GL_ALWAYS are accepted. The initial value is GL_LESS.
		/// </para>
		/// </param>
		//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glDepthFunc")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
				void DepthFunc(System.Graphics.ES11.All func) {
			Delegates.glDepthFunc((System.Graphics.ES11.All) func);
		}


		/// <summary>[requires: v1.1 and 1.1]
		/// Enable or disable writing into the depth buffer
		/// </summary>
		/// <param name="flag">
		/// <para>
		/// Specifies whether the depth buffer is enabled for writing. If flag is GL_FALSE, depth buffer writing is disabled. Otherwise, it is enabled. Initially, depth buffer writing is enabled.
		/// </para>
		/// </param>
		//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glDepthMask")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
				void DepthMask(bool flag) {
			Delegates.glDepthMask((bool) flag);
		}


		/// <summary>[requires: v1.1 and 1.1]
		/// Specify mapping of depth values from normalized device coordinates to window coordinates
		/// </summary>
		/// <param name="zNear">
		/// <para>
		/// Specifies the mapping of the near clipping plane to window coordinates. The initial value is 0.
		/// </para>
		/// </param>
		/// <param name="zFar">
		/// <para>
		/// Specifies the mapping of the far clipping plane to window coordinates. The initial value is 1.
		/// </para>
		/// </param>
		//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glDepthRangef")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
				void DepthRange(Single zNear, Single zFar) {
			Delegates.glDepthRangef((Single) zNear, (Single) zFar);
		}

		/// <summary>[requires: v1.1 and 1.1]</summary>
		//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glDepthRangex")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
				void DepthRangex(int zNear, int zFar) {
			Delegates.glDepthRangex((int) zNear, (int) zFar);
		}

		/// <summary>[requires: v1.1 and 1.1]</summary>
		//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glDisable")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
				void Disable(System.Graphics.ES11.All cap) {
			Delegates.glDisable((System.Graphics.ES11.All) cap);
		}

		/// <summary>[requires: v1.1 and 1.1]</summary>
		//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glDisableClientState")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
				void DisableClientState(System.Graphics.ES11.All array) {
			Delegates.glDisableClientState((System.Graphics.ES11.All) array);
		}


		/// <summary>[requires: v1.1 and 1.1]
		/// Render primitives from array data
		/// </summary>
		/// <param name="mode">
		/// <para>
		/// Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES, GL_LINE_STRIP_ADJACENCY, GL_LINES_ADJACENCY, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_TRIANGLES, GL_TRIANGLE_STRIP_ADJACENCY, GL_TRIANGLES_ADJACENCY and GL_PATCHES are accepted.
		/// </para>
		/// </param>
		/// <param name="first">
		/// <para>
		/// Specifies the starting index in the enabled arrays.
		/// </para>
		/// </param>
		/// <param name="count">
		/// <para>
		/// Specifies the number of indices to be rendered.
		/// </para>
		/// </param>
		//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glDrawArrays")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
				void DrawArrays(System.Graphics.ES11.All mode, Int32 first, Int32 count) {
			Delegates.glDrawArrays((System.Graphics.ES11.All) mode, (Int32) first, (Int32) count);
		}


		/// <summary>[requires: v1.1 and 1.1]
		/// Render primitives from array data
		/// </summary>
		/// <param name="mode">
		/// <para>
		/// Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES, GL_LINE_STRIP_ADJACENCY, GL_LINES_ADJACENCY, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_TRIANGLES, GL_TRIANGLE_STRIP_ADJACENCY, GL_TRIANGLES_ADJACENCY and GL_PATCHES are accepted.
		/// </para>
		/// </param>
		/// <param name="count">
		/// <para>
		/// Specifies the number of elements to be rendered.
		/// </para>
		/// </param>
		/// <param name="type">
		/// <para>
		/// Specifies the type of the values in indices. Must be one of GL_UNSIGNED_BYTE, GL_UNSIGNED_SHORT, or GL_UNSIGNED_INT.
		/// </para>
		/// </param>
		/// <param name="indices">
		/// <para>
		/// Specifies a pointer to the location where the indices are stored.
		/// </para>
		/// </param>
		//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glDrawElements")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
				void DrawElements(System.Graphics.ES11.All mode, Int32 count, System.Graphics.ES11.All type, IntPtr indices) {
			Delegates.glDrawElements((System.Graphics.ES11.All) mode, (Int32) count, (System.Graphics.ES11.All) type, (IntPtr) indices);
		}


		/// <summary>[requires: v1.1 and 1.1]
		/// Render primitives from array data
		/// </summary>
		/// <param name="mode">
		/// <para>
		/// Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES, GL_LINE_STRIP_ADJACENCY, GL_LINES_ADJACENCY, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_TRIANGLES, GL_TRIANGLE_STRIP_ADJACENCY, GL_TRIANGLES_ADJACENCY and GL_PATCHES are accepted.
		/// </para>
		/// </param>
		/// <param name="count">
		/// <para>
		/// Specifies the number of elements to be rendered.
		/// </para>
		/// </param>
		/// <param name="type">
		/// <para>
		/// Specifies the type of the values in indices. Must be one of GL_UNSIGNED_BYTE, GL_UNSIGNED_SHORT, or GL_UNSIGNED_INT.
		/// </para>
		/// </param>
		/// <param name="indices">
		/// <para>
		/// Specifies a pointer to the location where the indices are stored.
		/// </para>
		/// </param>
		//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glDrawElements")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
				void DrawElements<T3>(System.Graphics.ES11.All mode, Int32 count, System.Graphics.ES11.All type, [InAttribute, OutAttribute] T3[] indices)
					where T3 : struct {
			GCHandle indices_ptr = GCHandle.Alloc(indices, GCHandleType.Pinned);
			try {
				Delegates.glDrawElements((System.Graphics.ES11.All) mode, (Int32) count, (System.Graphics.ES11.All) type, (IntPtr) indices_ptr.AddrOfPinnedObject());
			} finally {
				indices_ptr.Free();
			}
		}


		/// <summary>[requires: v1.1 and 1.1]
		/// Render primitives from array data
		/// </summary>
		/// <param name="mode">
		/// <para>
		/// Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES, GL_LINE_STRIP_ADJACENCY, GL_LINES_ADJACENCY, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_TRIANGLES, GL_TRIANGLE_STRIP_ADJACENCY, GL_TRIANGLES_ADJACENCY and GL_PATCHES are accepted.
		/// </para>
		/// </param>
		/// <param name="count">
		/// <para>
		/// Specifies the number of elements to be rendered.
		/// </para>
		/// </param>
		/// <param name="type">
		/// <para>
		/// Specifies the type of the values in indices. Must be one of GL_UNSIGNED_BYTE, GL_UNSIGNED_SHORT, or GL_UNSIGNED_INT.
		/// </para>
		/// </param>
		/// <param name="indices">
		/// <para>
		/// Specifies a pointer to the location where the indices are stored.
		/// </para>
		/// </param>
		//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glDrawElements")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
				void DrawElements<T3>(System.Graphics.ES11.All mode, Int32 count, System.Graphics.ES11.All type, [InAttribute, OutAttribute] T3[,] indices)
					where T3 : struct {
			GCHandle indices_ptr = GCHandle.Alloc(indices, GCHandleType.Pinned);
			try {
				Delegates.glDrawElements((System.Graphics.ES11.All) mode, (Int32) count, (System.Graphics.ES11.All) type, (IntPtr) indices_ptr.AddrOfPinnedObject());
			} finally {
				indices_ptr.Free();
			}
		}


		/// <summary>[requires: v1.1 and 1.1]
		/// Render primitives from array data
		/// </summary>
		/// <param name="mode">
		/// <para>
		/// Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES, GL_LINE_STRIP_ADJACENCY, GL_LINES_ADJACENCY, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_TRIANGLES, GL_TRIANGLE_STRIP_ADJACENCY, GL_TRIANGLES_ADJACENCY and GL_PATCHES are accepted.
		/// </para>
		/// </param>
		/// <param name="count">
		/// <para>
		/// Specifies the number of elements to be rendered.
		/// </para>
		/// </param>
		/// <param name="type">
		/// <para>
		/// Specifies the type of the values in indices. Must be one of GL_UNSIGNED_BYTE, GL_UNSIGNED_SHORT, or GL_UNSIGNED_INT.
		/// </para>
		/// </param>
		/// <param name="indices">
		/// <para>
		/// Specifies a pointer to the location where the indices are stored.
		/// </para>
		/// </param>
		//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glDrawElements")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
				void DrawElements<T3>(System.Graphics.ES11.All mode, Int32 count, System.Graphics.ES11.All type, [InAttribute, OutAttribute] T3[,,] indices)
					where T3 : struct {
			GCHandle indices_ptr = GCHandle.Alloc(indices, GCHandleType.Pinned);
			try {
				Delegates.glDrawElements((System.Graphics.ES11.All) mode, (Int32) count, (System.Graphics.ES11.All) type, (IntPtr) indices_ptr.AddrOfPinnedObject());
			} finally {
				indices_ptr.Free();
			}
		}


		/// <summary>[requires: v1.1 and 1.1]
		/// Render primitives from array data
		/// </summary>
		/// <param name="mode">
		/// <para>
		/// Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES, GL_LINE_STRIP_ADJACENCY, GL_LINES_ADJACENCY, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_TRIANGLES, GL_TRIANGLE_STRIP_ADJACENCY, GL_TRIANGLES_ADJACENCY and GL_PATCHES are accepted.
		/// </para>
		/// </param>
		/// <param name="count">
		/// <para>
		/// Specifies the number of elements to be rendered.
		/// </para>
		/// </param>
		/// <param name="type">
		/// <para>
		/// Specifies the type of the values in indices. Must be one of GL_UNSIGNED_BYTE, GL_UNSIGNED_SHORT, or GL_UNSIGNED_INT.
		/// </para>
		/// </param>
		/// <param name="indices">
		/// <para>
		/// Specifies a pointer to the location where the indices are stored.
		/// </para>
		/// </param>
		//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glDrawElements")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
				void DrawElements<T3>(System.Graphics.ES11.All mode, Int32 count, System.Graphics.ES11.All type, [InAttribute, OutAttribute] ref T3 indices)
					where T3 : struct {
			GCHandle indices_ptr = GCHandle.Alloc(indices, GCHandleType.Pinned);
			try {
				Delegates.glDrawElements((System.Graphics.ES11.All) mode, (Int32) count, (System.Graphics.ES11.All) type, (IntPtr) indices_ptr.AddrOfPinnedObject());
				indices = (T3) indices_ptr.Target;
			} finally {
				indices_ptr.Free();
			}
		}


		/// <summary>[requires: v1.1 and 1.1]
		/// Enable or disable server-side GL capabilities
		/// </summary>
		/// <param name="cap">
		/// <para>
		/// Specifies a symbolic constant indicating a GL capability.
		/// </para>
		/// </param>
		//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glEnable")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
				void Enable(System.Graphics.ES11.All cap) {
			Delegates.glEnable((System.Graphics.ES11.All) cap);
		}


		/// <summary>[requires: v1.1 and 1.1]
		/// Enable or disable client-side capability
		/// </summary>
		/// <param name="array">
		/// <para>
		/// Specifies the capability to enable. Symbolic constants GL_COLOR_ARRAY, GL_EDGE_FLAG_ARRAY, GL_FOG_COORD_ARRAY, GL_INDEX_ARRAY, GL_NORMAL_ARRAY, GL_SECONDARY_COLOR_ARRAY, GL_TEXTURE_COORD_ARRAY, and GL_VERTEX_ARRAY are accepted.
		/// </para>
		/// </param>
		//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glEnableClientState")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
				void EnableClientState(System.Graphics.ES11.All array) {
			Delegates.glEnableClientState((System.Graphics.ES11.All) array);
		}


		/// <summary>[requires: v1.1 and 1.1]
		/// Block until all GL execution is complete
		/// </summary>
		//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glFinish")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
				void Finish() {
			Delegates.glFinish();
		}


		/// <summary>[requires: v1.1 and 1.1]
		/// Force execution of GL commands in finite time
		/// </summary>
		//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glFlush")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
				void Flush() {
			Delegates.glFlush();
		}


		/// <summary>[requires: v1.1 and 1.1]
		/// Specify fog parameters
		/// </summary>
		/// <param name="pname">
		/// <para>
		/// Specifies a single-valued fog parameter. GL_FOG_MODE, GL_FOG_DENSITY, GL_FOG_START, GL_FOG_END, GL_FOG_INDEX, and GL_FOG_COORD_SRC are accepted.
		/// </para>
		/// </param>
		/// <param name="param">
		/// <para>
		/// Specifies the value that pname will be set to.
		/// </para>
		/// </param>
		//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glFogf")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
				void Fog(System.Graphics.ES11.All pname, Single param) {
			Delegates.glFogf((System.Graphics.ES11.All) pname, (Single) param);
		}


		/// <summary>[requires: v1.1 and 1.1]
		/// Specify fog parameters
		/// </summary>
		/// <param name="pname">
		/// <para>
		/// Specifies a single-valued fog parameter. GL_FOG_MODE, GL_FOG_DENSITY, GL_FOG_START, GL_FOG_END, GL_FOG_INDEX, and GL_FOG_COORD_SRC are accepted.
		/// </para>
		/// </param>
		/// <param name="params">
		/// <para>
		/// Specifies the value that pname will be set to.
		/// </para>
		/// </param>
		//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glFogfv")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
				void Fog(System.Graphics.ES11.All pname, Single[] @params) {
			unsafe
			{
				fixed (Single* @params_ptr = @params) {
					Delegates.glFogfv((System.Graphics.ES11.All) pname, (Single*) @params_ptr);
				}
			}
		}


		/// <summary>[requires: v1.1 and 1.1]
		/// Specify fog parameters
		/// </summary>
		/// <param name="pname">
		/// <para>
		/// Specifies a single-valued fog parameter. GL_FOG_MODE, GL_FOG_DENSITY, GL_FOG_START, GL_FOG_END, GL_FOG_INDEX, and GL_FOG_COORD_SRC are accepted.
		/// </para>
		/// </param>
		/// <param name="params">
		/// <para>
		/// Specifies the value that pname will be set to.
		/// </para>
		/// </param>
		[System.CLSCompliant(false)]
		//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glFogfv")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
		unsafe void Fog(System.Graphics.ES11.All pname, Single* @params) {
			Delegates.glFogfv((System.Graphics.ES11.All) pname, (Single*) @params);
		}

		/// <summary>[requires: v1.1 and 1.1]</summary>
		//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glFogx")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
				void Fogx(System.Graphics.ES11.All pname, int param) {
			Delegates.glFogx((System.Graphics.ES11.All) pname, (int) param);
		}

		/// <summary>[requires: v1.1 and 1.1]</summary>
		//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glFogxv")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
				void Fogx(System.Graphics.ES11.All pname, int[] @params) {
			unsafe
			{
				fixed (int* @params_ptr = @params) {
					Delegates.glFogxv((System.Graphics.ES11.All) pname, (int*) @params_ptr);
				}
			}
		}

		/// <summary>[requires: v1.1 and 1.1]</summary>
		[System.CLSCompliant(false)]
		//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glFogxv")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
		unsafe void Fogx(System.Graphics.ES11.All pname, int* @params) {
			Delegates.glFogxv((System.Graphics.ES11.All) pname, (int*) @params);
		}


		/// <summary>[requires: v1.1 and 1.1]
		/// Define front- and back-facing polygons
		/// </summary>
		/// <param name="mode">
		/// <para>
		/// Specifies the orientation of front-facing polygons. GL_CW and GL_CCW are accepted. The initial value is GL_CCW.
		/// </para>
		/// </param>
		//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glFrontFace")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
				void FrontFace(System.Graphics.ES11.All mode) {
			Delegates.glFrontFace((System.Graphics.ES11.All) mode);
		}


		/// <summary>[requires: v1.1 and 1.1]
		/// Multiply the current matrix by a perspective matrix
		/// </summary>
		//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glFrustumf")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
				void Frustum(Single left, Single right, Single bottom, Single top, Single zNear, Single zFar) {
			Delegates.glFrustumf((Single) left, (Single) right, (Single) bottom, (Single) top, (Single) zNear, (Single) zFar);
		}

		/// <summary>[requires: v1.1 and 1.1]</summary>
		//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glFrustumx")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
				void Frustumx(int left, int right, int bottom, int top, int zNear, int zFar) {
			Delegates.glFrustumx((int) left, (int) right, (int) bottom, (int) top, (int) zNear, (int) zFar);
		}


		/// <summary>[requires: v1.1 and 1.1]
		/// Generate buffer object names
		/// </summary>
		/// <param name="n">
		/// <para>
		/// Specifies the number of buffer object names to be generated.
		/// </para>
		/// </param>
		/// <param name="buffers">
		/// <para>
		/// Specifies an array in which the generated buffer object names are stored.
		/// </para>
		/// </param>
		//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glGenBuffers")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
				void GenBuffers(Int32 n, Int32[] buffers) {
			unsafe
			{
				fixed (Int32* buffers_ptr = buffers) {
					Delegates.glGenBuffers((Int32) n, (UInt32*) buffers_ptr);
				}
			}
		}


		/// <summary>[requires: v1.1 and 1.1]
		/// Generate buffer object names
		/// </summary>
		/// <param name="n">
		/// <para>
		/// Specifies the number of buffer object names to be generated.
		/// </para>
		/// </param>
		/// <param name="buffers">
		/// <para>
		/// Specifies an array in which the generated buffer object names are stored.
		/// </para>
		/// </param>
		//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glGenBuffers")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
				void GenBuffers(Int32 n, ref Int32 buffers) {
			unsafe
			{
				fixed (Int32* buffers_ptr = &buffers) {
					Delegates.glGenBuffers((Int32) n, (UInt32*) buffers_ptr);
				}
			}
		}


		/// <summary>[requires: v1.1 and 1.1]
		/// Generate buffer object names
		/// </summary>
		/// <param name="n">
		/// <para>
		/// Specifies the number of buffer object names to be generated.
		/// </para>
		/// </param>
		/// <param name="buffers">
		/// <para>
		/// Specifies an array in which the generated buffer object names are stored.
		/// </para>
		/// </param>
		[System.CLSCompliant(false)]
		//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glGenBuffers")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
		unsafe void GenBuffers(Int32 n, Int32* buffers) {
			Delegates.glGenBuffers((Int32) n, (UInt32*) buffers);
		}


		/// <summary>[requires: v1.1 and 1.1]
		/// Generate buffer object names
		/// </summary>
		/// <param name="n">
		/// <para>
		/// Specifies the number of buffer object names to be generated.
		/// </para>
		/// </param>
		/// <param name="buffers">
		/// <para>
		/// Specifies an array in which the generated buffer object names are stored.
		/// </para>
		/// </param>
		[System.CLSCompliant(false)]
		//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glGenBuffers")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
		void GenBuffers(Int32 n, UInt32[] buffers) {
			unsafe
			{
				fixed (UInt32* buffers_ptr = buffers) {
					Delegates.glGenBuffers((Int32) n, (UInt32*) buffers_ptr);
				}
			}
		}


		/// <summary>[requires: v1.1 and 1.1]
		/// Generate buffer object names
		/// </summary>
		/// <param name="n">
		/// <para>
		/// Specifies the number of buffer object names to be generated.
		/// </para>
		/// </param>
		/// <param name="buffers">
		/// <para>
		/// Specifies an array in which the generated buffer object names are stored.
		/// </para>
		/// </param>
		[System.CLSCompliant(false)]
		//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glGenBuffers")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
		void GenBuffers(Int32 n, ref UInt32 buffers) {
			unsafe
			{
				fixed (UInt32* buffers_ptr = &buffers) {
					Delegates.glGenBuffers((Int32) n, (UInt32*) buffers_ptr);
				}
			}
		}


		/// <summary>[requires: v1.1 and 1.1]
		/// Generate buffer object names
		/// </summary>
		/// <param name="n">
		/// <para>
		/// Specifies the number of buffer object names to be generated.
		/// </para>
		/// </param>
		/// <param name="buffers">
		/// <para>
		/// Specifies an array in which the generated buffer object names are stored.
		/// </para>
		/// </param>
		[System.CLSCompliant(false)]
		//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glGenBuffers")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
		unsafe void GenBuffers(Int32 n, UInt32* buffers) {
			Delegates.glGenBuffers((Int32) n, (UInt32*) buffers);
		}


		/// <summary>[requires: v1.1 and 1.1]
		/// Generate texture names
		/// </summary>
		/// <param name="n">
		/// <para>
		/// Specifies the number of texture names to be generated.
		/// </para>
		/// </param>
		/// <param name="textures">
		/// <para>
		/// Specifies an array in which the generated texture names are stored.
		/// </para>
		/// </param>
		//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glGenTextures")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
				void GenTextures(Int32 n, Int32[] textures) {
			unsafe
			{
				fixed (Int32* textures_ptr = textures) {
					Delegates.glGenTextures((Int32) n, (UInt32*) textures_ptr);
				}
			}
		}


		/// <summary>[requires: v1.1 and 1.1]
		/// Generate texture names
		/// </summary>
		/// <param name="n">
		/// <para>
		/// Specifies the number of texture names to be generated.
		/// </para>
		/// </param>
		/// <param name="textures">
		/// <para>
		/// Specifies an array in which the generated texture names are stored.
		/// </para>
		/// </param>
		//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glGenTextures")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
				void GenTextures(Int32 n, ref Int32 textures) {
			unsafe
			{
				fixed (Int32* textures_ptr = &textures) {
					Delegates.glGenTextures((Int32) n, (UInt32*) textures_ptr);
				}
			}
		}


		/// <summary>[requires: v1.1 and 1.1]
		/// Generate texture names
		/// </summary>
		/// <param name="n">
		/// <para>
		/// Specifies the number of texture names to be generated.
		/// </para>
		/// </param>
		/// <param name="textures">
		/// <para>
		/// Specifies an array in which the generated texture names are stored.
		/// </para>
		/// </param>
		[System.CLSCompliant(false)]
		//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glGenTextures")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
		unsafe void GenTextures(Int32 n, Int32* textures) {
			Delegates.glGenTextures((Int32) n, (UInt32*) textures);
		}


		/// <summary>[requires: v1.1 and 1.1]
		/// Generate texture names
		/// </summary>
		/// <param name="n">
		/// <para>
		/// Specifies the number of texture names to be generated.
		/// </para>
		/// </param>
		/// <param name="textures">
		/// <para>
		/// Specifies an array in which the generated texture names are stored.
		/// </para>
		/// </param>
		[System.CLSCompliant(false)]
		//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glGenTextures")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
		void GenTextures(Int32 n, UInt32[] textures) {
			unsafe
			{
				fixed (UInt32* textures_ptr = textures) {
					Delegates.glGenTextures((Int32) n, (UInt32*) textures_ptr);
				}
			}
		}


		/// <summary>[requires: v1.1 and 1.1]
		/// Generate texture names
		/// </summary>
		/// <param name="n">
		/// <para>
		/// Specifies the number of texture names to be generated.
		/// </para>
		/// </param>
		/// <param name="textures">
		/// <para>
		/// Specifies an array in which the generated texture names are stored.
		/// </para>
		/// </param>
		[System.CLSCompliant(false)]
		//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glGenTextures")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
		void GenTextures(Int32 n, ref UInt32 textures) {
			unsafe
			{
				fixed (UInt32* textures_ptr = &textures) {
					Delegates.glGenTextures((Int32) n, (UInt32*) textures_ptr);
				}
			}
		}


		/// <summary>[requires: v1.1 and 1.1]
		/// Generate texture names
		/// </summary>
		/// <param name="n">
		/// <para>
		/// Specifies the number of texture names to be generated.
		/// </para>
		/// </param>
		/// <param name="textures">
		/// <para>
		/// Specifies an array in which the generated texture names are stored.
		/// </para>
		/// </param>
		[System.CLSCompliant(false)]
		//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glGenTextures")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
		unsafe void GenTextures(Int32 n, UInt32* textures) {
			Delegates.glGenTextures((Int32) n, (UInt32*) textures);
		}

		/// <summary>[requires: v1.1 and 1.1]</summary>
		//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glGetBooleanv")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
				void GetBoolean(System.Graphics.ES11.All pname, bool[] @params) {
			unsafe
			{
				fixed (bool* @params_ptr = @params) {
					Delegates.glGetBooleanv((System.Graphics.ES11.All) pname, (bool*) @params_ptr);
				}
			}
		}

		/// <summary>[requires: v1.1 and 1.1]</summary>
		//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glGetBooleanv")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
				void GetBoolean(System.Graphics.ES11.All pname, ref bool @params) {
			unsafe
			{
				fixed (bool* @params_ptr = &@params) {
					Delegates.glGetBooleanv((System.Graphics.ES11.All) pname, (bool*) @params_ptr);
				}
			}
		}

		/// <summary>[requires: v1.1 and 1.1]</summary>
		[System.CLSCompliant(false)]
		//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glGetBooleanv")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
		unsafe void GetBoolean(System.Graphics.ES11.All pname, bool* @params) {
			Delegates.glGetBooleanv((System.Graphics.ES11.All) pname, (bool*) @params);
		}


		/// <summary>[requires: v1.1 and 1.1]
		/// Return parameters of a buffer object
		/// </summary>
		/// <param name="target">
		/// <para>
		/// Specifies the target buffer object. The symbolic constant must be GL_ARRAY_BUFFER, GL_ELEMENT_ARRAY_BUFFER, GL_PIXEL_PACK_BUFFER, or GL_PIXEL_UNPACK_BUFFER.
		/// </para>
		/// </param>
		/// <param name="pname">
		/// <para>
		/// Specifies the symbolic name of a buffer object parameter. Accepted values are GL_BUFFER_ACCESS, GL_BUFFER_MAPPED, GL_BUFFER_SIZE, or GL_BUFFER_USAGE.
		/// </para>
		/// </param>
		/// <param name="params">
		/// <para>
		/// Returns the requested parameter.
		/// </para>
		/// </param>
		//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glGetBufferParameteriv")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
				void GetBufferParameter(System.Graphics.ES11.All target, System.Graphics.ES11.All pname, Int32[] @params) {
			unsafe
			{
				fixed (Int32* @params_ptr = @params) {
					Delegates.glGetBufferParameteriv((System.Graphics.ES11.All) target, (System.Graphics.ES11.All) pname, (Int32*) @params_ptr);
				}
			}
		}


		/// <summary>[requires: v1.1 and 1.1]
		/// Return parameters of a buffer object
		/// </summary>
		/// <param name="target">
		/// <para>
		/// Specifies the target buffer object. The symbolic constant must be GL_ARRAY_BUFFER, GL_ELEMENT_ARRAY_BUFFER, GL_PIXEL_PACK_BUFFER, or GL_PIXEL_UNPACK_BUFFER.
		/// </para>
		/// </param>
		/// <param name="pname">
		/// <para>
		/// Specifies the symbolic name of a buffer object parameter. Accepted values are GL_BUFFER_ACCESS, GL_BUFFER_MAPPED, GL_BUFFER_SIZE, or GL_BUFFER_USAGE.
		/// </para>
		/// </param>
		/// <param name="params">
		/// <para>
		/// Returns the requested parameter.
		/// </para>
		/// </param>
		//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glGetBufferParameteriv")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
				void GetBufferParameter(System.Graphics.ES11.All target, System.Graphics.ES11.All pname, ref Int32 @params) {
			unsafe
			{
				fixed (Int32* @params_ptr = &@params) {
					Delegates.glGetBufferParameteriv((System.Graphics.ES11.All) target, (System.Graphics.ES11.All) pname, (Int32*) @params_ptr);
				}
			}
		}


		/// <summary>[requires: v1.1 and 1.1]
		/// Return parameters of a buffer object
		/// </summary>
		/// <param name="target">
		/// <para>
		/// Specifies the target buffer object. The symbolic constant must be GL_ARRAY_BUFFER, GL_ELEMENT_ARRAY_BUFFER, GL_PIXEL_PACK_BUFFER, or GL_PIXEL_UNPACK_BUFFER.
		/// </para>
		/// </param>
		/// <param name="pname">
		/// <para>
		/// Specifies the symbolic name of a buffer object parameter. Accepted values are GL_BUFFER_ACCESS, GL_BUFFER_MAPPED, GL_BUFFER_SIZE, or GL_BUFFER_USAGE.
		/// </para>
		/// </param>
		/// <param name="params">
		/// <para>
		/// Returns the requested parameter.
		/// </para>
		/// </param>
		[System.CLSCompliant(false)]
		//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glGetBufferParameteriv")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
		unsafe void GetBufferParameter(System.Graphics.ES11.All target, System.Graphics.ES11.All pname, Int32* @params) {
			Delegates.glGetBufferParameteriv((System.Graphics.ES11.All) target, (System.Graphics.ES11.All) pname, (Int32*) @params);
		}


		/// <summary>[requires: v1.1 and 1.1]
		/// Return the coefficients of the specified clipping plane
		/// </summary>
		/// <param name="pname">
		/// <para>
		/// Specifies a clipping plane. The number of clipping planes depends on the implementation, but at least six clipping planes are supported. They are identified by symbolic names of the form GL_CLIP_PLANE where i ranges from 0 to the value of GL_MAX_CLIP_PLANES - 1.
		/// </para>
		/// </param>
		/// <param name="eqn">
		/// <para>
		/// Returns four double-precision values that are the coefficients of the plane equation of plane in eye coordinates. The initial value is (0, 0, 0, 0).
		/// </para>
		/// </param>
		//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glGetClipPlanef")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
				void GetClipPlane(System.Graphics.ES11.All pname, Single[] eqn) {
			unsafe
			{
				fixed (Single* eqn_ptr = eqn) {
					Delegates.glGetClipPlanef((System.Graphics.ES11.All) pname, (Single*) eqn_ptr);
				}
			}
		}


		/// <summary>[requires: v1.1 and 1.1]
		/// Return the coefficients of the specified clipping plane
		/// </summary>
		/// <param name="pname">
		/// <para>
		/// Specifies a clipping plane. The number of clipping planes depends on the implementation, but at least six clipping planes are supported. They are identified by symbolic names of the form GL_CLIP_PLANE where i ranges from 0 to the value of GL_MAX_CLIP_PLANES - 1.
		/// </para>
		/// </param>
		/// <param name="eqn">
		/// <para>
		/// Returns four double-precision values that are the coefficients of the plane equation of plane in eye coordinates. The initial value is (0, 0, 0, 0).
		/// </para>
		/// </param>
		//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glGetClipPlanef")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
				void GetClipPlane(System.Graphics.ES11.All pname, ref Single eqn) {
			unsafe
			{
				fixed (Single* eqn_ptr = &eqn) {
					Delegates.glGetClipPlanef((System.Graphics.ES11.All) pname, (Single*) eqn_ptr);
				}
			}
		}


		/// <summary>[requires: v1.1 and 1.1]
		/// Return the coefficients of the specified clipping plane
		/// </summary>
		/// <param name="pname">
		/// <para>
		/// Specifies a clipping plane. The number of clipping planes depends on the implementation, but at least six clipping planes are supported. They are identified by symbolic names of the form GL_CLIP_PLANE where i ranges from 0 to the value of GL_MAX_CLIP_PLANES - 1.
		/// </para>
		/// </param>
		/// <param name="eqn">
		/// <para>
		/// Returns four double-precision values that are the coefficients of the plane equation of plane in eye coordinates. The initial value is (0, 0, 0, 0).
		/// </para>
		/// </param>
		[System.CLSCompliant(false)]
		//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glGetClipPlanef")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
		unsafe void GetClipPlane(System.Graphics.ES11.All pname, Single* eqn) {
			Delegates.glGetClipPlanef((System.Graphics.ES11.All) pname, (Single*) eqn);
		}

		/// <summary>[requires: v1.1 and 1.1]</summary>
		//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glGetClipPlanex")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
				void GetClipPlanex(System.Graphics.ES11.All pname, int[] eqn) {
			unsafe
			{
				fixed (int* eqn_ptr = eqn) {
					Delegates.glGetClipPlanex((System.Graphics.ES11.All) pname, (int*) eqn_ptr);
				}
			}
		}

		/// <summary>[requires: v1.1 and 1.1]</summary>
		//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glGetClipPlanex")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
				void GetClipPlanex(System.Graphics.ES11.All pname, ref int eqn) {
			unsafe
			{
				fixed (int* eqn_ptr = &eqn) {
					Delegates.glGetClipPlanex((System.Graphics.ES11.All) pname, (int*) eqn_ptr);
				}
			}
		}

		/// <summary>[requires: v1.1 and 1.1]</summary>
		[System.CLSCompliant(false)]
		//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glGetClipPlanex")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
		unsafe void GetClipPlanex(System.Graphics.ES11.All pname, int* eqn) {
			Delegates.glGetClipPlanex((System.Graphics.ES11.All) pname, (int*) eqn);
		}


		/// <summary>[requires: v1.1 and 1.1]
		/// Return error information
		/// </summary>
		//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glGetError")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
				System.Graphics.ES11.All GetError() {
			return Delegates.glGetError();
		}

		/// <summary>[requires: v1.1 and 1.1]</summary>
		//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glGetFixedv")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
				void GetFixed(System.Graphics.ES11.All pname, int[] @params) {
			unsafe
			{
				fixed (int* @params_ptr = @params) {
					Delegates.glGetFixedv((System.Graphics.ES11.All) pname, (int*) @params_ptr);
				}
			}
		}

		/// <summary>[requires: v1.1 and 1.1]</summary>
		//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glGetFixedv")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
				void GetFixed(System.Graphics.ES11.All pname, ref int @params) {
			unsafe
			{
				fixed (int* @params_ptr = &@params) {
					Delegates.glGetFixedv((System.Graphics.ES11.All) pname, (int*) @params_ptr);
				}
			}
		}

		/// <summary>[requires: v1.1 and 1.1]</summary>
		[System.CLSCompliant(false)]
		//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glGetFixedv")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
		unsafe void GetFixed(System.Graphics.ES11.All pname, int* @params) {
			Delegates.glGetFixedv((System.Graphics.ES11.All) pname, (int*) @params);
		}

		/// <summary>[requires: v1.1 and 1.1]</summary>
		//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glGetFloatv")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
				void GetFloat(System.Graphics.ES11.All pname, Single[] @params) {
			unsafe
			{
				fixed (Single* @params_ptr = @params) {
					Delegates.glGetFloatv((System.Graphics.ES11.All) pname, (Single*) @params_ptr);
				}
			}
		}

		/// <summary>[requires: v1.1 and 1.1]</summary>
		//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glGetFloatv")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
				void GetFloat(System.Graphics.ES11.All pname, ref Single @params) {
			unsafe
			{
				fixed (Single* @params_ptr = &@params) {
					Delegates.glGetFloatv((System.Graphics.ES11.All) pname, (Single*) @params_ptr);
				}
			}
		}

		/// <summary>[requires: v1.1 and 1.1]</summary>
		[System.CLSCompliant(false)]
		//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glGetFloatv")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
		unsafe void GetFloat(System.Graphics.ES11.All pname, Single* @params) {
			Delegates.glGetFloatv((System.Graphics.ES11.All) pname, (Single*) @params);
		}

		/// <summary>[requires: v1.1 and 1.1]</summary>
		//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glGetIntegerv")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
				void GetInteger(System.Graphics.ES11.All pname, Int32[] @params) {
			unsafe
			{
				fixed (Int32* @params_ptr = @params) {
					Delegates.glGetIntegerv((System.Graphics.ES11.All) pname, (Int32*) @params_ptr);
				}
			}
		}

		/// <summary>[requires: v1.1 and 1.1]</summary>
		//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glGetIntegerv")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
				void GetInteger(System.Graphics.ES11.All pname, ref Int32 @params) {
			unsafe
			{
				fixed (Int32* @params_ptr = &@params) {
					Delegates.glGetIntegerv((System.Graphics.ES11.All) pname, (Int32*) @params_ptr);
				}
			}
		}

		/// <summary>[requires: v1.1 and 1.1]</summary>
		[System.CLSCompliant(false)]
		//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glGetIntegerv")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
		unsafe void GetInteger(System.Graphics.ES11.All pname, Int32* @params) {
			Delegates.glGetIntegerv((System.Graphics.ES11.All) pname, (Int32*) @params);
		}


		/// <summary>[requires: v1.1 and 1.1]
		/// Return light source parameter values
		/// </summary>
		/// <param name="light">
		/// <para>
		/// Specifies a light source. The number of possible lights depends on the implementation, but at least eight lights are supported. They are identified by symbolic names of the form GL_LIGHT where ranges from 0 to the value of GL_MAX_LIGHTS - 1.
		/// </para>
		/// </param>
		/// <param name="pname">
		/// <para>
		/// Specifies a light source parameter for light. Accepted symbolic names are GL_AMBIENT, GL_DIFFUSE, GL_SPECULAR, GL_POSITION, GL_SPOT_DIRECTION, GL_SPOT_EXPONENT, GL_SPOT_CUTOFF, GL_CONSTANT_ATTENUATION, GL_LINEAR_ATTENUATION, and GL_QUADRATIC_ATTENUATION.
		/// </para>
		/// </param>
		/// <param name="params">
		/// <para>
		/// Returns the requested data.
		/// </para>
		/// </param>
		//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glGetLightfv")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
				void GetLight(System.Graphics.ES11.All light, System.Graphics.ES11.All pname, Single[] @params) {
			unsafe
			{
				fixed (Single* @params_ptr = @params) {
					Delegates.glGetLightfv((System.Graphics.ES11.All) light, (System.Graphics.ES11.All) pname, (Single*) @params_ptr);
				}
			}
		}


		/// <summary>[requires: v1.1 and 1.1]
		/// Return light source parameter values
		/// </summary>
		/// <param name="light">
		/// <para>
		/// Specifies a light source. The number of possible lights depends on the implementation, but at least eight lights are supported. They are identified by symbolic names of the form GL_LIGHT where ranges from 0 to the value of GL_MAX_LIGHTS - 1.
		/// </para>
		/// </param>
		/// <param name="pname">
		/// <para>
		/// Specifies a light source parameter for light. Accepted symbolic names are GL_AMBIENT, GL_DIFFUSE, GL_SPECULAR, GL_POSITION, GL_SPOT_DIRECTION, GL_SPOT_EXPONENT, GL_SPOT_CUTOFF, GL_CONSTANT_ATTENUATION, GL_LINEAR_ATTENUATION, and GL_QUADRATIC_ATTENUATION.
		/// </para>
		/// </param>
		/// <param name="params">
		/// <para>
		/// Returns the requested data.
		/// </para>
		/// </param>
		//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glGetLightfv")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
				void GetLight(System.Graphics.ES11.All light, System.Graphics.ES11.All pname, ref Single @params) {
			unsafe
			{
				fixed (Single* @params_ptr = &@params) {
					Delegates.glGetLightfv((System.Graphics.ES11.All) light, (System.Graphics.ES11.All) pname, (Single*) @params_ptr);
				}
			}
		}


		/// <summary>[requires: v1.1 and 1.1]
		/// Return light source parameter values
		/// </summary>
		/// <param name="light">
		/// <para>
		/// Specifies a light source. The number of possible lights depends on the implementation, but at least eight lights are supported. They are identified by symbolic names of the form GL_LIGHT where ranges from 0 to the value of GL_MAX_LIGHTS - 1.
		/// </para>
		/// </param>
		/// <param name="pname">
		/// <para>
		/// Specifies a light source parameter for light. Accepted symbolic names are GL_AMBIENT, GL_DIFFUSE, GL_SPECULAR, GL_POSITION, GL_SPOT_DIRECTION, GL_SPOT_EXPONENT, GL_SPOT_CUTOFF, GL_CONSTANT_ATTENUATION, GL_LINEAR_ATTENUATION, and GL_QUADRATIC_ATTENUATION.
		/// </para>
		/// </param>
		/// <param name="params">
		/// <para>
		/// Returns the requested data.
		/// </para>
		/// </param>
		[System.CLSCompliant(false)]
		//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glGetLightfv")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
		unsafe void GetLight(System.Graphics.ES11.All light, System.Graphics.ES11.All pname, Single* @params) {
			Delegates.glGetLightfv((System.Graphics.ES11.All) light, (System.Graphics.ES11.All) pname, (Single*) @params);
		}

		/// <summary>[requires: v1.1 and 1.1]</summary>
		//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glGetLightxv")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
				void GetLightx(System.Graphics.ES11.All light, System.Graphics.ES11.All pname, int[] @params) {
			unsafe
			{
				fixed (int* @params_ptr = @params) {
					Delegates.glGetLightxv((System.Graphics.ES11.All) light, (System.Graphics.ES11.All) pname, (int*) @params_ptr);
				}
			}
		}

		/// <summary>[requires: v1.1 and 1.1]</summary>
		//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glGetLightxv")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
				void GetLightx(System.Graphics.ES11.All light, System.Graphics.ES11.All pname, ref int @params) {
			unsafe
			{
				fixed (int* @params_ptr = &@params) {
					Delegates.glGetLightxv((System.Graphics.ES11.All) light, (System.Graphics.ES11.All) pname, (int*) @params_ptr);
				}
			}
		}

		/// <summary>[requires: v1.1 and 1.1]</summary>
		[System.CLSCompliant(false)]
		//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glGetLightxv")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
		unsafe void GetLightx(System.Graphics.ES11.All light, System.Graphics.ES11.All pname, int* @params) {
			Delegates.glGetLightxv((System.Graphics.ES11.All) light, (System.Graphics.ES11.All) pname, (int*) @params);
		}


		/// <summary>[requires: v1.1 and 1.1]
		/// Return material parameters
		/// </summary>
		/// <param name="face">
		/// <para>
		/// Specifies which of the two materials is being queried. GL_FRONT or GL_BACK are accepted, representing the front and back materials, respectively.
		/// </para>
		/// </param>
		/// <param name="pname">
		/// <para>
		/// Specifies the material parameter to return. GL_AMBIENT, GL_DIFFUSE, GL_SPECULAR, GL_EMISSION, GL_SHININESS, and GL_COLOR_INDEXES are accepted.
		/// </para>
		/// </param>
		/// <param name="params">
		/// <para>
		/// Returns the requested data.
		/// </para>
		/// </param>
		//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glGetMaterialfv")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
				void GetMaterial(System.Graphics.ES11.All face, System.Graphics.ES11.All pname, Single[] @params) {
			unsafe
			{
				fixed (Single* @params_ptr = @params) {
					Delegates.glGetMaterialfv((System.Graphics.ES11.All) face, (System.Graphics.ES11.All) pname, (Single*) @params_ptr);
				}
			}
		}


		/// <summary>[requires: v1.1 and 1.1]
		/// Return material parameters
		/// </summary>
		/// <param name="face">
		/// <para>
		/// Specifies which of the two materials is being queried. GL_FRONT or GL_BACK are accepted, representing the front and back materials, respectively.
		/// </para>
		/// </param>
		/// <param name="pname">
		/// <para>
		/// Specifies the material parameter to return. GL_AMBIENT, GL_DIFFUSE, GL_SPECULAR, GL_EMISSION, GL_SHININESS, and GL_COLOR_INDEXES are accepted.
		/// </para>
		/// </param>
		/// <param name="params">
		/// <para>
		/// Returns the requested data.
		/// </para>
		/// </param>
		//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glGetMaterialfv")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
				void GetMaterial(System.Graphics.ES11.All face, System.Graphics.ES11.All pname, ref Single @params) {
			unsafe
			{
				fixed (Single* @params_ptr = &@params) {
					Delegates.glGetMaterialfv((System.Graphics.ES11.All) face, (System.Graphics.ES11.All) pname, (Single*) @params_ptr);
				}
			}
		}


		/// <summary>[requires: v1.1 and 1.1]
		/// Return material parameters
		/// </summary>
		/// <param name="face">
		/// <para>
		/// Specifies which of the two materials is being queried. GL_FRONT or GL_BACK are accepted, representing the front and back materials, respectively.
		/// </para>
		/// </param>
		/// <param name="pname">
		/// <para>
		/// Specifies the material parameter to return. GL_AMBIENT, GL_DIFFUSE, GL_SPECULAR, GL_EMISSION, GL_SHININESS, and GL_COLOR_INDEXES are accepted.
		/// </para>
		/// </param>
		/// <param name="params">
		/// <para>
		/// Returns the requested data.
		/// </para>
		/// </param>
		[System.CLSCompliant(false)]
		//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glGetMaterialfv")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
		unsafe void GetMaterial(System.Graphics.ES11.All face, System.Graphics.ES11.All pname, Single* @params) {
			Delegates.glGetMaterialfv((System.Graphics.ES11.All) face, (System.Graphics.ES11.All) pname, (Single*) @params);
		}

		/// <summary>[requires: v1.1 and 1.1]</summary>
		//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glGetMaterialxv")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
				void GetMaterialx(System.Graphics.ES11.All face, System.Graphics.ES11.All pname, int[] @params) {
			unsafe
			{
				fixed (int* @params_ptr = @params) {
					Delegates.glGetMaterialxv((System.Graphics.ES11.All) face, (System.Graphics.ES11.All) pname, (int*) @params_ptr);
				}
			}
		}

		/// <summary>[requires: v1.1 and 1.1]</summary>
		//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glGetMaterialxv")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
				void GetMaterialx(System.Graphics.ES11.All face, System.Graphics.ES11.All pname, ref int @params) {
			unsafe
			{
				fixed (int* @params_ptr = &@params) {
					Delegates.glGetMaterialxv((System.Graphics.ES11.All) face, (System.Graphics.ES11.All) pname, (int*) @params_ptr);
				}
			}
		}

		/// <summary>[requires: v1.1 and 1.1]</summary>
		[System.CLSCompliant(false)]
		//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glGetMaterialxv")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
		unsafe void GetMaterialx(System.Graphics.ES11.All face, System.Graphics.ES11.All pname, int* @params) {
			Delegates.glGetMaterialxv((System.Graphics.ES11.All) face, (System.Graphics.ES11.All) pname, (int*) @params);
		}


		/// <summary>[requires: v1.1 and 1.1]
		/// Return the address of the specified pointer
		/// </summary>
		/// <param name="pname">
		/// <para>
		/// Specifies the array or buffer pointer to be returned. Symbolic constants GL_COLOR_ARRAY_POINTER, GL_EDGE_FLAG_ARRAY_POINTER, GL_FOG_COORD_ARRAY_POINTER, GL_FEEDBACK_BUFFER_POINTER, GL_INDEX_ARRAY_POINTER, GL_NORMAL_ARRAY_POINTER, GL_SECONDARY_COLOR_ARRAY_POINTER, GL_SELECTION_BUFFER_POINTER, GL_TEXTURE_COORD_ARRAY_POINTER, or GL_VERTEX_ARRAY_POINTER are accepted.
		/// </para>
		/// </param>
		/// <param name="params">
		/// <para>
		/// Returns the pointer value specified by pname.
		/// </para>
		/// </param>
		//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glGetPointerv")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
				void GetPointer(System.Graphics.ES11.All pname, IntPtr @params) {
			Delegates.glGetPointerv((System.Graphics.ES11.All) pname, (IntPtr) @params);
		}


		/// <summary>[requires: v1.1 and 1.1]
		/// Return the address of the specified pointer
		/// </summary>
		/// <param name="pname">
		/// <para>
		/// Specifies the array or buffer pointer to be returned. Symbolic constants GL_COLOR_ARRAY_POINTER, GL_EDGE_FLAG_ARRAY_POINTER, GL_FOG_COORD_ARRAY_POINTER, GL_FEEDBACK_BUFFER_POINTER, GL_INDEX_ARRAY_POINTER, GL_NORMAL_ARRAY_POINTER, GL_SECONDARY_COLOR_ARRAY_POINTER, GL_SELECTION_BUFFER_POINTER, GL_TEXTURE_COORD_ARRAY_POINTER, or GL_VERTEX_ARRAY_POINTER are accepted.
		/// </para>
		/// </param>
		/// <param name="params">
		/// <para>
		/// Returns the pointer value specified by pname.
		/// </para>
		/// </param>
		//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glGetPointerv")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
				void GetPointer<T1>(System.Graphics.ES11.All pname, [InAttribute, OutAttribute] T1[] @params)
					where T1 : struct {
			GCHandle @params_ptr = GCHandle.Alloc(@params, GCHandleType.Pinned);
			try {
				Delegates.glGetPointerv((System.Graphics.ES11.All) pname, (IntPtr) @params_ptr.AddrOfPinnedObject());
			} finally {
				@params_ptr.Free();
			}
		}


		/// <summary>[requires: v1.1 and 1.1]
		/// Return the address of the specified pointer
		/// </summary>
		/// <param name="pname">
		/// <para>
		/// Specifies the array or buffer pointer to be returned. Symbolic constants GL_COLOR_ARRAY_POINTER, GL_EDGE_FLAG_ARRAY_POINTER, GL_FOG_COORD_ARRAY_POINTER, GL_FEEDBACK_BUFFER_POINTER, GL_INDEX_ARRAY_POINTER, GL_NORMAL_ARRAY_POINTER, GL_SECONDARY_COLOR_ARRAY_POINTER, GL_SELECTION_BUFFER_POINTER, GL_TEXTURE_COORD_ARRAY_POINTER, or GL_VERTEX_ARRAY_POINTER are accepted.
		/// </para>
		/// </param>
		/// <param name="params">
		/// <para>
		/// Returns the pointer value specified by pname.
		/// </para>
		/// </param>
		//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glGetPointerv")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
				void GetPointer<T1>(System.Graphics.ES11.All pname, [InAttribute, OutAttribute] T1[,] @params)
					where T1 : struct {
			GCHandle @params_ptr = GCHandle.Alloc(@params, GCHandleType.Pinned);
			try {
				Delegates.glGetPointerv((System.Graphics.ES11.All) pname, (IntPtr) @params_ptr.AddrOfPinnedObject());
			} finally {
				@params_ptr.Free();
			}
		}


		/// <summary>[requires: v1.1 and 1.1]
		/// Return the address of the specified pointer
		/// </summary>
		/// <param name="pname">
		/// <para>
		/// Specifies the array or buffer pointer to be returned. Symbolic constants GL_COLOR_ARRAY_POINTER, GL_EDGE_FLAG_ARRAY_POINTER, GL_FOG_COORD_ARRAY_POINTER, GL_FEEDBACK_BUFFER_POINTER, GL_INDEX_ARRAY_POINTER, GL_NORMAL_ARRAY_POINTER, GL_SECONDARY_COLOR_ARRAY_POINTER, GL_SELECTION_BUFFER_POINTER, GL_TEXTURE_COORD_ARRAY_POINTER, or GL_VERTEX_ARRAY_POINTER are accepted.
		/// </para>
		/// </param>
		/// <param name="params">
		/// <para>
		/// Returns the pointer value specified by pname.
		/// </para>
		/// </param>
		//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glGetPointerv")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
				void GetPointer<T1>(System.Graphics.ES11.All pname, [InAttribute, OutAttribute] T1[,,] @params)
					where T1 : struct {
			GCHandle @params_ptr = GCHandle.Alloc(@params, GCHandleType.Pinned);
			try {
				Delegates.glGetPointerv((System.Graphics.ES11.All) pname, (IntPtr) @params_ptr.AddrOfPinnedObject());
			} finally {
				@params_ptr.Free();
			}
		}


		/// <summary>[requires: v1.1 and 1.1]
		/// Return the address of the specified pointer
		/// </summary>
		/// <param name="pname">
		/// <para>
		/// Specifies the array or buffer pointer to be returned. Symbolic constants GL_COLOR_ARRAY_POINTER, GL_EDGE_FLAG_ARRAY_POINTER, GL_FOG_COORD_ARRAY_POINTER, GL_FEEDBACK_BUFFER_POINTER, GL_INDEX_ARRAY_POINTER, GL_NORMAL_ARRAY_POINTER, GL_SECONDARY_COLOR_ARRAY_POINTER, GL_SELECTION_BUFFER_POINTER, GL_TEXTURE_COORD_ARRAY_POINTER, or GL_VERTEX_ARRAY_POINTER are accepted.
		/// </para>
		/// </param>
		/// <param name="params">
		/// <para>
		/// Returns the pointer value specified by pname.
		/// </para>
		/// </param>
		//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glGetPointerv")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
				void GetPointer<T1>(System.Graphics.ES11.All pname, [InAttribute, OutAttribute] ref T1 @params)
					where T1 : struct {
			GCHandle @params_ptr = GCHandle.Alloc(@params, GCHandleType.Pinned);
			try {
				Delegates.glGetPointerv((System.Graphics.ES11.All) pname, (IntPtr) @params_ptr.AddrOfPinnedObject());
				@params = (T1) @params_ptr.Target;
			} finally {
				@params_ptr.Free();
			}
		}


		/// <summary>[requires: v1.1 and 1.1]
		/// Return a string describing the current GL connection
		/// </summary>
		/// <param name="name">
		/// <para>
		/// Specifies a symbolic constant, one of GL_VENDOR, GL_RENDERER, GL_VERSION, or GL_SHADING_LANGUAGE_VERSION. Additionally, glGetStringi accepts the GL_EXTENSIONS token.
		/// </para>
		/// </param>
		[System.CLSCompliant(false)]
		//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glGetString")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
		unsafe System.String GetString(System.Graphics.ES11.All name) {
			unsafe
			{
				return new string((sbyte*) Delegates.glGetString((System.Graphics.ES11.All) name));
			}
		}


		/// <summary>[requires: v1.1 and 1.1]
		/// Return texture environment parameters
		/// </summary>
		/// <param name="env">
		/// <para>
		/// Specifies a texture environment. May be GL_TEXTURE_ENV, GL_TEXTURE_FILTER_CONTROL, or GL_POINT_SPRITE.
		/// </para>
		/// </param>
		/// <param name="pname">
		/// <para>
		/// Specifies the symbolic name of a texture environment parameter. Accepted values are GL_TEXTURE_ENV_MODE, GL_TEXTURE_ENV_COLOR, GL_TEXTURE_LOD_BIAS, GL_COMBINE_RGB, GL_COMBINE_ALPHA, GL_SRC0_RGB, GL_SRC1_RGB, GL_SRC2_RGB, GL_SRC0_ALPHA, GL_SRC1_ALPHA, GL_SRC2_ALPHA, GL_OPERAND0_RGB, GL_OPERAND1_RGB, GL_OPERAND2_RGB, GL_OPERAND0_ALPHA, GL_OPERAND1_ALPHA, GL_OPERAND2_ALPHA, GL_RGB_SCALE, GL_ALPHA_SCALE, or GL_COORD_REPLACE.
		/// </para>
		/// </param>
		/// <param name="params">
		/// <para>
		/// Returns the requested data.
		/// </para>
		/// </param>
		//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glGetTexEnvfv")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
				void GetTexEnv(System.Graphics.ES11.All env, System.Graphics.ES11.All pname, Single[] @params) {
			unsafe
			{
				fixed (Single* @params_ptr = @params) {
					Delegates.glGetTexEnvfv((System.Graphics.ES11.All) env, (System.Graphics.ES11.All) pname, (Single*) @params_ptr);
				}
			}
		}


		/// <summary>[requires: v1.1 and 1.1]
		/// Return texture environment parameters
		/// </summary>
		/// <param name="env">
		/// <para>
		/// Specifies a texture environment. May be GL_TEXTURE_ENV, GL_TEXTURE_FILTER_CONTROL, or GL_POINT_SPRITE.
		/// </para>
		/// </param>
		/// <param name="pname">
		/// <para>
		/// Specifies the symbolic name of a texture environment parameter. Accepted values are GL_TEXTURE_ENV_MODE, GL_TEXTURE_ENV_COLOR, GL_TEXTURE_LOD_BIAS, GL_COMBINE_RGB, GL_COMBINE_ALPHA, GL_SRC0_RGB, GL_SRC1_RGB, GL_SRC2_RGB, GL_SRC0_ALPHA, GL_SRC1_ALPHA, GL_SRC2_ALPHA, GL_OPERAND0_RGB, GL_OPERAND1_RGB, GL_OPERAND2_RGB, GL_OPERAND0_ALPHA, GL_OPERAND1_ALPHA, GL_OPERAND2_ALPHA, GL_RGB_SCALE, GL_ALPHA_SCALE, or GL_COORD_REPLACE.
		/// </para>
		/// </param>
		/// <param name="params">
		/// <para>
		/// Returns the requested data.
		/// </para>
		/// </param>
		//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glGetTexEnvfv")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
				void GetTexEnv(System.Graphics.ES11.All env, System.Graphics.ES11.All pname, ref Single @params) {
			unsafe
			{
				fixed (Single* @params_ptr = &@params) {
					Delegates.glGetTexEnvfv((System.Graphics.ES11.All) env, (System.Graphics.ES11.All) pname, (Single*) @params_ptr);
				}
			}
		}


		/// <summary>[requires: v1.1 and 1.1]
		/// Return texture environment parameters
		/// </summary>
		/// <param name="env">
		/// <para>
		/// Specifies a texture environment. May be GL_TEXTURE_ENV, GL_TEXTURE_FILTER_CONTROL, or GL_POINT_SPRITE.
		/// </para>
		/// </param>
		/// <param name="pname">
		/// <para>
		/// Specifies the symbolic name of a texture environment parameter. Accepted values are GL_TEXTURE_ENV_MODE, GL_TEXTURE_ENV_COLOR, GL_TEXTURE_LOD_BIAS, GL_COMBINE_RGB, GL_COMBINE_ALPHA, GL_SRC0_RGB, GL_SRC1_RGB, GL_SRC2_RGB, GL_SRC0_ALPHA, GL_SRC1_ALPHA, GL_SRC2_ALPHA, GL_OPERAND0_RGB, GL_OPERAND1_RGB, GL_OPERAND2_RGB, GL_OPERAND0_ALPHA, GL_OPERAND1_ALPHA, GL_OPERAND2_ALPHA, GL_RGB_SCALE, GL_ALPHA_SCALE, or GL_COORD_REPLACE.
		/// </para>
		/// </param>
		/// <param name="params">
		/// <para>
		/// Returns the requested data.
		/// </para>
		/// </param>
		[System.CLSCompliant(false)]
		//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glGetTexEnvfv")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
		unsafe void GetTexEnv(System.Graphics.ES11.All env, System.Graphics.ES11.All pname, Single* @params) {
			Delegates.glGetTexEnvfv((System.Graphics.ES11.All) env, (System.Graphics.ES11.All) pname, (Single*) @params);
		}


		/// <summary>[requires: v1.1 and 1.1]
		/// Return texture environment parameters
		/// </summary>
		/// <param name="env">
		/// <para>
		/// Specifies a texture environment. May be GL_TEXTURE_ENV, GL_TEXTURE_FILTER_CONTROL, or GL_POINT_SPRITE.
		/// </para>
		/// </param>
		/// <param name="pname">
		/// <para>
		/// Specifies the symbolic name of a texture environment parameter. Accepted values are GL_TEXTURE_ENV_MODE, GL_TEXTURE_ENV_COLOR, GL_TEXTURE_LOD_BIAS, GL_COMBINE_RGB, GL_COMBINE_ALPHA, GL_SRC0_RGB, GL_SRC1_RGB, GL_SRC2_RGB, GL_SRC0_ALPHA, GL_SRC1_ALPHA, GL_SRC2_ALPHA, GL_OPERAND0_RGB, GL_OPERAND1_RGB, GL_OPERAND2_RGB, GL_OPERAND0_ALPHA, GL_OPERAND1_ALPHA, GL_OPERAND2_ALPHA, GL_RGB_SCALE, GL_ALPHA_SCALE, or GL_COORD_REPLACE.
		/// </para>
		/// </param>
		/// <param name="params">
		/// <para>
		/// Returns the requested data.
		/// </para>
		/// </param>
		//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glGetTexEnviv")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
				void GetTexEnv(System.Graphics.ES11.All env, System.Graphics.ES11.All pname, Int32[] @params) {
			unsafe
			{
				fixed (Int32* @params_ptr = @params) {
					Delegates.glGetTexEnviv((System.Graphics.ES11.All) env, (System.Graphics.ES11.All) pname, (Int32*) @params_ptr);
				}
			}
		}


		/// <summary>[requires: v1.1 and 1.1]
		/// Return texture environment parameters
		/// </summary>
		/// <param name="env">
		/// <para>
		/// Specifies a texture environment. May be GL_TEXTURE_ENV, GL_TEXTURE_FILTER_CONTROL, or GL_POINT_SPRITE.
		/// </para>
		/// </param>
		/// <param name="pname">
		/// <para>
		/// Specifies the symbolic name of a texture environment parameter. Accepted values are GL_TEXTURE_ENV_MODE, GL_TEXTURE_ENV_COLOR, GL_TEXTURE_LOD_BIAS, GL_COMBINE_RGB, GL_COMBINE_ALPHA, GL_SRC0_RGB, GL_SRC1_RGB, GL_SRC2_RGB, GL_SRC0_ALPHA, GL_SRC1_ALPHA, GL_SRC2_ALPHA, GL_OPERAND0_RGB, GL_OPERAND1_RGB, GL_OPERAND2_RGB, GL_OPERAND0_ALPHA, GL_OPERAND1_ALPHA, GL_OPERAND2_ALPHA, GL_RGB_SCALE, GL_ALPHA_SCALE, or GL_COORD_REPLACE.
		/// </para>
		/// </param>
		/// <param name="params">
		/// <para>
		/// Returns the requested data.
		/// </para>
		/// </param>
		//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glGetTexEnviv")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
				void GetTexEnv(System.Graphics.ES11.All env, System.Graphics.ES11.All pname, ref Int32 @params) {
			unsafe
			{
				fixed (Int32* @params_ptr = &@params) {
					Delegates.glGetTexEnviv((System.Graphics.ES11.All) env, (System.Graphics.ES11.All) pname, (Int32*) @params_ptr);
				}
			}
		}


		/// <summary>[requires: v1.1 and 1.1]
		/// Return texture environment parameters
		/// </summary>
		/// <param name="env">
		/// <para>
		/// Specifies a texture environment. May be GL_TEXTURE_ENV, GL_TEXTURE_FILTER_CONTROL, or GL_POINT_SPRITE.
		/// </para>
		/// </param>
		/// <param name="pname">
		/// <para>
		/// Specifies the symbolic name of a texture environment parameter. Accepted values are GL_TEXTURE_ENV_MODE, GL_TEXTURE_ENV_COLOR, GL_TEXTURE_LOD_BIAS, GL_COMBINE_RGB, GL_COMBINE_ALPHA, GL_SRC0_RGB, GL_SRC1_RGB, GL_SRC2_RGB, GL_SRC0_ALPHA, GL_SRC1_ALPHA, GL_SRC2_ALPHA, GL_OPERAND0_RGB, GL_OPERAND1_RGB, GL_OPERAND2_RGB, GL_OPERAND0_ALPHA, GL_OPERAND1_ALPHA, GL_OPERAND2_ALPHA, GL_RGB_SCALE, GL_ALPHA_SCALE, or GL_COORD_REPLACE.
		/// </para>
		/// </param>
		/// <param name="params">
		/// <para>
		/// Returns the requested data.
		/// </para>
		/// </param>
		[System.CLSCompliant(false)]
		//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glGetTexEnviv")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
		unsafe void GetTexEnv(System.Graphics.ES11.All env, System.Graphics.ES11.All pname, Int32* @params) {
			Delegates.glGetTexEnviv((System.Graphics.ES11.All) env, (System.Graphics.ES11.All) pname, (Int32*) @params);
		}

		/// <summary>[requires: v1.1 and 1.1]</summary>
		//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glGetTexEnvxv")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
				void GetTexEnvx(System.Graphics.ES11.All env, System.Graphics.ES11.All pname, int[] @params) {
			unsafe
			{
				fixed (int* @params_ptr = @params) {
					Delegates.glGetTexEnvxv((System.Graphics.ES11.All) env, (System.Graphics.ES11.All) pname, (int*) @params_ptr);
				}
			}
		}

		/// <summary>[requires: v1.1 and 1.1]</summary>
		//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glGetTexEnvxv")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
				void GetTexEnvx(System.Graphics.ES11.All env, System.Graphics.ES11.All pname, ref int @params) {
			unsafe
			{
				fixed (int* @params_ptr = &@params) {
					Delegates.glGetTexEnvxv((System.Graphics.ES11.All) env, (System.Graphics.ES11.All) pname, (int*) @params_ptr);
				}
			}
		}

		/// <summary>[requires: v1.1 and 1.1]</summary>
		[System.CLSCompliant(false)]
		//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glGetTexEnvxv")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
		unsafe void GetTexEnvx(System.Graphics.ES11.All env, System.Graphics.ES11.All pname, int* @params) {
			Delegates.glGetTexEnvxv((System.Graphics.ES11.All) env, (System.Graphics.ES11.All) pname, (int*) @params);
		}


		/// <summary>[requires: v1.1 and 1.1]
		/// Return texture parameter values
		/// </summary>
		/// <param name="target">
		/// <para>
		/// Specifies the symbolic name of the target texture. GL_TEXTURE_1D, GL_TEXTURE_2D, GL_TEXTURE_1D_ARRAY, GL_TEXTURE_2D_ARRAY, GL_TEXTURE_3D, GL_TEXTURE_RECTANGLE, and GL_TEXTURE_CUBE_MAP are accepted.
		/// </para>
		/// </param>
		/// <param name="pname">
		/// <para>
		/// Specifies the symbolic name of a texture parameter. GL_TEXTURE_BASE_LEVEL, GL_TEXTURE_BORDER_COLOR, GL_TEXTURE_COMPARE_MODE, GL_TEXTURE_COMPARE_FUNC, GL_TEXTURE_LOD_BIAS, GL_TEXTURE_MAG_FILTER, GL_TEXTURE_MAX_LEVEL, GL_TEXTURE_MAX_LOD, GL_TEXTURE_MIN_FILTER, GL_TEXTURE_MIN_LOD, GL_TEXTURE_SWIZZLE_R, GL_TEXTURE_SWIZZLE_G, GL_TEXTURE_SWIZZLE_B, GL_TEXTURE_SWIZZLE_A, GL_TEXTURE_SWIZZLE_RGBA, GL_TEXTURE_WRAP_S, GL_TEXTURE_WRAP_T, and GL_TEXTURE_WRAP_R are accepted.
		/// </para>
		/// </param>
		/// <param name="params">
		/// <para>
		/// Returns the texture parameters.
		/// </para>
		/// </param>
		//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glGetTexParameterfv")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
				void GetTexParameter(System.Graphics.ES11.All target, System.Graphics.ES11.All pname, Single[] @params) {
			unsafe
			{
				fixed (Single* @params_ptr = @params) {
					Delegates.glGetTexParameterfv((System.Graphics.ES11.All) target, (System.Graphics.ES11.All) pname, (Single*) @params_ptr);
				}
			}
		}


		/// <summary>[requires: v1.1 and 1.1]
		/// Return texture parameter values
		/// </summary>
		/// <param name="target">
		/// <para>
		/// Specifies the symbolic name of the target texture. GL_TEXTURE_1D, GL_TEXTURE_2D, GL_TEXTURE_1D_ARRAY, GL_TEXTURE_2D_ARRAY, GL_TEXTURE_3D, GL_TEXTURE_RECTANGLE, and GL_TEXTURE_CUBE_MAP are accepted.
		/// </para>
		/// </param>
		/// <param name="pname">
		/// <para>
		/// Specifies the symbolic name of a texture parameter. GL_TEXTURE_BASE_LEVEL, GL_TEXTURE_BORDER_COLOR, GL_TEXTURE_COMPARE_MODE, GL_TEXTURE_COMPARE_FUNC, GL_TEXTURE_LOD_BIAS, GL_TEXTURE_MAG_FILTER, GL_TEXTURE_MAX_LEVEL, GL_TEXTURE_MAX_LOD, GL_TEXTURE_MIN_FILTER, GL_TEXTURE_MIN_LOD, GL_TEXTURE_SWIZZLE_R, GL_TEXTURE_SWIZZLE_G, GL_TEXTURE_SWIZZLE_B, GL_TEXTURE_SWIZZLE_A, GL_TEXTURE_SWIZZLE_RGBA, GL_TEXTURE_WRAP_S, GL_TEXTURE_WRAP_T, and GL_TEXTURE_WRAP_R are accepted.
		/// </para>
		/// </param>
		/// <param name="params">
		/// <para>
		/// Returns the texture parameters.
		/// </para>
		/// </param>
		//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glGetTexParameterfv")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
				void GetTexParameter(System.Graphics.ES11.All target, System.Graphics.ES11.All pname, ref Single @params) {
			unsafe
			{
				fixed (Single* @params_ptr = &@params) {
					Delegates.glGetTexParameterfv((System.Graphics.ES11.All) target, (System.Graphics.ES11.All) pname, (Single*) @params_ptr);
				}
			}
		}


		/// <summary>[requires: v1.1 and 1.1]
		/// Return texture parameter values
		/// </summary>
		/// <param name="target">
		/// <para>
		/// Specifies the symbolic name of the target texture. GL_TEXTURE_1D, GL_TEXTURE_2D, GL_TEXTURE_1D_ARRAY, GL_TEXTURE_2D_ARRAY, GL_TEXTURE_3D, GL_TEXTURE_RECTANGLE, and GL_TEXTURE_CUBE_MAP are accepted.
		/// </para>
		/// </param>
		/// <param name="pname">
		/// <para>
		/// Specifies the symbolic name of a texture parameter. GL_TEXTURE_BASE_LEVEL, GL_TEXTURE_BORDER_COLOR, GL_TEXTURE_COMPARE_MODE, GL_TEXTURE_COMPARE_FUNC, GL_TEXTURE_LOD_BIAS, GL_TEXTURE_MAG_FILTER, GL_TEXTURE_MAX_LEVEL, GL_TEXTURE_MAX_LOD, GL_TEXTURE_MIN_FILTER, GL_TEXTURE_MIN_LOD, GL_TEXTURE_SWIZZLE_R, GL_TEXTURE_SWIZZLE_G, GL_TEXTURE_SWIZZLE_B, GL_TEXTURE_SWIZZLE_A, GL_TEXTURE_SWIZZLE_RGBA, GL_TEXTURE_WRAP_S, GL_TEXTURE_WRAP_T, and GL_TEXTURE_WRAP_R are accepted.
		/// </para>
		/// </param>
		/// <param name="params">
		/// <para>
		/// Returns the texture parameters.
		/// </para>
		/// </param>
		[System.CLSCompliant(false)]
		//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glGetTexParameterfv")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
		unsafe void GetTexParameter(System.Graphics.ES11.All target, System.Graphics.ES11.All pname, Single* @params) {
			Delegates.glGetTexParameterfv((System.Graphics.ES11.All) target, (System.Graphics.ES11.All) pname, (Single*) @params);
		}


		/// <summary>[requires: v1.1 and 1.1]
		/// Return texture parameter values
		/// </summary>
		/// <param name="target">
		/// <para>
		/// Specifies the symbolic name of the target texture. GL_TEXTURE_1D, GL_TEXTURE_2D, GL_TEXTURE_1D_ARRAY, GL_TEXTURE_2D_ARRAY, GL_TEXTURE_3D, GL_TEXTURE_RECTANGLE, and GL_TEXTURE_CUBE_MAP are accepted.
		/// </para>
		/// </param>
		/// <param name="pname">
		/// <para>
		/// Specifies the symbolic name of a texture parameter. GL_TEXTURE_BASE_LEVEL, GL_TEXTURE_BORDER_COLOR, GL_TEXTURE_COMPARE_MODE, GL_TEXTURE_COMPARE_FUNC, GL_TEXTURE_LOD_BIAS, GL_TEXTURE_MAG_FILTER, GL_TEXTURE_MAX_LEVEL, GL_TEXTURE_MAX_LOD, GL_TEXTURE_MIN_FILTER, GL_TEXTURE_MIN_LOD, GL_TEXTURE_SWIZZLE_R, GL_TEXTURE_SWIZZLE_G, GL_TEXTURE_SWIZZLE_B, GL_TEXTURE_SWIZZLE_A, GL_TEXTURE_SWIZZLE_RGBA, GL_TEXTURE_WRAP_S, GL_TEXTURE_WRAP_T, and GL_TEXTURE_WRAP_R are accepted.
		/// </para>
		/// </param>
		/// <param name="params">
		/// <para>
		/// Returns the texture parameters.
		/// </para>
		/// </param>
		//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glGetTexParameteriv")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
				void GetTexParameter(System.Graphics.ES11.All target, System.Graphics.ES11.All pname, Int32[] @params) {
			unsafe
			{
				fixed (Int32* @params_ptr = @params) {
					Delegates.glGetTexParameteriv((System.Graphics.ES11.All) target, (System.Graphics.ES11.All) pname, (Int32*) @params_ptr);
				}
			}
		}


		/// <summary>[requires: v1.1 and 1.1]
		/// Return texture parameter values
		/// </summary>
		/// <param name="target">
		/// <para>
		/// Specifies the symbolic name of the target texture. GL_TEXTURE_1D, GL_TEXTURE_2D, GL_TEXTURE_1D_ARRAY, GL_TEXTURE_2D_ARRAY, GL_TEXTURE_3D, GL_TEXTURE_RECTANGLE, and GL_TEXTURE_CUBE_MAP are accepted.
		/// </para>
		/// </param>
		/// <param name="pname">
		/// <para>
		/// Specifies the symbolic name of a texture parameter. GL_TEXTURE_BASE_LEVEL, GL_TEXTURE_BORDER_COLOR, GL_TEXTURE_COMPARE_MODE, GL_TEXTURE_COMPARE_FUNC, GL_TEXTURE_LOD_BIAS, GL_TEXTURE_MAG_FILTER, GL_TEXTURE_MAX_LEVEL, GL_TEXTURE_MAX_LOD, GL_TEXTURE_MIN_FILTER, GL_TEXTURE_MIN_LOD, GL_TEXTURE_SWIZZLE_R, GL_TEXTURE_SWIZZLE_G, GL_TEXTURE_SWIZZLE_B, GL_TEXTURE_SWIZZLE_A, GL_TEXTURE_SWIZZLE_RGBA, GL_TEXTURE_WRAP_S, GL_TEXTURE_WRAP_T, and GL_TEXTURE_WRAP_R are accepted.
		/// </para>
		/// </param>
		/// <param name="params">
		/// <para>
		/// Returns the texture parameters.
		/// </para>
		/// </param>
		//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glGetTexParameteriv")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
				void GetTexParameter(System.Graphics.ES11.All target, System.Graphics.ES11.All pname, ref Int32 @params) {
			unsafe
			{
				fixed (Int32* @params_ptr = &@params) {
					Delegates.glGetTexParameteriv((System.Graphics.ES11.All) target, (System.Graphics.ES11.All) pname, (Int32*) @params_ptr);
				}
			}
		}


		/// <summary>[requires: v1.1 and 1.1]
		/// Return texture parameter values
		/// </summary>
		/// <param name="target">
		/// <para>
		/// Specifies the symbolic name of the target texture. GL_TEXTURE_1D, GL_TEXTURE_2D, GL_TEXTURE_1D_ARRAY, GL_TEXTURE_2D_ARRAY, GL_TEXTURE_3D, GL_TEXTURE_RECTANGLE, and GL_TEXTURE_CUBE_MAP are accepted.
		/// </para>
		/// </param>
		/// <param name="pname">
		/// <para>
		/// Specifies the symbolic name of a texture parameter. GL_TEXTURE_BASE_LEVEL, GL_TEXTURE_BORDER_COLOR, GL_TEXTURE_COMPARE_MODE, GL_TEXTURE_COMPARE_FUNC, GL_TEXTURE_LOD_BIAS, GL_TEXTURE_MAG_FILTER, GL_TEXTURE_MAX_LEVEL, GL_TEXTURE_MAX_LOD, GL_TEXTURE_MIN_FILTER, GL_TEXTURE_MIN_LOD, GL_TEXTURE_SWIZZLE_R, GL_TEXTURE_SWIZZLE_G, GL_TEXTURE_SWIZZLE_B, GL_TEXTURE_SWIZZLE_A, GL_TEXTURE_SWIZZLE_RGBA, GL_TEXTURE_WRAP_S, GL_TEXTURE_WRAP_T, and GL_TEXTURE_WRAP_R are accepted.
		/// </para>
		/// </param>
		/// <param name="params">
		/// <para>
		/// Returns the texture parameters.
		/// </para>
		/// </param>
		[System.CLSCompliant(false)]
		//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glGetTexParameteriv")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
		unsafe void GetTexParameter(System.Graphics.ES11.All target, System.Graphics.ES11.All pname, Int32* @params) {
			Delegates.glGetTexParameteriv((System.Graphics.ES11.All) target, (System.Graphics.ES11.All) pname, (Int32*) @params);
		}

		/// <summary>[requires: v1.1 and 1.1]</summary>
		//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glGetTexParameterxv")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
				void GetTexParameterx(System.Graphics.ES11.All target, System.Graphics.ES11.All pname, int[] @params) {
			unsafe
			{
				fixed (int* @params_ptr = @params) {
					Delegates.glGetTexParameterxv((System.Graphics.ES11.All) target, (System.Graphics.ES11.All) pname, (int*) @params_ptr);
				}
			}
		}

		/// <summary>[requires: v1.1 and 1.1]</summary>
		//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glGetTexParameterxv")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
				void GetTexParameterx(System.Graphics.ES11.All target, System.Graphics.ES11.All pname, ref int @params) {
			unsafe
			{
				fixed (int* @params_ptr = &@params) {
					Delegates.glGetTexParameterxv((System.Graphics.ES11.All) target, (System.Graphics.ES11.All) pname, (int*) @params_ptr);
				}
			}
		}

		/// <summary>[requires: v1.1 and 1.1]</summary>
		[System.CLSCompliant(false)]
		//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glGetTexParameterxv")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
		unsafe void GetTexParameterx(System.Graphics.ES11.All target, System.Graphics.ES11.All pname, int* @params) {
			Delegates.glGetTexParameterxv((System.Graphics.ES11.All) target, (System.Graphics.ES11.All) pname, (int*) @params);
		}


		/// <summary>[requires: v1.1 and 1.1]
		/// Specify implementation-specific hints
		/// </summary>
		/// <param name="target">
		/// <para>
		/// Specifies a symbolic constant indicating the behavior to be controlled. GL_LINE_SMOOTH_HINT, GL_POLYGON_SMOOTH_HINT, GL_TEXTURE_COMPRESSION_HINT, and GL_FRAGMENT_SHADER_DERIVATIVE_HINT are accepted.
		/// </para>
		/// </param>
		/// <param name="mode">
		/// <para>
		/// Specifies a symbolic constant indicating the desired behavior. GL_FASTEST, GL_NICEST, and GL_DONT_CARE are accepted.
		/// </para>
		/// </param>
		//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glHint")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
				void Hint(System.Graphics.ES11.All target, System.Graphics.ES11.All mode) {
			Delegates.glHint((System.Graphics.ES11.All) target, (System.Graphics.ES11.All) mode);
		}


		/// <summary>[requires: v1.1 and 1.1]
		/// Determine if a name corresponds to a buffer object
		/// </summary>
		/// <param name="buffer">
		/// <para>
		/// Specifies a value that may be the name of a buffer object.
		/// </para>
		/// </param>
		//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glIsBuffer")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
				bool IsBuffer(Int32 buffer) {
			return Delegates.glIsBuffer((UInt32) buffer);
		}


		/// <summary>[requires: v1.1 and 1.1]
		/// Determine if a name corresponds to a buffer object
		/// </summary>
		/// <param name="buffer">
		/// <para>
		/// Specifies a value that may be the name of a buffer object.
		/// </para>
		/// </param>
		[System.CLSCompliant(false)]
		//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glIsBuffer")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
		bool IsBuffer(UInt32 buffer) {
			return Delegates.glIsBuffer((UInt32) buffer);
		}


		/// <summary>[requires: v1.1 and 1.1]
		/// Test whether a capability is enabled
		/// </summary>
		/// <param name="cap">
		/// <para>
		/// Specifies a symbolic constant indicating a GL capability.
		/// </para>
		/// </param>
		//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glIsEnabled")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
				bool IsEnabled(System.Graphics.ES11.All cap) {
			return Delegates.glIsEnabled((System.Graphics.ES11.All) cap);
		}


		/// <summary>[requires: v1.1 and 1.1]
		/// Determine if a name corresponds to a texture
		/// </summary>
		/// <param name="texture">
		/// <para>
		/// Specifies a value that may be the name of a texture.
		/// </para>
		/// </param>
		//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glIsTexture")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
				bool IsTexture(Int32 texture) {
			return Delegates.glIsTexture((UInt32) texture);
		}


		/// <summary>[requires: v1.1 and 1.1]
		/// Determine if a name corresponds to a texture
		/// </summary>
		/// <param name="texture">
		/// <para>
		/// Specifies a value that may be the name of a texture.
		/// </para>
		/// </param>
		[System.CLSCompliant(false)]
		//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glIsTexture")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
		bool IsTexture(UInt32 texture) {
			return Delegates.glIsTexture((UInt32) texture);
		}


		/// <summary>[requires: v1.1 and 1.1]
		/// Set light source parameters
		/// </summary>
		/// <param name="light">
		/// <para>
		/// Specifies a light. The number of lights depends on the implementation, but at least eight lights are supported. They are identified by symbolic names of the form GL_LIGHT , where i ranges from 0 to the value of GL_MAX_LIGHTS - 1.
		/// </para>
		/// </param>
		/// <param name="pname">
		/// <para>
		/// Specifies a single-valued light source parameter for light. GL_SPOT_EXPONENT, GL_SPOT_CUTOFF, GL_CONSTANT_ATTENUATION, GL_LINEAR_ATTENUATION, and GL_QUADRATIC_ATTENUATION are accepted.
		/// </para>
		/// </param>
		/// <param name="param">
		/// <para>
		/// Specifies the value that parameter pname of light source light will be set to.
		/// </para>
		/// </param>
		//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glLightf")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
				void Light(System.Graphics.ES11.All light, System.Graphics.ES11.All pname, Single param) {
			Delegates.glLightf((System.Graphics.ES11.All) light, (System.Graphics.ES11.All) pname, (Single) param);
		}


		/// <summary>[requires: v1.1 and 1.1]
		/// Set light source parameters
		/// </summary>
		/// <param name="light">
		/// <para>
		/// Specifies a light. The number of lights depends on the implementation, but at least eight lights are supported. They are identified by symbolic names of the form GL_LIGHT , where i ranges from 0 to the value of GL_MAX_LIGHTS - 1.
		/// </para>
		/// </param>
		/// <param name="pname">
		/// <para>
		/// Specifies a single-valued light source parameter for light. GL_SPOT_EXPONENT, GL_SPOT_CUTOFF, GL_CONSTANT_ATTENUATION, GL_LINEAR_ATTENUATION, and GL_QUADRATIC_ATTENUATION are accepted.
		/// </para>
		/// </param>
		/// <param name="params">
		/// <para>
		/// Specifies the value that parameter pname of light source light will be set to.
		/// </para>
		/// </param>
		//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glLightfv")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
				void Light(System.Graphics.ES11.All light, System.Graphics.ES11.All pname, Single[] @params) {
			unsafe
			{
				fixed (Single* @params_ptr = @params) {
					Delegates.glLightfv((System.Graphics.ES11.All) light, (System.Graphics.ES11.All) pname, (Single*) @params_ptr);
				}
			}
		}


		/// <summary>[requires: v1.1 and 1.1]
		/// Set light source parameters
		/// </summary>
		/// <param name="light">
		/// <para>
		/// Specifies a light. The number of lights depends on the implementation, but at least eight lights are supported. They are identified by symbolic names of the form GL_LIGHT , where i ranges from 0 to the value of GL_MAX_LIGHTS - 1.
		/// </para>
		/// </param>
		/// <param name="pname">
		/// <para>
		/// Specifies a single-valued light source parameter for light. GL_SPOT_EXPONENT, GL_SPOT_CUTOFF, GL_CONSTANT_ATTENUATION, GL_LINEAR_ATTENUATION, and GL_QUADRATIC_ATTENUATION are accepted.
		/// </para>
		/// </param>
		/// <param name="params">
		/// <para>
		/// Specifies the value that parameter pname of light source light will be set to.
		/// </para>
		/// </param>
		[System.CLSCompliant(false)]
		//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glLightfv")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
		unsafe void Light(System.Graphics.ES11.All light, System.Graphics.ES11.All pname, Single* @params) {
			Delegates.glLightfv((System.Graphics.ES11.All) light, (System.Graphics.ES11.All) pname, (Single*) @params);
		}


		/// <summary>[requires: v1.1 and 1.1]
		/// Set the lighting model parameters
		/// </summary>
		/// <param name="pname">
		/// <para>
		/// Specifies a single-valued lighting model parameter. GL_LIGHT_MODEL_LOCAL_VIEWER, GL_LIGHT_MODEL_COLOR_CONTROL, and GL_LIGHT_MODEL_TWO_SIDE are accepted.
		/// </para>
		/// </param>
		/// <param name="param">
		/// <para>
		/// Specifies the value that param will be set to.
		/// </para>
		/// </param>
		//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glLightModelf")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
				void LightModel(System.Graphics.ES11.All pname, Single param) {
			Delegates.glLightModelf((System.Graphics.ES11.All) pname, (Single) param);
		}


		/// <summary>[requires: v1.1 and 1.1]
		/// Set the lighting model parameters
		/// </summary>
		/// <param name="pname">
		/// <para>
		/// Specifies a single-valued lighting model parameter. GL_LIGHT_MODEL_LOCAL_VIEWER, GL_LIGHT_MODEL_COLOR_CONTROL, and GL_LIGHT_MODEL_TWO_SIDE are accepted.
		/// </para>
		/// </param>
		/// <param name="params">
		/// <para>
		/// Specifies the value that param will be set to.
		/// </para>
		/// </param>
		//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glLightModelfv")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
				void LightModel(System.Graphics.ES11.All pname, Single[] @params) {
			unsafe
			{
				fixed (Single* @params_ptr = @params) {
					Delegates.glLightModelfv((System.Graphics.ES11.All) pname, (Single*) @params_ptr);
				}
			}
		}


		/// <summary>[requires: v1.1 and 1.1]
		/// Set the lighting model parameters
		/// </summary>
		/// <param name="pname">
		/// <para>
		/// Specifies a single-valued lighting model parameter. GL_LIGHT_MODEL_LOCAL_VIEWER, GL_LIGHT_MODEL_COLOR_CONTROL, and GL_LIGHT_MODEL_TWO_SIDE are accepted.
		/// </para>
		/// </param>
		/// <param name="params">
		/// <para>
		/// Specifies the value that param will be set to.
		/// </para>
		/// </param>
		[System.CLSCompliant(false)]
		//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glLightModelfv")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
		unsafe void LightModel(System.Graphics.ES11.All pname, Single* @params) {
			Delegates.glLightModelfv((System.Graphics.ES11.All) pname, (Single*) @params);
		}

		/// <summary>[requires: v1.1 and 1.1]</summary>
		//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glLightModelx")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
				void LightModelx(System.Graphics.ES11.All pname, int param) {
			Delegates.glLightModelx((System.Graphics.ES11.All) pname, (int) param);
		}

		/// <summary>[requires: v1.1 and 1.1]</summary>
		//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glLightModelxv")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
				void LightModelx(System.Graphics.ES11.All pname, int[] @params) {
			unsafe
			{
				fixed (int* @params_ptr = @params) {
					Delegates.glLightModelxv((System.Graphics.ES11.All) pname, (int*) @params_ptr);
				}
			}
		}

		/// <summary>[requires: v1.1 and 1.1]</summary>
		[System.CLSCompliant(false)]
		//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glLightModelxv")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
		unsafe void LightModelx(System.Graphics.ES11.All pname, int* @params) {
			Delegates.glLightModelxv((System.Graphics.ES11.All) pname, (int*) @params);
		}

		/// <summary>[requires: v1.1 and 1.1]</summary>
		//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glLightx")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
				void Lightx(System.Graphics.ES11.All light, System.Graphics.ES11.All pname, int param) {
			Delegates.glLightx((System.Graphics.ES11.All) light, (System.Graphics.ES11.All) pname, (int) param);
		}

		/// <summary>[requires: v1.1 and 1.1]</summary>
		//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glLightxv")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
				void Lightx(System.Graphics.ES11.All light, System.Graphics.ES11.All pname, int[] @params) {
			unsafe
			{
				fixed (int* @params_ptr = @params) {
					Delegates.glLightxv((System.Graphics.ES11.All) light, (System.Graphics.ES11.All) pname, (int*) @params_ptr);
				}
			}
		}

		/// <summary>[requires: v1.1 and 1.1]</summary>
		[System.CLSCompliant(false)]
		//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glLightxv")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
		unsafe void Lightx(System.Graphics.ES11.All light, System.Graphics.ES11.All pname, int* @params) {
			Delegates.glLightxv((System.Graphics.ES11.All) light, (System.Graphics.ES11.All) pname, (int*) @params);
		}


		/// <summary>[requires: v1.1 and 1.1]
		/// Specify the width of rasterized lines
		/// </summary>
		/// <param name="width">
		/// <para>
		/// Specifies the width of rasterized lines. The initial value is 1.
		/// </para>
		/// </param>
		//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glLineWidth")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
				void LineWidth(Single width) {
			Delegates.glLineWidth((Single) width);
		}

		/// <summary>[requires: v1.1 and 1.1]</summary>
		//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glLineWidthx")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
				void LineWidthx(int width) {
			Delegates.glLineWidthx((int) width);
		}


		/// <summary>[requires: v1.1 and 1.1]
		/// Replace the current matrix with the identity matrix
		/// </summary>
		//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glLoadIdentity")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
				void LoadIdentity() {
			Delegates.glLoadIdentity();
		}


		/// <summary>[requires: v1.1 and 1.1]
		/// Replace the current matrix with the specified matrix
		/// </summary>
		/// <param name="m">
		/// <para>
		/// Specifies a pointer to 16 consecutive values, which are used as the elements of a 4 times 4 column-major matrix.
		/// </para>
		/// </param>
		//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glLoadMatrixf")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
				void LoadMatrix(Single[] m) {
			unsafe
			{
				fixed (Single* m_ptr = m) {
					Delegates.glLoadMatrixf((Single*) m_ptr);
				}
			}
		}


		/// <summary>[requires: v1.1 and 1.1]
		/// Replace the current matrix with the specified matrix
		/// </summary>
		/// <param name="m">
		/// <para>
		/// Specifies a pointer to 16 consecutive values, which are used as the elements of a 4 times 4 column-major matrix.
		/// </para>
		/// </param>
		//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glLoadMatrixf")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
				void LoadMatrix(ref Single m) {
			unsafe
			{
				fixed (Single* m_ptr = &m) {
					Delegates.glLoadMatrixf((Single*) m_ptr);
				}
			}
		}


		/// <summary>[requires: v1.1 and 1.1]
		/// Replace the current matrix with the specified matrix
		/// </summary>
		/// <param name="m">
		/// <para>
		/// Specifies a pointer to 16 consecutive values, which are used as the elements of a 4 times 4 column-major matrix.
		/// </para>
		/// </param>
		[System.CLSCompliant(false)]
		//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glLoadMatrixf")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
		unsafe void LoadMatrix(Single* m) {
			Delegates.glLoadMatrixf((Single*) m);
		}

		/// <summary>[requires: v1.1 and 1.1]</summary>
		//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glLoadMatrixx")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
				void LoadMatrixx(int[] m) {
			unsafe
			{
				fixed (int* m_ptr = m) {
					Delegates.glLoadMatrixx((int*) m_ptr);
				}
			}
		}

		/// <summary>[requires: v1.1 and 1.1]</summary>
		//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glLoadMatrixx")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
				void LoadMatrixx(ref int m) {
			unsafe
			{
				fixed (int* m_ptr = &m) {
					Delegates.glLoadMatrixx((int*) m_ptr);
				}
			}
		}

		/// <summary>[requires: v1.1 and 1.1]</summary>
		[System.CLSCompliant(false)]
		//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glLoadMatrixx")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
		unsafe void LoadMatrixx(int* m) {
			Delegates.glLoadMatrixx((int*) m);
		}


		/// <summary>[requires: v1.1 and 1.1]
		/// Specify a logical pixel operation for rendering
		/// </summary>
		/// <param name="opcode">
		/// <para>
		/// Specifies a symbolic constant that selects a logical operation. The following symbols are accepted: GL_CLEAR, GL_SET, GL_COPY, GL_COPY_INVERTED, GL_NOOP, GL_INVERT, GL_AND, GL_NAND, GL_OR, GL_NOR, GL_XOR, GL_EQUIV, GL_AND_REVERSE, GL_AND_INVERTED, GL_OR_REVERSE, and GL_OR_INVERTED. The initial value is GL_COPY.
		/// </para>
		/// </param>
		//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glLogicOp")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
				void LogicOp(System.Graphics.ES11.All opcode) {
			Delegates.glLogicOp((System.Graphics.ES11.All) opcode);
		}


		/// <summary>[requires: v1.1 and 1.1]
		/// Specify material parameters for the lighting model
		/// </summary>
		/// <param name="face">
		/// <para>
		/// Specifies which face or faces are being updated. Must be one of GL_FRONT, GL_BACK, or GL_FRONT_AND_BACK.
		/// </para>
		/// </param>
		/// <param name="pname">
		/// <para>
		/// Specifies the single-valued material parameter of the face or faces that is being updated. Must be GL_SHININESS.
		/// </para>
		/// </param>
		/// <param name="param">
		/// <para>
		/// Specifies the value that parameter GL_SHININESS will be set to.
		/// </para>
		/// </param>
		//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glMaterialf")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
				void Material(System.Graphics.ES11.All face, System.Graphics.ES11.All pname, Single param) {
			Delegates.glMaterialf((System.Graphics.ES11.All) face, (System.Graphics.ES11.All) pname, (Single) param);
		}


		/// <summary>[requires: v1.1 and 1.1]
		/// Specify material parameters for the lighting model
		/// </summary>
		/// <param name="face">
		/// <para>
		/// Specifies which face or faces are being updated. Must be one of GL_FRONT, GL_BACK, or GL_FRONT_AND_BACK.
		/// </para>
		/// </param>
		/// <param name="pname">
		/// <para>
		/// Specifies the single-valued material parameter of the face or faces that is being updated. Must be GL_SHININESS.
		/// </para>
		/// </param>
		/// <param name="params">
		/// <para>
		/// Specifies the value that parameter GL_SHININESS will be set to.
		/// </para>
		/// </param>
		//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glMaterialfv")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
				void Material(System.Graphics.ES11.All face, System.Graphics.ES11.All pname, Single[] @params) {
			unsafe
			{
				fixed (Single* @params_ptr = @params) {
					Delegates.glMaterialfv((System.Graphics.ES11.All) face, (System.Graphics.ES11.All) pname, (Single*) @params_ptr);
				}
			}
		}


		/// <summary>[requires: v1.1 and 1.1]
		/// Specify material parameters for the lighting model
		/// </summary>
		/// <param name="face">
		/// <para>
		/// Specifies which face or faces are being updated. Must be one of GL_FRONT, GL_BACK, or GL_FRONT_AND_BACK.
		/// </para>
		/// </param>
		/// <param name="pname">
		/// <para>
		/// Specifies the single-valued material parameter of the face or faces that is being updated. Must be GL_SHININESS.
		/// </para>
		/// </param>
		/// <param name="params">
		/// <para>
		/// Specifies the value that parameter GL_SHININESS will be set to.
		/// </para>
		/// </param>
		[System.CLSCompliant(false)]
		//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glMaterialfv")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
		unsafe void Material(System.Graphics.ES11.All face, System.Graphics.ES11.All pname, Single* @params) {
			Delegates.glMaterialfv((System.Graphics.ES11.All) face, (System.Graphics.ES11.All) pname, (Single*) @params);
		}

		/// <summary>[requires: v1.1 and 1.1]</summary>
		//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glMaterialx")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
				void Materialx(System.Graphics.ES11.All face, System.Graphics.ES11.All pname, int param) {
			Delegates.glMaterialx((System.Graphics.ES11.All) face, (System.Graphics.ES11.All) pname, (int) param);
		}

		/// <summary>[requires: v1.1 and 1.1]</summary>
		//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glMaterialxv")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
				void Materialx(System.Graphics.ES11.All face, System.Graphics.ES11.All pname, int[] @params) {
			unsafe
			{
				fixed (int* @params_ptr = @params) {
					Delegates.glMaterialxv((System.Graphics.ES11.All) face, (System.Graphics.ES11.All) pname, (int*) @params_ptr);
				}
			}
		}

		/// <summary>[requires: v1.1 and 1.1]</summary>
		[System.CLSCompliant(false)]
		//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glMaterialxv")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
		unsafe void Materialx(System.Graphics.ES11.All face, System.Graphics.ES11.All pname, int* @params) {
			Delegates.glMaterialxv((System.Graphics.ES11.All) face, (System.Graphics.ES11.All) pname, (int*) @params);
		}


		/// <summary>[requires: v1.1 and 1.1]
		/// Specify which matrix is the current matrix
		/// </summary>
		/// <param name="mode">
		/// <para>
		/// Specifies which matrix stack is the target for subsequent matrix operations. Three values are accepted: GL_MODELVIEW, GL_PROJECTION, and GL_TEXTURE. The initial value is GL_MODELVIEW. Additionally, if the ARB_imaging extension is supported, GL_COLOR is also accepted.
		/// </para>
		/// </param>
		//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glMatrixMode")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
				void MatrixMode(System.Graphics.ES11.All mode) {
			Delegates.glMatrixMode((System.Graphics.ES11.All) mode);
		}


		/// <summary>[requires: v1.1 and 1.1]
		/// Set the current texture coordinates. The number of texture units is implementation dependent, but must be at least two. Symbolic constant must be one of GL_TEXTURE, where i ranges from 0 to GL_MAX_TEXTURE_COORDS - 1, which is an implementation-dependent value.
		/// </summary>
		//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glMultiTexCoord4f")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
				void MultiTexCoord4(System.Graphics.ES11.All target, Single s, Single t, Single r, Single q) {
			Delegates.glMultiTexCoord4f((System.Graphics.ES11.All) target, (Single) s, (Single) t, (Single) r, (Single) q);
		}

		/// <summary>[requires: v1.1 and 1.1]</summary>
		//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glMultiTexCoord4x")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
				void MultiTexCoord4x(System.Graphics.ES11.All target, int s, int t, int r, int q) {
			Delegates.glMultiTexCoord4x((System.Graphics.ES11.All) target, (int) s, (int) t, (int) r, (int) q);
		}


		/// <summary>[requires: v1.1 and 1.1]
		/// Multiply the current matrix with the specified matrix
		/// </summary>
		/// <param name="m">
		/// <para>
		/// Points to 16 consecutive values that are used as the elements of a 4 times 4 column-major matrix.
		/// </para>
		/// </param>
		//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glMultMatrixf")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
				void MultMatrix(Single[] m) {
			unsafe
			{
				fixed (Single* m_ptr = m) {
					Delegates.glMultMatrixf((Single*) m_ptr);
				}
			}
		}


		/// <summary>[requires: v1.1 and 1.1]
		/// Multiply the current matrix with the specified matrix
		/// </summary>
		/// <param name="m">
		/// <para>
		/// Points to 16 consecutive values that are used as the elements of a 4 times 4 column-major matrix.
		/// </para>
		/// </param>
		//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glMultMatrixf")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
				void MultMatrix(ref Single m) {
			unsafe
			{
				fixed (Single* m_ptr = &m) {
					Delegates.glMultMatrixf((Single*) m_ptr);
				}
			}
		}


		/// <summary>[requires: v1.1 and 1.1]
		/// Multiply the current matrix with the specified matrix
		/// </summary>
		/// <param name="m">
		/// <para>
		/// Points to 16 consecutive values that are used as the elements of a 4 times 4 column-major matrix.
		/// </para>
		/// </param>
		[System.CLSCompliant(false)]
		//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glMultMatrixf")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
		unsafe void MultMatrix(Single* m) {
			Delegates.glMultMatrixf((Single*) m);
		}

		/// <summary>[requires: v1.1 and 1.1]</summary>
		//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glMultMatrixx")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
				void MultMatrixx(int[] m) {
			unsafe
			{
				fixed (int* m_ptr = m) {
					Delegates.glMultMatrixx((int*) m_ptr);
				}
			}
		}

		/// <summary>[requires: v1.1 and 1.1]</summary>
		//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glMultMatrixx")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
				void MultMatrixx(ref int m) {
			unsafe
			{
				fixed (int* m_ptr = &m) {
					Delegates.glMultMatrixx((int*) m_ptr);
				}
			}
		}

		/// <summary>[requires: v1.1 and 1.1]</summary>
		[System.CLSCompliant(false)]
		//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glMultMatrixx")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
		unsafe void MultMatrixx(int* m) {
			Delegates.glMultMatrixx((int*) m);
		}


		/// <summary>[requires: v1.1 and 1.1]
		/// Set the current normal vector
		/// </summary>
		//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glNormal3f")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
				void Normal3(Single nx, Single ny, Single nz) {
			Delegates.glNormal3f((Single) nx, (Single) ny, (Single) nz);
		}

		/// <summary>[requires: v1.1 and 1.1]</summary>
		//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glNormal3x")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
				void Normal3x(int nx, int ny, int nz) {
			Delegates.glNormal3x((int) nx, (int) ny, (int) nz);
		}


		/// <summary>[requires: v1.1 and 1.1]
		/// Define an array of normals
		/// </summary>
		/// <param name="type">
		/// <para>
		/// Specifies the data type of each coordinate in the array. Symbolic constants GL_BYTE, GL_SHORT, GL_INT, GL_FLOAT, and GL_DOUBLE are accepted. The initial value is GL_FLOAT.
		/// </para>
		/// </param>
		/// <param name="stride">
		/// <para>
		/// Specifies the byte offset between consecutive normals. If stride is 0, the normals are understood to be tightly packed in the array. The initial value is 0.
		/// </para>
		/// </param>
		/// <param name="pointer">
		/// <para>
		/// Specifies a pointer to the first coordinate of the first normal in the array. The initial value is 0.
		/// </para>
		/// </param>
		//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glNormalPointer")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
				void NormalPointer(System.Graphics.ES11.All type, Int32 stride, IntPtr pointer) {
			Delegates.glNormalPointer((System.Graphics.ES11.All) type, (Int32) stride, (IntPtr) pointer);
		}


		/// <summary>[requires: v1.1 and 1.1]
		/// Define an array of normals
		/// </summary>
		/// <param name="type">
		/// <para>
		/// Specifies the data type of each coordinate in the array. Symbolic constants GL_BYTE, GL_SHORT, GL_INT, GL_FLOAT, and GL_DOUBLE are accepted. The initial value is GL_FLOAT.
		/// </para>
		/// </param>
		/// <param name="stride">
		/// <para>
		/// Specifies the byte offset between consecutive normals. If stride is 0, the normals are understood to be tightly packed in the array. The initial value is 0.
		/// </para>
		/// </param>
		/// <param name="pointer">
		/// <para>
		/// Specifies a pointer to the first coordinate of the first normal in the array. The initial value is 0.
		/// </para>
		/// </param>
		//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glNormalPointer")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
				void NormalPointer<T2>(System.Graphics.ES11.All type, Int32 stride, [InAttribute, OutAttribute] T2[] pointer)
					where T2 : struct {
			GCHandle pointer_ptr = GCHandle.Alloc(pointer, GCHandleType.Pinned);
			try {
				Delegates.glNormalPointer((System.Graphics.ES11.All) type, (Int32) stride, (IntPtr) pointer_ptr.AddrOfPinnedObject());
			} finally {
				pointer_ptr.Free();
			}
		}


		/// <summary>[requires: v1.1 and 1.1]
		/// Define an array of normals
		/// </summary>
		/// <param name="type">
		/// <para>
		/// Specifies the data type of each coordinate in the array. Symbolic constants GL_BYTE, GL_SHORT, GL_INT, GL_FLOAT, and GL_DOUBLE are accepted. The initial value is GL_FLOAT.
		/// </para>
		/// </param>
		/// <param name="stride">
		/// <para>
		/// Specifies the byte offset between consecutive normals. If stride is 0, the normals are understood to be tightly packed in the array. The initial value is 0.
		/// </para>
		/// </param>
		/// <param name="pointer">
		/// <para>
		/// Specifies a pointer to the first coordinate of the first normal in the array. The initial value is 0.
		/// </para>
		/// </param>
		//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glNormalPointer")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
				void NormalPointer<T2>(System.Graphics.ES11.All type, Int32 stride, [InAttribute, OutAttribute] T2[,] pointer)
					where T2 : struct {
			GCHandle pointer_ptr = GCHandle.Alloc(pointer, GCHandleType.Pinned);
			try {
				Delegates.glNormalPointer((System.Graphics.ES11.All) type, (Int32) stride, (IntPtr) pointer_ptr.AddrOfPinnedObject());
			} finally {
				pointer_ptr.Free();
			}
		}


		/// <summary>[requires: v1.1 and 1.1]
		/// Define an array of normals
		/// </summary>
		/// <param name="type">
		/// <para>
		/// Specifies the data type of each coordinate in the array. Symbolic constants GL_BYTE, GL_SHORT, GL_INT, GL_FLOAT, and GL_DOUBLE are accepted. The initial value is GL_FLOAT.
		/// </para>
		/// </param>
		/// <param name="stride">
		/// <para>
		/// Specifies the byte offset between consecutive normals. If stride is 0, the normals are understood to be tightly packed in the array. The initial value is 0.
		/// </para>
		/// </param>
		/// <param name="pointer">
		/// <para>
		/// Specifies a pointer to the first coordinate of the first normal in the array. The initial value is 0.
		/// </para>
		/// </param>
		//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glNormalPointer")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
				void NormalPointer<T2>(System.Graphics.ES11.All type, Int32 stride, [InAttribute, OutAttribute] T2[,,] pointer)
					where T2 : struct {
			GCHandle pointer_ptr = GCHandle.Alloc(pointer, GCHandleType.Pinned);
			try {
				Delegates.glNormalPointer((System.Graphics.ES11.All) type, (Int32) stride, (IntPtr) pointer_ptr.AddrOfPinnedObject());
			} finally {
				pointer_ptr.Free();
			}
		}


		/// <summary>[requires: v1.1 and 1.1]
		/// Define an array of normals
		/// </summary>
		/// <param name="type">
		/// <para>
		/// Specifies the data type of each coordinate in the array. Symbolic constants GL_BYTE, GL_SHORT, GL_INT, GL_FLOAT, and GL_DOUBLE are accepted. The initial value is GL_FLOAT.
		/// </para>
		/// </param>
		/// <param name="stride">
		/// <para>
		/// Specifies the byte offset between consecutive normals. If stride is 0, the normals are understood to be tightly packed in the array. The initial value is 0.
		/// </para>
		/// </param>
		/// <param name="pointer">
		/// <para>
		/// Specifies a pointer to the first coordinate of the first normal in the array. The initial value is 0.
		/// </para>
		/// </param>
		//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glNormalPointer")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
				void NormalPointer<T2>(System.Graphics.ES11.All type, Int32 stride, [InAttribute, OutAttribute] ref T2 pointer)
					where T2 : struct {
			GCHandle pointer_ptr = GCHandle.Alloc(pointer, GCHandleType.Pinned);
			try {
				Delegates.glNormalPointer((System.Graphics.ES11.All) type, (Int32) stride, (IntPtr) pointer_ptr.AddrOfPinnedObject());
				pointer = (T2) pointer_ptr.Target;
			} finally {
				pointer_ptr.Free();
			}
		}


		/// <summary>[requires: v1.1 and 1.1]
		/// Multiply the current matrix with an orthographic matrix
		/// </summary>
		//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glOrthof")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
				void Ortho(Single left, Single right, Single bottom, Single top, Single zNear, Single zFar) {
			Delegates.glOrthof((Single) left, (Single) right, (Single) bottom, (Single) top, (Single) zNear, (Single) zFar);
		}

		/// <summary>[requires: v1.1 and 1.1]</summary>
		//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glOrthox")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
				void Orthox(int left, int right, int bottom, int top, int zNear, int zFar) {
			Delegates.glOrthox((int) left, (int) right, (int) bottom, (int) top, (int) zNear, (int) zFar);
		}


		/// <summary>[requires: v1.1 and 1.1]
		/// Set pixel storage modes
		/// </summary>
		/// <param name="pname">
		/// <para>
		/// Specifies the symbolic name of the parameter to be set. Six values affect the packing of pixel data into memory: GL_PACK_SWAP_BYTES, GL_PACK_LSB_FIRST, GL_PACK_ROW_LENGTH, GL_PACK_IMAGE_HEIGHT, GL_PACK_SKIP_PIXELS, GL_PACK_SKIP_ROWS, GL_PACK_SKIP_IMAGES, and GL_PACK_ALIGNMENT. Six more affect the unpacking of pixel data from memory: GL_UNPACK_SWAP_BYTES, GL_UNPACK_LSB_FIRST, GL_UNPACK_ROW_LENGTH, GL_UNPACK_IMAGE_HEIGHT, GL_UNPACK_SKIP_PIXELS, GL_UNPACK_SKIP_ROWS, GL_UNPACK_SKIP_IMAGES, and GL_UNPACK_ALIGNMENT.
		/// </para>
		/// </param>
		/// <param name="param">
		/// <para>
		/// Specifies the value that pname is set to.
		/// </para>
		/// </param>
		//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glPixelStorei")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
				void PixelStore(System.Graphics.ES11.All pname, Int32 param) {
			Delegates.glPixelStorei((System.Graphics.ES11.All) pname, (Int32) param);
		}


		/// <summary>[requires: v1.1 and 1.1]
		/// Specify point parameters
		/// </summary>
		/// <param name="pname">
		/// <para>
		/// Specifies a single-valued point parameter. GL_POINT_FADE_THRESHOLD_SIZE, and GL_POINT_SPRITE_COORD_ORIGIN are accepted.
		/// </para>
		/// </param>
		/// <param name="param">
		/// <para>
		/// Specifies the value that pname will be set to.
		/// </para>
		/// </param>
		//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glPointParameterf")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
				void PointParameter(System.Graphics.ES11.All pname, Single param) {
			Delegates.glPointParameterf((System.Graphics.ES11.All) pname, (Single) param);
		}


		/// <summary>[requires: v1.1 and 1.1]
		/// Specify point parameters
		/// </summary>
		/// <param name="pname">
		/// <para>
		/// Specifies a single-valued point parameter. GL_POINT_FADE_THRESHOLD_SIZE, and GL_POINT_SPRITE_COORD_ORIGIN are accepted.
		/// </para>
		/// </param>
		/// <param name="params">
		/// <para>
		/// Specifies the value that pname will be set to.
		/// </para>
		/// </param>
		//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glPointParameterfv")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
				void PointParameter(System.Graphics.ES11.All pname, Single[] @params) {
			unsafe
			{
				fixed (Single* @params_ptr = @params) {
					Delegates.glPointParameterfv((System.Graphics.ES11.All) pname, (Single*) @params_ptr);
				}
			}
		}


		/// <summary>[requires: v1.1 and 1.1]
		/// Specify point parameters
		/// </summary>
		/// <param name="pname">
		/// <para>
		/// Specifies a single-valued point parameter. GL_POINT_FADE_THRESHOLD_SIZE, and GL_POINT_SPRITE_COORD_ORIGIN are accepted.
		/// </para>
		/// </param>
		/// <param name="params">
		/// <para>
		/// Specifies the value that pname will be set to.
		/// </para>
		/// </param>
		[System.CLSCompliant(false)]
		//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glPointParameterfv")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
		unsafe void PointParameter(System.Graphics.ES11.All pname, Single* @params) {
			Delegates.glPointParameterfv((System.Graphics.ES11.All) pname, (Single*) @params);
		}

		/// <summary>[requires: v1.1 and 1.1]</summary>
		//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glPointParameterx")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
				void PointParameterx(System.Graphics.ES11.All pname, int param) {
			Delegates.glPointParameterx((System.Graphics.ES11.All) pname, (int) param);
		}

		/// <summary>[requires: v1.1 and 1.1]</summary>
		//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glPointParameterxv")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
				void PointParameterx(System.Graphics.ES11.All pname, int[] @params) {
			unsafe
			{
				fixed (int* @params_ptr = @params) {
					Delegates.glPointParameterxv((System.Graphics.ES11.All) pname, (int*) @params_ptr);
				}
			}
		}

		/// <summary>[requires: v1.1 and 1.1]</summary>
		[System.CLSCompliant(false)]
		//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glPointParameterxv")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
		unsafe void PointParameterx(System.Graphics.ES11.All pname, int* @params) {
			Delegates.glPointParameterxv((System.Graphics.ES11.All) pname, (int*) @params);
		}


		/// <summary>[requires: v1.1 and 1.1]
		/// Specify the diameter of rasterized points
		/// </summary>
		/// <param name="size">
		/// <para>
		/// Specifies the diameter of rasterized points. The initial value is 1.
		/// </para>
		/// </param>
		//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glPointSize")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
				void PointSize(Single size) {
			Delegates.glPointSize((Single) size);
		}

		/// <summary>[requires: v1.1 and 1.1]</summary>
		//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glPointSizex")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
				void PointSizex(int size) {
			Delegates.glPointSizex((int) size);
		}


		/// <summary>[requires: v1.1 and 1.1]
		/// Set the scale and units used to calculate depth values
		/// </summary>
		/// <param name="factor">
		/// <para>
		/// Specifies a scale factor that is used to create a variable depth offset for each polygon. The initial value is 0.
		/// </para>
		/// </param>
		/// <param name="units">
		/// <para>
		/// Is multiplied by an implementation-specific value to create a constant depth offset. The initial value is 0.
		/// </para>
		/// </param>
		//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glPolygonOffset")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
				void PolygonOffset(Single factor, Single units) {
			Delegates.glPolygonOffset((Single) factor, (Single) units);
		}

		/// <summary>[requires: v1.1 and 1.1]</summary>
		//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glPolygonOffsetx")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
				void PolygonOffsetx(int factor, int units) {
			Delegates.glPolygonOffsetx((int) factor, (int) units);
		}

		/// <summary>[requires: v1.1 and 1.1]</summary>
		//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glPopMatrix")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
				void PopMatrix() {
			Delegates.glPopMatrix();
		}


		/// <summary>[requires: v1.1 and 1.1]
		/// Push and pop the current matrix stack
		/// </summary>
		//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glPushMatrix")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
				void PushMatrix() {
			Delegates.glPushMatrix();
		}


		/// <summary>[requires: v1.1 and 1.1]
		/// Read a block of pixels from the frame buffer
		/// </summary>
		/// <param name="x">
		/// <para>
		/// Specify the window coordinates of the first pixel that is read from the frame buffer. This location is the lower left corner of a rectangular block of pixels.
		/// </para>
		/// </param>
		/// <param name="y">
		/// <para>
		/// Specify the window coordinates of the first pixel that is read from the frame buffer. This location is the lower left corner of a rectangular block of pixels.
		/// </para>
		/// </param>
		/// <param name="width">
		/// <para>
		/// Specify the dimensions of the pixel rectangle. width and height of one correspond to a single pixel.
		/// </para>
		/// </param>
		/// <param name="height">
		/// <para>
		/// Specify the dimensions of the pixel rectangle. width and height of one correspond to a single pixel.
		/// </para>
		/// </param>
		/// <param name="format">
		/// <para>
		/// Specifies the format of the pixel data. The following symbolic values are accepted: GL_STENCIL_INDEX, GL_DEPTH_COMPONENT, GL_DEPTH_STENCIL, GL_RED, GL_GREEN, GL_BLUE, GL_RGB, GL_BGR, GL_RGBA, and GL_BGRA.
		/// </para>
		/// </param>
		/// <param name="type">
		/// <para>
		/// Specifies the data type of the pixel data. Must be one of GL_UNSIGNED_BYTE, GL_BYTE, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_HALF_FLOAT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, GL_UNSIGNED_INT_2_10_10_10_REV, GL_UNSIGNED_INT_24_8, GL_UNSIGNED_INT_10F_11F_11F_REV, GL_UNSIGNED_INT_5_9_9_9_REV, or GL_FLOAT_32_UNSIGNED_INT_24_8_REV.
		/// </para>
		/// </param>
		/// <param name="pixels">
		/// <para>
		/// Returns the pixel data.
		/// </para>
		/// </param>
		//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glReadPixels")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
				void ReadPixels(Int32 x, Int32 y, Int32 width, Int32 height, System.Graphics.ES11.All format, System.Graphics.ES11.All type, IntPtr pixels) {
			Delegates.glReadPixels((Int32) x, (Int32) y, (Int32) width, (Int32) height, (System.Graphics.ES11.All) format, (System.Graphics.ES11.All) type, (IntPtr) pixels);
		}


		/// <summary>[requires: v1.1 and 1.1]
		/// Read a block of pixels from the frame buffer
		/// </summary>
		/// <param name="x">
		/// <para>
		/// Specify the window coordinates of the first pixel that is read from the frame buffer. This location is the lower left corner of a rectangular block of pixels.
		/// </para>
		/// </param>
		/// <param name="y">
		/// <para>
		/// Specify the window coordinates of the first pixel that is read from the frame buffer. This location is the lower left corner of a rectangular block of pixels.
		/// </para>
		/// </param>
		/// <param name="width">
		/// <para>
		/// Specify the dimensions of the pixel rectangle. width and height of one correspond to a single pixel.
		/// </para>
		/// </param>
		/// <param name="height">
		/// <para>
		/// Specify the dimensions of the pixel rectangle. width and height of one correspond to a single pixel.
		/// </para>
		/// </param>
		/// <param name="format">
		/// <para>
		/// Specifies the format of the pixel data. The following symbolic values are accepted: GL_STENCIL_INDEX, GL_DEPTH_COMPONENT, GL_DEPTH_STENCIL, GL_RED, GL_GREEN, GL_BLUE, GL_RGB, GL_BGR, GL_RGBA, and GL_BGRA.
		/// </para>
		/// </param>
		/// <param name="type">
		/// <para>
		/// Specifies the data type of the pixel data. Must be one of GL_UNSIGNED_BYTE, GL_BYTE, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_HALF_FLOAT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, GL_UNSIGNED_INT_2_10_10_10_REV, GL_UNSIGNED_INT_24_8, GL_UNSIGNED_INT_10F_11F_11F_REV, GL_UNSIGNED_INT_5_9_9_9_REV, or GL_FLOAT_32_UNSIGNED_INT_24_8_REV.
		/// </para>
		/// </param>
		/// <param name="pixels">
		/// <para>
		/// Returns the pixel data.
		/// </para>
		/// </param>
		//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glReadPixels")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
				void ReadPixels<T6>(Int32 x, Int32 y, Int32 width, Int32 height, System.Graphics.ES11.All format, System.Graphics.ES11.All type, [InAttribute, OutAttribute] T6[] pixels)
					where T6 : struct {
			GCHandle pixels_ptr = GCHandle.Alloc(pixels, GCHandleType.Pinned);
			try {
				Delegates.glReadPixels((Int32) x, (Int32) y, (Int32) width, (Int32) height, (System.Graphics.ES11.All) format, (System.Graphics.ES11.All) type, (IntPtr) pixels_ptr.AddrOfPinnedObject());
			} finally {
				pixels_ptr.Free();
			}
		}


		/// <summary>[requires: v1.1 and 1.1]
		/// Read a block of pixels from the frame buffer
		/// </summary>
		/// <param name="x">
		/// <para>
		/// Specify the window coordinates of the first pixel that is read from the frame buffer. This location is the lower left corner of a rectangular block of pixels.
		/// </para>
		/// </param>
		/// <param name="y">
		/// <para>
		/// Specify the window coordinates of the first pixel that is read from the frame buffer. This location is the lower left corner of a rectangular block of pixels.
		/// </para>
		/// </param>
		/// <param name="width">
		/// <para>
		/// Specify the dimensions of the pixel rectangle. width and height of one correspond to a single pixel.
		/// </para>
		/// </param>
		/// <param name="height">
		/// <para>
		/// Specify the dimensions of the pixel rectangle. width and height of one correspond to a single pixel.
		/// </para>
		/// </param>
		/// <param name="format">
		/// <para>
		/// Specifies the format of the pixel data. The following symbolic values are accepted: GL_STENCIL_INDEX, GL_DEPTH_COMPONENT, GL_DEPTH_STENCIL, GL_RED, GL_GREEN, GL_BLUE, GL_RGB, GL_BGR, GL_RGBA, and GL_BGRA.
		/// </para>
		/// </param>
		/// <param name="type">
		/// <para>
		/// Specifies the data type of the pixel data. Must be one of GL_UNSIGNED_BYTE, GL_BYTE, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_HALF_FLOAT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, GL_UNSIGNED_INT_2_10_10_10_REV, GL_UNSIGNED_INT_24_8, GL_UNSIGNED_INT_10F_11F_11F_REV, GL_UNSIGNED_INT_5_9_9_9_REV, or GL_FLOAT_32_UNSIGNED_INT_24_8_REV.
		/// </para>
		/// </param>
		/// <param name="pixels">
		/// <para>
		/// Returns the pixel data.
		/// </para>
		/// </param>
		//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glReadPixels")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
				void ReadPixels<T6>(Int32 x, Int32 y, Int32 width, Int32 height, System.Graphics.ES11.All format, System.Graphics.ES11.All type, [InAttribute, OutAttribute] T6[,] pixels)
					where T6 : struct {
			GCHandle pixels_ptr = GCHandle.Alloc(pixels, GCHandleType.Pinned);
			try {
				Delegates.glReadPixels((Int32) x, (Int32) y, (Int32) width, (Int32) height, (System.Graphics.ES11.All) format, (System.Graphics.ES11.All) type, (IntPtr) pixels_ptr.AddrOfPinnedObject());
			} finally {
				pixels_ptr.Free();
			}
		}


		/// <summary>[requires: v1.1 and 1.1]
		/// Read a block of pixels from the frame buffer
		/// </summary>
		/// <param name="x">
		/// <para>
		/// Specify the window coordinates of the first pixel that is read from the frame buffer. This location is the lower left corner of a rectangular block of pixels.
		/// </para>
		/// </param>
		/// <param name="y">
		/// <para>
		/// Specify the window coordinates of the first pixel that is read from the frame buffer. This location is the lower left corner of a rectangular block of pixels.
		/// </para>
		/// </param>
		/// <param name="width">
		/// <para>
		/// Specify the dimensions of the pixel rectangle. width and height of one correspond to a single pixel.
		/// </para>
		/// </param>
		/// <param name="height">
		/// <para>
		/// Specify the dimensions of the pixel rectangle. width and height of one correspond to a single pixel.
		/// </para>
		/// </param>
		/// <param name="format">
		/// <para>
		/// Specifies the format of the pixel data. The following symbolic values are accepted: GL_STENCIL_INDEX, GL_DEPTH_COMPONENT, GL_DEPTH_STENCIL, GL_RED, GL_GREEN, GL_BLUE, GL_RGB, GL_BGR, GL_RGBA, and GL_BGRA.
		/// </para>
		/// </param>
		/// <param name="type">
		/// <para>
		/// Specifies the data type of the pixel data. Must be one of GL_UNSIGNED_BYTE, GL_BYTE, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_HALF_FLOAT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, GL_UNSIGNED_INT_2_10_10_10_REV, GL_UNSIGNED_INT_24_8, GL_UNSIGNED_INT_10F_11F_11F_REV, GL_UNSIGNED_INT_5_9_9_9_REV, or GL_FLOAT_32_UNSIGNED_INT_24_8_REV.
		/// </para>
		/// </param>
		/// <param name="pixels">
		/// <para>
		/// Returns the pixel data.
		/// </para>
		/// </param>
		//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glReadPixels")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
				void ReadPixels<T6>(Int32 x, Int32 y, Int32 width, Int32 height, System.Graphics.ES11.All format, System.Graphics.ES11.All type, [InAttribute, OutAttribute] T6[,,] pixels)
					where T6 : struct {
			GCHandle pixels_ptr = GCHandle.Alloc(pixels, GCHandleType.Pinned);
			try {
				Delegates.glReadPixels((Int32) x, (Int32) y, (Int32) width, (Int32) height, (System.Graphics.ES11.All) format, (System.Graphics.ES11.All) type, (IntPtr) pixels_ptr.AddrOfPinnedObject());
			} finally {
				pixels_ptr.Free();
			}
		}


		/// <summary>[requires: v1.1 and 1.1]
		/// Read a block of pixels from the frame buffer
		/// </summary>
		/// <param name="x">
		/// <para>
		/// Specify the window coordinates of the first pixel that is read from the frame buffer. This location is the lower left corner of a rectangular block of pixels.
		/// </para>
		/// </param>
		/// <param name="y">
		/// <para>
		/// Specify the window coordinates of the first pixel that is read from the frame buffer. This location is the lower left corner of a rectangular block of pixels.
		/// </para>
		/// </param>
		/// <param name="width">
		/// <para>
		/// Specify the dimensions of the pixel rectangle. width and height of one correspond to a single pixel.
		/// </para>
		/// </param>
		/// <param name="height">
		/// <para>
		/// Specify the dimensions of the pixel rectangle. width and height of one correspond to a single pixel.
		/// </para>
		/// </param>
		/// <param name="format">
		/// <para>
		/// Specifies the format of the pixel data. The following symbolic values are accepted: GL_STENCIL_INDEX, GL_DEPTH_COMPONENT, GL_DEPTH_STENCIL, GL_RED, GL_GREEN, GL_BLUE, GL_RGB, GL_BGR, GL_RGBA, and GL_BGRA.
		/// </para>
		/// </param>
		/// <param name="type">
		/// <para>
		/// Specifies the data type of the pixel data. Must be one of GL_UNSIGNED_BYTE, GL_BYTE, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_HALF_FLOAT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, GL_UNSIGNED_INT_2_10_10_10_REV, GL_UNSIGNED_INT_24_8, GL_UNSIGNED_INT_10F_11F_11F_REV, GL_UNSIGNED_INT_5_9_9_9_REV, or GL_FLOAT_32_UNSIGNED_INT_24_8_REV.
		/// </para>
		/// </param>
		/// <param name="pixels">
		/// <para>
		/// Returns the pixel data.
		/// </para>
		/// </param>
		//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glReadPixels")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
				void ReadPixels<T6>(Int32 x, Int32 y, Int32 width, Int32 height, System.Graphics.ES11.All format, System.Graphics.ES11.All type, [InAttribute, OutAttribute] ref T6 pixels)
					where T6 : struct {
			GCHandle pixels_ptr = GCHandle.Alloc(pixels, GCHandleType.Pinned);
			try {
				Delegates.glReadPixels((Int32) x, (Int32) y, (Int32) width, (Int32) height, (System.Graphics.ES11.All) format, (System.Graphics.ES11.All) type, (IntPtr) pixels_ptr.AddrOfPinnedObject());
				pixels = (T6) pixels_ptr.Target;
			} finally {
				pixels_ptr.Free();
			}
		}


		/// <summary>[requires: v1.1 and 1.1]
		/// Multiply the current matrix by a rotation matrix
		/// </summary>
		//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glRotatef")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
				void Rotate(Single angle, Single x, Single y, Single z) {
			Delegates.glRotatef((Single) angle, (Single) x, (Single) y, (Single) z);
		}

		/// <summary>[requires: v1.1 and 1.1]</summary>
		//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glRotatex")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
				void Rotatex(int angle, int x, int y, int z) {
			Delegates.glRotatex((int) angle, (int) x, (int) y, (int) z);
		}


		/// <summary>[requires: v1.1 and 1.1]
		/// Specify multisample coverage parameters
		/// </summary>
		/// <param name="value">
		/// <para>
		/// Specify a single floating-point sample coverage value. The value is clamped to the range [0 ,1]. The initial value is 1.0.
		/// </para>
		/// </param>
		/// <param name="invert">
		/// <para>
		/// Specify a single boolean value representing if the coverage masks should be inverted. GL_TRUE and GL_FALSE are accepted. The initial value is GL_FALSE.
		/// </para>
		/// </param>
		//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glSampleCoverage")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
				void SampleCoverage(Single value, bool invert) {
			Delegates.glSampleCoverage((Single) value, (bool) invert);
		}

		/// <summary>[requires: v1.1 and 1.1]</summary>
		//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glSampleCoveragex")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
				void SampleCoveragex(int value, bool invert) {
			Delegates.glSampleCoveragex((int) value, (bool) invert);
		}


		/// <summary>[requires: v1.1 and 1.1]
		/// Multiply the current matrix by a general scaling matrix
		/// </summary>
		//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glScalef")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
				void Scale(Single x, Single y, Single z) {
			Delegates.glScalef((Single) x, (Single) y, (Single) z);
		}

		/// <summary>[requires: v1.1 and 1.1]</summary>
		//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glScalex")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
				void Scalex(int x, int y, int z) {
			Delegates.glScalex((int) x, (int) y, (int) z);
		}


		/// <summary>[requires: v1.1 and 1.1]
		/// Define the scissor box
		/// </summary>
		/// <param name="x">
		/// <para>
		/// Specify the lower left corner of the scissor box. Initially (0, 0).
		/// </para>
		/// </param>
		/// <param name="y">
		/// <para>
		/// Specify the lower left corner of the scissor box. Initially (0, 0).
		/// </para>
		/// </param>
		/// <param name="width">
		/// <para>
		/// Specify the width and height of the scissor box. When a GL context is first attached to a window, width and height are set to the dimensions of that window.
		/// </para>
		/// </param>
		/// <param name="height">
		/// <para>
		/// Specify the width and height of the scissor box. When a GL context is first attached to a window, width and height are set to the dimensions of that window.
		/// </para>
		/// </param>
		//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glScissor")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
				void Scissor(Int32 x, Int32 y, Int32 width, Int32 height) {
			Delegates.glScissor((Int32) x, (Int32) y, (Int32) width, (Int32) height);
		}


		/// <summary>[requires: v1.1 and 1.1]
		/// Select flat or smooth shading
		/// </summary>
		/// <param name="mode">
		/// <para>
		/// Specifies a symbolic value representing a shading technique. Accepted values are GL_FLAT and GL_SMOOTH. The initial value is GL_SMOOTH.
		/// </para>
		/// </param>
		//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glShadeModel")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
				void ShadeModel(System.Graphics.ES11.All mode) {
			Delegates.glShadeModel((System.Graphics.ES11.All) mode);
		}


		/// <summary>[requires: v1.1 and 1.1]
		/// Set front and back function and reference value for stencil testing
		/// </summary>
		/// <param name="func">
		/// <para>
		/// Specifies the test function. Eight symbolic constants are valid: GL_NEVER, GL_LESS, GL_LEQUAL, GL_GREATER, GL_GEQUAL, GL_EQUAL, GL_NOTEQUAL, and GL_ALWAYS. The initial value is GL_ALWAYS.
		/// </para>
		/// </param>
		/// <param name="ref">
		/// <para>
		/// Specifies the reference value for the stencil test. ref is clamped to the range [0, 2 sup n - 1], where is the number of bitplanes in the stencil buffer. The initial value is 0.
		/// </para>
		/// </param>
		/// <param name="mask">
		/// <para>
		/// Specifies a mask that is ANDed with both the reference value and the stored stencil value when the test is done. The initial value is all 1's.
		/// </para>
		/// </param>
		//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glStencilFunc")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
				void StencilFunc(System.Graphics.ES11.All func, Int32 @ref, Int32 mask) {
			Delegates.glStencilFunc((System.Graphics.ES11.All) func, (Int32) @ref, (UInt32) mask);
		}


		/// <summary>[requires: v1.1 and 1.1]
		/// Set front and back function and reference value for stencil testing
		/// </summary>
		/// <param name="func">
		/// <para>
		/// Specifies the test function. Eight symbolic constants are valid: GL_NEVER, GL_LESS, GL_LEQUAL, GL_GREATER, GL_GEQUAL, GL_EQUAL, GL_NOTEQUAL, and GL_ALWAYS. The initial value is GL_ALWAYS.
		/// </para>
		/// </param>
		/// <param name="ref">
		/// <para>
		/// Specifies the reference value for the stencil test. ref is clamped to the range [0, 2 sup n - 1], where is the number of bitplanes in the stencil buffer. The initial value is 0.
		/// </para>
		/// </param>
		/// <param name="mask">
		/// <para>
		/// Specifies a mask that is ANDed with both the reference value and the stored stencil value when the test is done. The initial value is all 1's.
		/// </para>
		/// </param>
		[System.CLSCompliant(false)]
		//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glStencilFunc")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
		void StencilFunc(System.Graphics.ES11.All func, Int32 @ref, UInt32 mask) {
			Delegates.glStencilFunc((System.Graphics.ES11.All) func, (Int32) @ref, (UInt32) mask);
		}


		/// <summary>[requires: v1.1 and 1.1]
		/// Control the front and back writing of individual bits in the stencil planes
		/// </summary>
		/// <param name="mask">
		/// <para>
		/// Specifies a bit mask to enable and disable writing of individual bits in the stencil planes. Initially, the mask is all 1's.
		/// </para>
		/// </param>
		//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glStencilMask")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
				void StencilMask(Int32 mask) {
			Delegates.glStencilMask((UInt32) mask);
		}


		/// <summary>[requires: v1.1 and 1.1]
		/// Control the front and back writing of individual bits in the stencil planes
		/// </summary>
		/// <param name="mask">
		/// <para>
		/// Specifies a bit mask to enable and disable writing of individual bits in the stencil planes. Initially, the mask is all 1's.
		/// </para>
		/// </param>
		[System.CLSCompliant(false)]
		//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glStencilMask")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
		void StencilMask(UInt32 mask) {
			Delegates.glStencilMask((UInt32) mask);
		}


		/// <summary>[requires: v1.1 and 1.1]
		/// Set front and back stencil test actions
		/// </summary>
		/// <param name="sfail">
		/// <para>
		/// Specifies the action to take when the stencil test fails. Eight symbolic constants are accepted: GL_KEEP, GL_ZERO, GL_REPLACE, GL_INCR, GL_INCR_WRAP, GL_DECR, GL_DECR_WRAP, and GL_INVERT. The initial value is GL_KEEP.
		/// </para>
		/// </param>
		/// <param name="dpfail">
		/// <para>
		/// Specifies the stencil action when the stencil test passes, but the depth test fails. dpfail accepts the same symbolic constants as sfail. The initial value is GL_KEEP.
		/// </para>
		/// </param>
		/// <param name="dppass">
		/// <para>
		/// Specifies the stencil action when both the stencil test and the depth test pass, or when the stencil test passes and either there is no depth buffer or depth testing is not enabled. dppass accepts the same symbolic constants as sfail. The initial value is GL_KEEP.
		/// </para>
		/// </param>
		//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glStencilOp")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
				void StencilOp(System.Graphics.ES11.All sfail, System.Graphics.ES11.All dpfail, System.Graphics.ES11.All dppass) {
			Delegates.glStencilOp((System.Graphics.ES11.All) sfail, (System.Graphics.ES11.All) dpfail, (System.Graphics.ES11.All) dppass);
		}


		/// <summary>[requires: v1.1 and 1.1]
		/// Define an array of texture coordinates
		/// </summary>
		/// <param name="size">
		/// <para>
		/// Specifies the number of coordinates per array element. Must be 1, 2, 3, or 4. The initial value is 4.
		/// </para>
		/// </param>
		/// <param name="type">
		/// <para>
		/// Specifies the data type of each texture coordinate. Symbolic constants GL_SHORT, GL_INT, GL_FLOAT, or GL_DOUBLE are accepted. The initial value is GL_FLOAT.
		/// </para>
		/// </param>
		/// <param name="stride">
		/// <para>
		/// Specifies the byte offset between consecutive texture coordinate sets. If stride is 0, the array elements are understood to be tightly packed. The initial value is 0.
		/// </para>
		/// </param>
		/// <param name="pointer">
		/// <para>
		/// Specifies a pointer to the first coordinate of the first texture coordinate set in the array. The initial value is 0.
		/// </para>
		/// </param>
		//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glTexCoordPointer")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
				void TexCoordPointer(Int32 size, System.Graphics.ES11.All type, Int32 stride, IntPtr pointer) {
			Delegates.glTexCoordPointer((Int32) size, (System.Graphics.ES11.All) type, (Int32) stride, (IntPtr) pointer);
		}


		/// <summary>[requires: v1.1 and 1.1]
		/// Define an array of texture coordinates
		/// </summary>
		/// <param name="size">
		/// <para>
		/// Specifies the number of coordinates per array element. Must be 1, 2, 3, or 4. The initial value is 4.
		/// </para>
		/// </param>
		/// <param name="type">
		/// <para>
		/// Specifies the data type of each texture coordinate. Symbolic constants GL_SHORT, GL_INT, GL_FLOAT, or GL_DOUBLE are accepted. The initial value is GL_FLOAT.
		/// </para>
		/// </param>
		/// <param name="stride">
		/// <para>
		/// Specifies the byte offset between consecutive texture coordinate sets. If stride is 0, the array elements are understood to be tightly packed. The initial value is 0.
		/// </para>
		/// </param>
		/// <param name="pointer">
		/// <para>
		/// Specifies a pointer to the first coordinate of the first texture coordinate set in the array. The initial value is 0.
		/// </para>
		/// </param>
		//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glTexCoordPointer")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
				void TexCoordPointer<T3>(Int32 size, System.Graphics.ES11.All type, Int32 stride, [InAttribute, OutAttribute] T3[] pointer)
					where T3 : struct {
			GCHandle pointer_ptr = GCHandle.Alloc(pointer, GCHandleType.Pinned);
			try {
				Delegates.glTexCoordPointer((Int32) size, (System.Graphics.ES11.All) type, (Int32) stride, (IntPtr) pointer_ptr.AddrOfPinnedObject());
			} finally {
				pointer_ptr.Free();
			}
		}


		/// <summary>[requires: v1.1 and 1.1]
		/// Define an array of texture coordinates
		/// </summary>
		/// <param name="size">
		/// <para>
		/// Specifies the number of coordinates per array element. Must be 1, 2, 3, or 4. The initial value is 4.
		/// </para>
		/// </param>
		/// <param name="type">
		/// <para>
		/// Specifies the data type of each texture coordinate. Symbolic constants GL_SHORT, GL_INT, GL_FLOAT, or GL_DOUBLE are accepted. The initial value is GL_FLOAT.
		/// </para>
		/// </param>
		/// <param name="stride">
		/// <para>
		/// Specifies the byte offset between consecutive texture coordinate sets. If stride is 0, the array elements are understood to be tightly packed. The initial value is 0.
		/// </para>
		/// </param>
		/// <param name="pointer">
		/// <para>
		/// Specifies a pointer to the first coordinate of the first texture coordinate set in the array. The initial value is 0.
		/// </para>
		/// </param>
		//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glTexCoordPointer")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
				void TexCoordPointer<T3>(Int32 size, System.Graphics.ES11.All type, Int32 stride, [InAttribute, OutAttribute] T3[,] pointer)
					where T3 : struct {
			GCHandle pointer_ptr = GCHandle.Alloc(pointer, GCHandleType.Pinned);
			try {
				Delegates.glTexCoordPointer((Int32) size, (System.Graphics.ES11.All) type, (Int32) stride, (IntPtr) pointer_ptr.AddrOfPinnedObject());
			} finally {
				pointer_ptr.Free();
			}
		}


		/// <summary>[requires: v1.1 and 1.1]
		/// Define an array of texture coordinates
		/// </summary>
		/// <param name="size">
		/// <para>
		/// Specifies the number of coordinates per array element. Must be 1, 2, 3, or 4. The initial value is 4.
		/// </para>
		/// </param>
		/// <param name="type">
		/// <para>
		/// Specifies the data type of each texture coordinate. Symbolic constants GL_SHORT, GL_INT, GL_FLOAT, or GL_DOUBLE are accepted. The initial value is GL_FLOAT.
		/// </para>
		/// </param>
		/// <param name="stride">
		/// <para>
		/// Specifies the byte offset between consecutive texture coordinate sets. If stride is 0, the array elements are understood to be tightly packed. The initial value is 0.
		/// </para>
		/// </param>
		/// <param name="pointer">
		/// <para>
		/// Specifies a pointer to the first coordinate of the first texture coordinate set in the array. The initial value is 0.
		/// </para>
		/// </param>
		//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glTexCoordPointer")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
				void TexCoordPointer<T3>(Int32 size, System.Graphics.ES11.All type, Int32 stride, [InAttribute, OutAttribute] T3[,,] pointer)
					where T3 : struct {
			GCHandle pointer_ptr = GCHandle.Alloc(pointer, GCHandleType.Pinned);
			try {
				Delegates.glTexCoordPointer((Int32) size, (System.Graphics.ES11.All) type, (Int32) stride, (IntPtr) pointer_ptr.AddrOfPinnedObject());
			} finally {
				pointer_ptr.Free();
			}
		}


		/// <summary>[requires: v1.1 and 1.1]
		/// Define an array of texture coordinates
		/// </summary>
		/// <param name="size">
		/// <para>
		/// Specifies the number of coordinates per array element. Must be 1, 2, 3, or 4. The initial value is 4.
		/// </para>
		/// </param>
		/// <param name="type">
		/// <para>
		/// Specifies the data type of each texture coordinate. Symbolic constants GL_SHORT, GL_INT, GL_FLOAT, or GL_DOUBLE are accepted. The initial value is GL_FLOAT.
		/// </para>
		/// </param>
		/// <param name="stride">
		/// <para>
		/// Specifies the byte offset between consecutive texture coordinate sets. If stride is 0, the array elements are understood to be tightly packed. The initial value is 0.
		/// </para>
		/// </param>
		/// <param name="pointer">
		/// <para>
		/// Specifies a pointer to the first coordinate of the first texture coordinate set in the array. The initial value is 0.
		/// </para>
		/// </param>
		//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glTexCoordPointer")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
				void TexCoordPointer<T3>(Int32 size, System.Graphics.ES11.All type, Int32 stride, [InAttribute, OutAttribute] ref T3 pointer)
					where T3 : struct {
			GCHandle pointer_ptr = GCHandle.Alloc(pointer, GCHandleType.Pinned);
			try {
				Delegates.glTexCoordPointer((Int32) size, (System.Graphics.ES11.All) type, (Int32) stride, (IntPtr) pointer_ptr.AddrOfPinnedObject());
				pointer = (T3) pointer_ptr.Target;
			} finally {
				pointer_ptr.Free();
			}
		}


		/// <summary>[requires: v1.1 and 1.1]
		/// Set texture environment parameters
		/// </summary>
		/// <param name="target">
		/// <para>
		/// Specifies a texture environment. May be GL_TEXTURE_ENV, GL_TEXTURE_FILTER_CONTROL or GL_POINT_SPRITE.
		/// </para>
		/// </param>
		/// <param name="pname">
		/// <para>
		/// Specifies the symbolic name of a single-valued texture environment parameter. May be either GL_TEXTURE_ENV_MODE, GL_TEXTURE_LOD_BIAS, GL_COMBINE_RGB, GL_COMBINE_ALPHA, GL_SRC0_RGB, GL_SRC1_RGB, GL_SRC2_RGB, GL_SRC0_ALPHA, GL_SRC1_ALPHA, GL_SRC2_ALPHA, GL_OPERAND0_RGB, GL_OPERAND1_RGB, GL_OPERAND2_RGB, GL_OPERAND0_ALPHA, GL_OPERAND1_ALPHA, GL_OPERAND2_ALPHA, GL_RGB_SCALE, GL_ALPHA_SCALE, or GL_COORD_REPLACE.
		/// </para>
		/// </param>
		/// <param name="param">
		/// <para>
		/// Specifies a single symbolic constant, one of GL_ADD, GL_ADD_SIGNED, GL_INTERPOLATE, GL_MODULATE, GL_DECAL, GL_BLEND, GL_REPLACE, GL_SUBTRACT, GL_COMBINE, GL_TEXTURE, GL_CONSTANT, GL_PRIMARY_COLOR, GL_PREVIOUS, GL_SRC_COLOR, GL_ONE_MINUS_SRC_COLOR, GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA, a single boolean value for the point sprite texture coordinate replacement, a single floating-point value for the texture level-of-detail bias, or 1.0, 2.0, or 4.0 when specifying the GL_RGB_SCALE or GL_ALPHA_SCALE.
		/// </para>
		/// </param>
		//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glTexEnvf")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
				void TexEnv(System.Graphics.ES11.All target, System.Graphics.ES11.All pname, Single param) {
			Delegates.glTexEnvf((System.Graphics.ES11.All) target, (System.Graphics.ES11.All) pname, (Single) param);
		}


		/// <summary>[requires: v1.1 and 1.1]
		/// Set texture environment parameters
		/// </summary>
		/// <param name="target">
		/// <para>
		/// Specifies a texture environment. May be GL_TEXTURE_ENV, GL_TEXTURE_FILTER_CONTROL or GL_POINT_SPRITE.
		/// </para>
		/// </param>
		/// <param name="pname">
		/// <para>
		/// Specifies the symbolic name of a single-valued texture environment parameter. May be either GL_TEXTURE_ENV_MODE, GL_TEXTURE_LOD_BIAS, GL_COMBINE_RGB, GL_COMBINE_ALPHA, GL_SRC0_RGB, GL_SRC1_RGB, GL_SRC2_RGB, GL_SRC0_ALPHA, GL_SRC1_ALPHA, GL_SRC2_ALPHA, GL_OPERAND0_RGB, GL_OPERAND1_RGB, GL_OPERAND2_RGB, GL_OPERAND0_ALPHA, GL_OPERAND1_ALPHA, GL_OPERAND2_ALPHA, GL_RGB_SCALE, GL_ALPHA_SCALE, or GL_COORD_REPLACE.
		/// </para>
		/// </param>
		/// <param name="params">
		/// <para>
		/// Specifies a single symbolic constant, one of GL_ADD, GL_ADD_SIGNED, GL_INTERPOLATE, GL_MODULATE, GL_DECAL, GL_BLEND, GL_REPLACE, GL_SUBTRACT, GL_COMBINE, GL_TEXTURE, GL_CONSTANT, GL_PRIMARY_COLOR, GL_PREVIOUS, GL_SRC_COLOR, GL_ONE_MINUS_SRC_COLOR, GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA, a single boolean value for the point sprite texture coordinate replacement, a single floating-point value for the texture level-of-detail bias, or 1.0, 2.0, or 4.0 when specifying the GL_RGB_SCALE or GL_ALPHA_SCALE.
		/// </para>
		/// </param>
		//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glTexEnvfv")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
				void TexEnv(System.Graphics.ES11.All target, System.Graphics.ES11.All pname, Single[] @params) {
			unsafe
			{
				fixed (Single* @params_ptr = @params) {
					Delegates.glTexEnvfv((System.Graphics.ES11.All) target, (System.Graphics.ES11.All) pname, (Single*) @params_ptr);
				}
			}
		}


		/// <summary>[requires: v1.1 and 1.1]
		/// Set texture environment parameters
		/// </summary>
		/// <param name="target">
		/// <para>
		/// Specifies a texture environment. May be GL_TEXTURE_ENV, GL_TEXTURE_FILTER_CONTROL or GL_POINT_SPRITE.
		/// </para>
		/// </param>
		/// <param name="pname">
		/// <para>
		/// Specifies the symbolic name of a single-valued texture environment parameter. May be either GL_TEXTURE_ENV_MODE, GL_TEXTURE_LOD_BIAS, GL_COMBINE_RGB, GL_COMBINE_ALPHA, GL_SRC0_RGB, GL_SRC1_RGB, GL_SRC2_RGB, GL_SRC0_ALPHA, GL_SRC1_ALPHA, GL_SRC2_ALPHA, GL_OPERAND0_RGB, GL_OPERAND1_RGB, GL_OPERAND2_RGB, GL_OPERAND0_ALPHA, GL_OPERAND1_ALPHA, GL_OPERAND2_ALPHA, GL_RGB_SCALE, GL_ALPHA_SCALE, or GL_COORD_REPLACE.
		/// </para>
		/// </param>
		/// <param name="params">
		/// <para>
		/// Specifies a single symbolic constant, one of GL_ADD, GL_ADD_SIGNED, GL_INTERPOLATE, GL_MODULATE, GL_DECAL, GL_BLEND, GL_REPLACE, GL_SUBTRACT, GL_COMBINE, GL_TEXTURE, GL_CONSTANT, GL_PRIMARY_COLOR, GL_PREVIOUS, GL_SRC_COLOR, GL_ONE_MINUS_SRC_COLOR, GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA, a single boolean value for the point sprite texture coordinate replacement, a single floating-point value for the texture level-of-detail bias, or 1.0, 2.0, or 4.0 when specifying the GL_RGB_SCALE or GL_ALPHA_SCALE.
		/// </para>
		/// </param>
		[System.CLSCompliant(false)]
		//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glTexEnvfv")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
		unsafe void TexEnv(System.Graphics.ES11.All target, System.Graphics.ES11.All pname, Single* @params) {
			Delegates.glTexEnvfv((System.Graphics.ES11.All) target, (System.Graphics.ES11.All) pname, (Single*) @params);
		}


		/// <summary>[requires: v1.1 and 1.1]
		/// Set texture environment parameters
		/// </summary>
		/// <param name="target">
		/// <para>
		/// Specifies a texture environment. May be GL_TEXTURE_ENV, GL_TEXTURE_FILTER_CONTROL or GL_POINT_SPRITE.
		/// </para>
		/// </param>
		/// <param name="pname">
		/// <para>
		/// Specifies the symbolic name of a single-valued texture environment parameter. May be either GL_TEXTURE_ENV_MODE, GL_TEXTURE_LOD_BIAS, GL_COMBINE_RGB, GL_COMBINE_ALPHA, GL_SRC0_RGB, GL_SRC1_RGB, GL_SRC2_RGB, GL_SRC0_ALPHA, GL_SRC1_ALPHA, GL_SRC2_ALPHA, GL_OPERAND0_RGB, GL_OPERAND1_RGB, GL_OPERAND2_RGB, GL_OPERAND0_ALPHA, GL_OPERAND1_ALPHA, GL_OPERAND2_ALPHA, GL_RGB_SCALE, GL_ALPHA_SCALE, or GL_COORD_REPLACE.
		/// </para>
		/// </param>
		/// <param name="param">
		/// <para>
		/// Specifies a single symbolic constant, one of GL_ADD, GL_ADD_SIGNED, GL_INTERPOLATE, GL_MODULATE, GL_DECAL, GL_BLEND, GL_REPLACE, GL_SUBTRACT, GL_COMBINE, GL_TEXTURE, GL_CONSTANT, GL_PRIMARY_COLOR, GL_PREVIOUS, GL_SRC_COLOR, GL_ONE_MINUS_SRC_COLOR, GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA, a single boolean value for the point sprite texture coordinate replacement, a single floating-point value for the texture level-of-detail bias, or 1.0, 2.0, or 4.0 when specifying the GL_RGB_SCALE or GL_ALPHA_SCALE.
		/// </para>
		/// </param>
		//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glTexEnvi")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
				void TexEnv(System.Graphics.ES11.All target, System.Graphics.ES11.All pname, Int32 param) {
			Delegates.glTexEnvi((System.Graphics.ES11.All) target, (System.Graphics.ES11.All) pname, (Int32) param);
		}


		/// <summary>[requires: v1.1 and 1.1]
		/// Set texture environment parameters
		/// </summary>
		/// <param name="target">
		/// <para>
		/// Specifies a texture environment. May be GL_TEXTURE_ENV, GL_TEXTURE_FILTER_CONTROL or GL_POINT_SPRITE.
		/// </para>
		/// </param>
		/// <param name="pname">
		/// <para>
		/// Specifies the symbolic name of a single-valued texture environment parameter. May be either GL_TEXTURE_ENV_MODE, GL_TEXTURE_LOD_BIAS, GL_COMBINE_RGB, GL_COMBINE_ALPHA, GL_SRC0_RGB, GL_SRC1_RGB, GL_SRC2_RGB, GL_SRC0_ALPHA, GL_SRC1_ALPHA, GL_SRC2_ALPHA, GL_OPERAND0_RGB, GL_OPERAND1_RGB, GL_OPERAND2_RGB, GL_OPERAND0_ALPHA, GL_OPERAND1_ALPHA, GL_OPERAND2_ALPHA, GL_RGB_SCALE, GL_ALPHA_SCALE, or GL_COORD_REPLACE.
		/// </para>
		/// </param>
		/// <param name="params">
		/// <para>
		/// Specifies a single symbolic constant, one of GL_ADD, GL_ADD_SIGNED, GL_INTERPOLATE, GL_MODULATE, GL_DECAL, GL_BLEND, GL_REPLACE, GL_SUBTRACT, GL_COMBINE, GL_TEXTURE, GL_CONSTANT, GL_PRIMARY_COLOR, GL_PREVIOUS, GL_SRC_COLOR, GL_ONE_MINUS_SRC_COLOR, GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA, a single boolean value for the point sprite texture coordinate replacement, a single floating-point value for the texture level-of-detail bias, or 1.0, 2.0, or 4.0 when specifying the GL_RGB_SCALE or GL_ALPHA_SCALE.
		/// </para>
		/// </param>
		//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glTexEnviv")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
				void TexEnv(System.Graphics.ES11.All target, System.Graphics.ES11.All pname, Int32[] @params) {
			unsafe
			{
				fixed (Int32* @params_ptr = @params) {
					Delegates.glTexEnviv((System.Graphics.ES11.All) target, (System.Graphics.ES11.All) pname, (Int32*) @params_ptr);
				}
			}
		}


		/// <summary>[requires: v1.1 and 1.1]
		/// Set texture environment parameters
		/// </summary>
		/// <param name="target">
		/// <para>
		/// Specifies a texture environment. May be GL_TEXTURE_ENV, GL_TEXTURE_FILTER_CONTROL or GL_POINT_SPRITE.
		/// </para>
		/// </param>
		/// <param name="pname">
		/// <para>
		/// Specifies the symbolic name of a single-valued texture environment parameter. May be either GL_TEXTURE_ENV_MODE, GL_TEXTURE_LOD_BIAS, GL_COMBINE_RGB, GL_COMBINE_ALPHA, GL_SRC0_RGB, GL_SRC1_RGB, GL_SRC2_RGB, GL_SRC0_ALPHA, GL_SRC1_ALPHA, GL_SRC2_ALPHA, GL_OPERAND0_RGB, GL_OPERAND1_RGB, GL_OPERAND2_RGB, GL_OPERAND0_ALPHA, GL_OPERAND1_ALPHA, GL_OPERAND2_ALPHA, GL_RGB_SCALE, GL_ALPHA_SCALE, or GL_COORD_REPLACE.
		/// </para>
		/// </param>
		/// <param name="params">
		/// <para>
		/// Specifies a single symbolic constant, one of GL_ADD, GL_ADD_SIGNED, GL_INTERPOLATE, GL_MODULATE, GL_DECAL, GL_BLEND, GL_REPLACE, GL_SUBTRACT, GL_COMBINE, GL_TEXTURE, GL_CONSTANT, GL_PRIMARY_COLOR, GL_PREVIOUS, GL_SRC_COLOR, GL_ONE_MINUS_SRC_COLOR, GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA, a single boolean value for the point sprite texture coordinate replacement, a single floating-point value for the texture level-of-detail bias, or 1.0, 2.0, or 4.0 when specifying the GL_RGB_SCALE or GL_ALPHA_SCALE.
		/// </para>
		/// </param>
		[System.CLSCompliant(false)]
		//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glTexEnviv")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
		unsafe void TexEnv(System.Graphics.ES11.All target, System.Graphics.ES11.All pname, Int32* @params) {
			Delegates.glTexEnviv((System.Graphics.ES11.All) target, (System.Graphics.ES11.All) pname, (Int32*) @params);
		}

		/// <summary>[requires: v1.1 and 1.1]</summary>
		//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glTexEnvx")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
				void TexEnvx(System.Graphics.ES11.All target, System.Graphics.ES11.All pname, int param) {
			Delegates.glTexEnvx((System.Graphics.ES11.All) target, (System.Graphics.ES11.All) pname, (int) param);
		}

		/// <summary>[requires: v1.1 and 1.1]</summary>
		//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glTexEnvxv")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
				void TexEnvx(System.Graphics.ES11.All target, System.Graphics.ES11.All pname, int[] @params) {
			unsafe
			{
				fixed (int* @params_ptr = @params) {
					Delegates.glTexEnvxv((System.Graphics.ES11.All) target, (System.Graphics.ES11.All) pname, (int*) @params_ptr);
				}
			}
		}

		/// <summary>[requires: v1.1 and 1.1]</summary>
		[System.CLSCompliant(false)]
		//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glTexEnvxv")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
		unsafe void TexEnvx(System.Graphics.ES11.All target, System.Graphics.ES11.All pname, int* @params) {
			Delegates.glTexEnvxv((System.Graphics.ES11.All) target, (System.Graphics.ES11.All) pname, (int*) @params);
		}


		/// <summary>[requires: v1.1 and 1.1]
		/// Specify a two-dimensional texture image
		/// </summary>
		/// <param name="target">
		/// <para>
		/// Specifies the target texture. Must be GL_TEXTURE_2D, GL_PROXY_TEXTURE_2D, GL_TEXTURE_1D_ARRAY, GL_PROXY_TEXTURE_1D_ARRAY, GL_TEXTURE_RECTANGLE, GL_PROXY_TEXTURE_RECTANGLE, GL_TEXTURE_CUBE_MAP_POSITIVE_X, GL_TEXTURE_CUBE_MAP_NEGATIVE_X, GL_TEXTURE_CUBE_MAP_POSITIVE_Y, GL_TEXTURE_CUBE_MAP_NEGATIVE_Y, GL_TEXTURE_CUBE_MAP_POSITIVE_Z, GL_TEXTURE_CUBE_MAP_NEGATIVE_Z, or GL_PROXY_TEXTURE_CUBE_MAP.
		/// </para>
		/// </param>
		/// <param name="level">
		/// <para>
		/// Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image. If target is GL_TEXTURE_RECTANGLE or GL_PROXY_TEXTURE_RECTANGLE, level must be 0.
		/// </para>
		/// </param>
		/// <param name="internalFormat">
		/// <para>
		/// Specifies the number of color components in the texture. Must be one of the following symbolic constants: GL_COMPRESSED_RED, GL_COMPRESSED_RG, GL_COMPRESSED_RGB, GL_COMPRESSED_RGBA, GL_COMPRESSED_SRGB, GL_COMPRESSED_SRGB_ALPHA, GL_DEPTH_COMPONENT, GL_DEPTH_COMPONENT16, GL_DEPTH_COMPONENT24, GL_DEPTH_COMPONENT32, GL_R3_G3_B2, GL_RED, GL_RG, GL_RGB, GL_RGB4, GL_RGB5, GL_RGB8, GL_RGB10, GL_RGB12, GL_RGB16, GL_RGBA, GL_RGBA2, GL_RGBA4, GL_RGB5_A1, GL_RGBA8, GL_RGB10_A2, GL_RGBA12, GL_RGBA16, GL_SRGB, GL_SRGB8, GL_SRGB_ALPHA, or GL_SRGB8_ALPHA8.
		/// </para>
		/// </param>
		/// <param name="width">
		/// <para>
		/// Specifies the width of the texture image. All implementations support texture images that are at least 1024 texels wide.
		/// </para>
		/// </param>
		/// <param name="height">
		/// <para>
		/// Specifies the height of the texture image, or the number of layers in a texture array, in the case of the GL_TEXTURE_1D_ARRAY and GL_PROXY_TEXTURE_1D_ARRAY targets. All implementations support 2D texture images that are at least 1024 texels high, and texture arrays that are at least 256 layers deep.
		/// </para>
		/// </param>
		/// <param name="border">
		/// <para>
		/// This value must be 0.
		/// </para>
		/// </param>
		/// <param name="format">
		/// <para>
		/// Specifies the format of the pixel data. The following symbolic values are accepted: GL_RED, GL_RG, GL_RGB, GL_BGR, GL_RGBA, and GL_BGRA.
		/// </para>
		/// </param>
		/// <param name="type">
		/// <para>
		/// Specifies the data type of the pixel data. The following symbolic values are accepted: GL_UNSIGNED_BYTE, GL_BYTE, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV.
		/// </para>
		/// </param>
		/// <param name="pixels">
		/// <para>
		/// Specifies a pointer to the image data in memory.
		/// </para>
		/// </param>
		//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glTexImage2D")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
				void TexImage2D(System.Graphics.ES11.All target, Int32 level, Int32 internalFormat, Int32 width, Int32 height, Int32 border, System.Graphics.ES11.All format, System.Graphics.ES11.All type, IntPtr pixels) {
			Delegates.glTexImage2D((System.Graphics.ES11.All) target, (Int32) level, (Int32) internalFormat, (Int32) width, (Int32) height, (Int32) border, (System.Graphics.ES11.All) format, (System.Graphics.ES11.All) type, (IntPtr) pixels);
		}


		/// <summary>[requires: v1.1 and 1.1]
		/// Specify a two-dimensional texture image
		/// </summary>
		/// <param name="target">
		/// <para>
		/// Specifies the target texture. Must be GL_TEXTURE_2D, GL_PROXY_TEXTURE_2D, GL_TEXTURE_1D_ARRAY, GL_PROXY_TEXTURE_1D_ARRAY, GL_TEXTURE_RECTANGLE, GL_PROXY_TEXTURE_RECTANGLE, GL_TEXTURE_CUBE_MAP_POSITIVE_X, GL_TEXTURE_CUBE_MAP_NEGATIVE_X, GL_TEXTURE_CUBE_MAP_POSITIVE_Y, GL_TEXTURE_CUBE_MAP_NEGATIVE_Y, GL_TEXTURE_CUBE_MAP_POSITIVE_Z, GL_TEXTURE_CUBE_MAP_NEGATIVE_Z, or GL_PROXY_TEXTURE_CUBE_MAP.
		/// </para>
		/// </param>
		/// <param name="level">
		/// <para>
		/// Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image. If target is GL_TEXTURE_RECTANGLE or GL_PROXY_TEXTURE_RECTANGLE, level must be 0.
		/// </para>
		/// </param>
		/// <param name="internalFormat">
		/// <para>
		/// Specifies the number of color components in the texture. Must be one of the following symbolic constants: GL_COMPRESSED_RED, GL_COMPRESSED_RG, GL_COMPRESSED_RGB, GL_COMPRESSED_RGBA, GL_COMPRESSED_SRGB, GL_COMPRESSED_SRGB_ALPHA, GL_DEPTH_COMPONENT, GL_DEPTH_COMPONENT16, GL_DEPTH_COMPONENT24, GL_DEPTH_COMPONENT32, GL_R3_G3_B2, GL_RED, GL_RG, GL_RGB, GL_RGB4, GL_RGB5, GL_RGB8, GL_RGB10, GL_RGB12, GL_RGB16, GL_RGBA, GL_RGBA2, GL_RGBA4, GL_RGB5_A1, GL_RGBA8, GL_RGB10_A2, GL_RGBA12, GL_RGBA16, GL_SRGB, GL_SRGB8, GL_SRGB_ALPHA, or GL_SRGB8_ALPHA8.
		/// </para>
		/// </param>
		/// <param name="width">
		/// <para>
		/// Specifies the width of the texture image. All implementations support texture images that are at least 1024 texels wide.
		/// </para>
		/// </param>
		/// <param name="height">
		/// <para>
		/// Specifies the height of the texture image, or the number of layers in a texture array, in the case of the GL_TEXTURE_1D_ARRAY and GL_PROXY_TEXTURE_1D_ARRAY targets. All implementations support 2D texture images that are at least 1024 texels high, and texture arrays that are at least 256 layers deep.
		/// </para>
		/// </param>
		/// <param name="border">
		/// <para>
		/// This value must be 0.
		/// </para>
		/// </param>
		/// <param name="format">
		/// <para>
		/// Specifies the format of the pixel data. The following symbolic values are accepted: GL_RED, GL_RG, GL_RGB, GL_BGR, GL_RGBA, and GL_BGRA.
		/// </para>
		/// </param>
		/// <param name="type">
		/// <para>
		/// Specifies the data type of the pixel data. The following symbolic values are accepted: GL_UNSIGNED_BYTE, GL_BYTE, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV.
		/// </para>
		/// </param>
		/// <param name="pixels">
		/// <para>
		/// Specifies a pointer to the image data in memory.
		/// </para>
		/// </param>
		//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glTexImage2D")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
				void TexImage2D<T8>(System.Graphics.ES11.All target, Int32 level, Int32 internalFormat, Int32 width, Int32 height, Int32 border, System.Graphics.ES11.All format, System.Graphics.ES11.All type, [InAttribute, OutAttribute] T8[] pixels)
					where T8 : struct {
			GCHandle pixels_ptr = GCHandle.Alloc(pixels, GCHandleType.Pinned);
			try {
				Delegates.glTexImage2D((System.Graphics.ES11.All) target, (Int32) level, (Int32) internalFormat, (Int32) width, (Int32) height, (Int32) border, (System.Graphics.ES11.All) format, (System.Graphics.ES11.All) type, (IntPtr) pixels_ptr.AddrOfPinnedObject());
			} finally {
				pixels_ptr.Free();
			}
		}


		/// <summary>[requires: v1.1 and 1.1]
		/// Specify a two-dimensional texture image
		/// </summary>
		/// <param name="target">
		/// <para>
		/// Specifies the target texture. Must be GL_TEXTURE_2D, GL_PROXY_TEXTURE_2D, GL_TEXTURE_1D_ARRAY, GL_PROXY_TEXTURE_1D_ARRAY, GL_TEXTURE_RECTANGLE, GL_PROXY_TEXTURE_RECTANGLE, GL_TEXTURE_CUBE_MAP_POSITIVE_X, GL_TEXTURE_CUBE_MAP_NEGATIVE_X, GL_TEXTURE_CUBE_MAP_POSITIVE_Y, GL_TEXTURE_CUBE_MAP_NEGATIVE_Y, GL_TEXTURE_CUBE_MAP_POSITIVE_Z, GL_TEXTURE_CUBE_MAP_NEGATIVE_Z, or GL_PROXY_TEXTURE_CUBE_MAP.
		/// </para>
		/// </param>
		/// <param name="level">
		/// <para>
		/// Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image. If target is GL_TEXTURE_RECTANGLE or GL_PROXY_TEXTURE_RECTANGLE, level must be 0.
		/// </para>
		/// </param>
		/// <param name="internalFormat">
		/// <para>
		/// Specifies the number of color components in the texture. Must be one of the following symbolic constants: GL_COMPRESSED_RED, GL_COMPRESSED_RG, GL_COMPRESSED_RGB, GL_COMPRESSED_RGBA, GL_COMPRESSED_SRGB, GL_COMPRESSED_SRGB_ALPHA, GL_DEPTH_COMPONENT, GL_DEPTH_COMPONENT16, GL_DEPTH_COMPONENT24, GL_DEPTH_COMPONENT32, GL_R3_G3_B2, GL_RED, GL_RG, GL_RGB, GL_RGB4, GL_RGB5, GL_RGB8, GL_RGB10, GL_RGB12, GL_RGB16, GL_RGBA, GL_RGBA2, GL_RGBA4, GL_RGB5_A1, GL_RGBA8, GL_RGB10_A2, GL_RGBA12, GL_RGBA16, GL_SRGB, GL_SRGB8, GL_SRGB_ALPHA, or GL_SRGB8_ALPHA8.
		/// </para>
		/// </param>
		/// <param name="width">
		/// <para>
		/// Specifies the width of the texture image. All implementations support texture images that are at least 1024 texels wide.
		/// </para>
		/// </param>
		/// <param name="height">
		/// <para>
		/// Specifies the height of the texture image, or the number of layers in a texture array, in the case of the GL_TEXTURE_1D_ARRAY and GL_PROXY_TEXTURE_1D_ARRAY targets. All implementations support 2D texture images that are at least 1024 texels high, and texture arrays that are at least 256 layers deep.
		/// </para>
		/// </param>
		/// <param name="border">
		/// <para>
		/// This value must be 0.
		/// </para>
		/// </param>
		/// <param name="format">
		/// <para>
		/// Specifies the format of the pixel data. The following symbolic values are accepted: GL_RED, GL_RG, GL_RGB, GL_BGR, GL_RGBA, and GL_BGRA.
		/// </para>
		/// </param>
		/// <param name="type">
		/// <para>
		/// Specifies the data type of the pixel data. The following symbolic values are accepted: GL_UNSIGNED_BYTE, GL_BYTE, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV.
		/// </para>
		/// </param>
		/// <param name="pixels">
		/// <para>
		/// Specifies a pointer to the image data in memory.
		/// </para>
		/// </param>
		//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glTexImage2D")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
				void TexImage2D<T8>(System.Graphics.ES11.All target, Int32 level, Int32 internalFormat, Int32 width, Int32 height, Int32 border, System.Graphics.ES11.All format, System.Graphics.ES11.All type, [InAttribute, OutAttribute] T8[,] pixels)
					where T8 : struct {
			GCHandle pixels_ptr = GCHandle.Alloc(pixels, GCHandleType.Pinned);
			try {
				Delegates.glTexImage2D((System.Graphics.ES11.All) target, (Int32) level, (Int32) internalFormat, (Int32) width, (Int32) height, (Int32) border, (System.Graphics.ES11.All) format, (System.Graphics.ES11.All) type, (IntPtr) pixels_ptr.AddrOfPinnedObject());
			} finally {
				pixels_ptr.Free();
			}
		}


		/// <summary>[requires: v1.1 and 1.1]
		/// Specify a two-dimensional texture image
		/// </summary>
		/// <param name="target">
		/// <para>
		/// Specifies the target texture. Must be GL_TEXTURE_2D, GL_PROXY_TEXTURE_2D, GL_TEXTURE_1D_ARRAY, GL_PROXY_TEXTURE_1D_ARRAY, GL_TEXTURE_RECTANGLE, GL_PROXY_TEXTURE_RECTANGLE, GL_TEXTURE_CUBE_MAP_POSITIVE_X, GL_TEXTURE_CUBE_MAP_NEGATIVE_X, GL_TEXTURE_CUBE_MAP_POSITIVE_Y, GL_TEXTURE_CUBE_MAP_NEGATIVE_Y, GL_TEXTURE_CUBE_MAP_POSITIVE_Z, GL_TEXTURE_CUBE_MAP_NEGATIVE_Z, or GL_PROXY_TEXTURE_CUBE_MAP.
		/// </para>
		/// </param>
		/// <param name="level">
		/// <para>
		/// Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image. If target is GL_TEXTURE_RECTANGLE or GL_PROXY_TEXTURE_RECTANGLE, level must be 0.
		/// </para>
		/// </param>
		/// <param name="internalFormat">
		/// <para>
		/// Specifies the number of color components in the texture. Must be one of the following symbolic constants: GL_COMPRESSED_RED, GL_COMPRESSED_RG, GL_COMPRESSED_RGB, GL_COMPRESSED_RGBA, GL_COMPRESSED_SRGB, GL_COMPRESSED_SRGB_ALPHA, GL_DEPTH_COMPONENT, GL_DEPTH_COMPONENT16, GL_DEPTH_COMPONENT24, GL_DEPTH_COMPONENT32, GL_R3_G3_B2, GL_RED, GL_RG, GL_RGB, GL_RGB4, GL_RGB5, GL_RGB8, GL_RGB10, GL_RGB12, GL_RGB16, GL_RGBA, GL_RGBA2, GL_RGBA4, GL_RGB5_A1, GL_RGBA8, GL_RGB10_A2, GL_RGBA12, GL_RGBA16, GL_SRGB, GL_SRGB8, GL_SRGB_ALPHA, or GL_SRGB8_ALPHA8.
		/// </para>
		/// </param>
		/// <param name="width">
		/// <para>
		/// Specifies the width of the texture image. All implementations support texture images that are at least 1024 texels wide.
		/// </para>
		/// </param>
		/// <param name="height">
		/// <para>
		/// Specifies the height of the texture image, or the number of layers in a texture array, in the case of the GL_TEXTURE_1D_ARRAY and GL_PROXY_TEXTURE_1D_ARRAY targets. All implementations support 2D texture images that are at least 1024 texels high, and texture arrays that are at least 256 layers deep.
		/// </para>
		/// </param>
		/// <param name="border">
		/// <para>
		/// This value must be 0.
		/// </para>
		/// </param>
		/// <param name="format">
		/// <para>
		/// Specifies the format of the pixel data. The following symbolic values are accepted: GL_RED, GL_RG, GL_RGB, GL_BGR, GL_RGBA, and GL_BGRA.
		/// </para>
		/// </param>
		/// <param name="type">
		/// <para>
		/// Specifies the data type of the pixel data. The following symbolic values are accepted: GL_UNSIGNED_BYTE, GL_BYTE, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV.
		/// </para>
		/// </param>
		/// <param name="pixels">
		/// <para>
		/// Specifies a pointer to the image data in memory.
		/// </para>
		/// </param>
		//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glTexImage2D")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
				void TexImage2D<T8>(System.Graphics.ES11.All target, Int32 level, Int32 internalFormat, Int32 width, Int32 height, Int32 border, System.Graphics.ES11.All format, System.Graphics.ES11.All type, [InAttribute, OutAttribute] T8[,,] pixels)
					where T8 : struct {
			GCHandle pixels_ptr = GCHandle.Alloc(pixels, GCHandleType.Pinned);
			try {
				Delegates.glTexImage2D((System.Graphics.ES11.All) target, (Int32) level, (Int32) internalFormat, (Int32) width, (Int32) height, (Int32) border, (System.Graphics.ES11.All) format, (System.Graphics.ES11.All) type, (IntPtr) pixels_ptr.AddrOfPinnedObject());
			} finally {
				pixels_ptr.Free();
			}
		}


		/// <summary>[requires: v1.1 and 1.1]
		/// Specify a two-dimensional texture image
		/// </summary>
		/// <param name="target">
		/// <para>
		/// Specifies the target texture. Must be GL_TEXTURE_2D, GL_PROXY_TEXTURE_2D, GL_TEXTURE_1D_ARRAY, GL_PROXY_TEXTURE_1D_ARRAY, GL_TEXTURE_RECTANGLE, GL_PROXY_TEXTURE_RECTANGLE, GL_TEXTURE_CUBE_MAP_POSITIVE_X, GL_TEXTURE_CUBE_MAP_NEGATIVE_X, GL_TEXTURE_CUBE_MAP_POSITIVE_Y, GL_TEXTURE_CUBE_MAP_NEGATIVE_Y, GL_TEXTURE_CUBE_MAP_POSITIVE_Z, GL_TEXTURE_CUBE_MAP_NEGATIVE_Z, or GL_PROXY_TEXTURE_CUBE_MAP.
		/// </para>
		/// </param>
		/// <param name="level">
		/// <para>
		/// Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image. If target is GL_TEXTURE_RECTANGLE or GL_PROXY_TEXTURE_RECTANGLE, level must be 0.
		/// </para>
		/// </param>
		/// <param name="internalFormat">
		/// <para>
		/// Specifies the number of color components in the texture. Must be one of the following symbolic constants: GL_COMPRESSED_RED, GL_COMPRESSED_RG, GL_COMPRESSED_RGB, GL_COMPRESSED_RGBA, GL_COMPRESSED_SRGB, GL_COMPRESSED_SRGB_ALPHA, GL_DEPTH_COMPONENT, GL_DEPTH_COMPONENT16, GL_DEPTH_COMPONENT24, GL_DEPTH_COMPONENT32, GL_R3_G3_B2, GL_RED, GL_RG, GL_RGB, GL_RGB4, GL_RGB5, GL_RGB8, GL_RGB10, GL_RGB12, GL_RGB16, GL_RGBA, GL_RGBA2, GL_RGBA4, GL_RGB5_A1, GL_RGBA8, GL_RGB10_A2, GL_RGBA12, GL_RGBA16, GL_SRGB, GL_SRGB8, GL_SRGB_ALPHA, or GL_SRGB8_ALPHA8.
		/// </para>
		/// </param>
		/// <param name="width">
		/// <para>
		/// Specifies the width of the texture image. All implementations support texture images that are at least 1024 texels wide.
		/// </para>
		/// </param>
		/// <param name="height">
		/// <para>
		/// Specifies the height of the texture image, or the number of layers in a texture array, in the case of the GL_TEXTURE_1D_ARRAY and GL_PROXY_TEXTURE_1D_ARRAY targets. All implementations support 2D texture images that are at least 1024 texels high, and texture arrays that are at least 256 layers deep.
		/// </para>
		/// </param>
		/// <param name="border">
		/// <para>
		/// This value must be 0.
		/// </para>
		/// </param>
		/// <param name="format">
		/// <para>
		/// Specifies the format of the pixel data. The following symbolic values are accepted: GL_RED, GL_RG, GL_RGB, GL_BGR, GL_RGBA, and GL_BGRA.
		/// </para>
		/// </param>
		/// <param name="type">
		/// <para>
		/// Specifies the data type of the pixel data. The following symbolic values are accepted: GL_UNSIGNED_BYTE, GL_BYTE, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV.
		/// </para>
		/// </param>
		/// <param name="pixels">
		/// <para>
		/// Specifies a pointer to the image data in memory.
		/// </para>
		/// </param>
		//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glTexImage2D")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
				void TexImage2D<T8>(System.Graphics.ES11.All target, Int32 level, Int32 internalFormat, Int32 width, Int32 height, Int32 border, System.Graphics.ES11.All format, System.Graphics.ES11.All type, [InAttribute, OutAttribute] ref T8 pixels)
					where T8 : struct {
			GCHandle pixels_ptr = GCHandle.Alloc(pixels, GCHandleType.Pinned);
			try {
				Delegates.glTexImage2D((System.Graphics.ES11.All) target, (Int32) level, (Int32) internalFormat, (Int32) width, (Int32) height, (Int32) border, (System.Graphics.ES11.All) format, (System.Graphics.ES11.All) type, (IntPtr) pixels_ptr.AddrOfPinnedObject());
				pixels = (T8) pixels_ptr.Target;
			} finally {
				pixels_ptr.Free();
			}
		}


		/// <summary>[requires: v1.1 and 1.1]
		/// Set texture parameters
		/// </summary>
		/// <param name="target">
		/// <para>
		/// Specifies the target texture, which must be either GL_TEXTURE_1D, GL_TEXTURE_2D, GL_TEXTURE_3D, GL_TEXTURE_1D_ARRAY, GL_TEXTURE_2D_ARRAY, GL_TEXTURE_RECTANGLE, or GL_TEXTURE_CUBE_MAP.
		/// </para>
		/// </param>
		/// <param name="pname">
		/// <para>
		/// Specifies the symbolic name of a single-valued texture parameter. pname can be one of the following: GL_TEXTURE_BASE_LEVEL, GL_TEXTURE_COMPARE_FUNC, GL_TEXTURE_COMPARE_MODE, GL_TEXTURE_LOD_BIAS, GL_TEXTURE_MIN_FILTER, GL_TEXTURE_MAG_FILTER, GL_TEXTURE_MIN_LOD, GL_TEXTURE_MAX_LOD, GL_TEXTURE_MAX_LEVEL, GL_TEXTURE_SWIZZLE_R, GL_TEXTURE_SWIZZLE_G, GL_TEXTURE_SWIZZLE_B, GL_TEXTURE_SWIZZLE_A, GL_TEXTURE_WRAP_S, GL_TEXTURE_WRAP_T, or GL_TEXTURE_WRAP_R.
		/// </para>
		/// </param>
		/// <param name="param">
		/// <para>
		/// Specifies the value of pname.
		/// </para>
		/// </param>
		//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glTexParameterf")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
				void TexParameter(System.Graphics.ES11.All target, System.Graphics.ES11.All pname, Single param) {
			Delegates.glTexParameterf((System.Graphics.ES11.All) target, (System.Graphics.ES11.All) pname, (Single) param);
		}


		/// <summary>[requires: v1.1 and 1.1]
		/// Set texture parameters
		/// </summary>
		/// <param name="target">
		/// <para>
		/// Specifies the target texture, which must be either GL_TEXTURE_1D, GL_TEXTURE_2D, GL_TEXTURE_3D, GL_TEXTURE_1D_ARRAY, GL_TEXTURE_2D_ARRAY, GL_TEXTURE_RECTANGLE, or GL_TEXTURE_CUBE_MAP.
		/// </para>
		/// </param>
		/// <param name="pname">
		/// <para>
		/// Specifies the symbolic name of a single-valued texture parameter. pname can be one of the following: GL_TEXTURE_BASE_LEVEL, GL_TEXTURE_COMPARE_FUNC, GL_TEXTURE_COMPARE_MODE, GL_TEXTURE_LOD_BIAS, GL_TEXTURE_MIN_FILTER, GL_TEXTURE_MAG_FILTER, GL_TEXTURE_MIN_LOD, GL_TEXTURE_MAX_LOD, GL_TEXTURE_MAX_LEVEL, GL_TEXTURE_SWIZZLE_R, GL_TEXTURE_SWIZZLE_G, GL_TEXTURE_SWIZZLE_B, GL_TEXTURE_SWIZZLE_A, GL_TEXTURE_WRAP_S, GL_TEXTURE_WRAP_T, or GL_TEXTURE_WRAP_R.
		/// </para>
		/// </param>
		/// <param name="params">
		/// <para>
		/// Specifies the value of pname.
		/// </para>
		/// </param>
		//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glTexParameterfv")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
				void TexParameter(System.Graphics.ES11.All target, System.Graphics.ES11.All pname, Single[] @params) {
			unsafe
			{
				fixed (Single* @params_ptr = @params) {
					Delegates.glTexParameterfv((System.Graphics.ES11.All) target, (System.Graphics.ES11.All) pname, (Single*) @params_ptr);
				}
			}
		}


		/// <summary>[requires: v1.1 and 1.1]
		/// Set texture parameters
		/// </summary>
		/// <param name="target">
		/// <para>
		/// Specifies the target texture, which must be either GL_TEXTURE_1D, GL_TEXTURE_2D, GL_TEXTURE_3D, GL_TEXTURE_1D_ARRAY, GL_TEXTURE_2D_ARRAY, GL_TEXTURE_RECTANGLE, or GL_TEXTURE_CUBE_MAP.
		/// </para>
		/// </param>
		/// <param name="pname">
		/// <para>
		/// Specifies the symbolic name of a single-valued texture parameter. pname can be one of the following: GL_TEXTURE_BASE_LEVEL, GL_TEXTURE_COMPARE_FUNC, GL_TEXTURE_COMPARE_MODE, GL_TEXTURE_LOD_BIAS, GL_TEXTURE_MIN_FILTER, GL_TEXTURE_MAG_FILTER, GL_TEXTURE_MIN_LOD, GL_TEXTURE_MAX_LOD, GL_TEXTURE_MAX_LEVEL, GL_TEXTURE_SWIZZLE_R, GL_TEXTURE_SWIZZLE_G, GL_TEXTURE_SWIZZLE_B, GL_TEXTURE_SWIZZLE_A, GL_TEXTURE_WRAP_S, GL_TEXTURE_WRAP_T, or GL_TEXTURE_WRAP_R.
		/// </para>
		/// </param>
		/// <param name="params">
		/// <para>
		/// Specifies the value of pname.
		/// </para>
		/// </param>
		[System.CLSCompliant(false)]
		//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glTexParameterfv")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
		unsafe void TexParameter(System.Graphics.ES11.All target, System.Graphics.ES11.All pname, Single* @params) {
			Delegates.glTexParameterfv((System.Graphics.ES11.All) target, (System.Graphics.ES11.All) pname, (Single*) @params);
		}


		/// <summary>[requires: v1.1 and 1.1]
		/// Set texture parameters
		/// </summary>
		/// <param name="target">
		/// <para>
		/// Specifies the target texture, which must be either GL_TEXTURE_1D, GL_TEXTURE_2D, GL_TEXTURE_3D, GL_TEXTURE_1D_ARRAY, GL_TEXTURE_2D_ARRAY, GL_TEXTURE_RECTANGLE, or GL_TEXTURE_CUBE_MAP.
		/// </para>
		/// </param>
		/// <param name="pname">
		/// <para>
		/// Specifies the symbolic name of a single-valued texture parameter. pname can be one of the following: GL_TEXTURE_BASE_LEVEL, GL_TEXTURE_COMPARE_FUNC, GL_TEXTURE_COMPARE_MODE, GL_TEXTURE_LOD_BIAS, GL_TEXTURE_MIN_FILTER, GL_TEXTURE_MAG_FILTER, GL_TEXTURE_MIN_LOD, GL_TEXTURE_MAX_LOD, GL_TEXTURE_MAX_LEVEL, GL_TEXTURE_SWIZZLE_R, GL_TEXTURE_SWIZZLE_G, GL_TEXTURE_SWIZZLE_B, GL_TEXTURE_SWIZZLE_A, GL_TEXTURE_WRAP_S, GL_TEXTURE_WRAP_T, or GL_TEXTURE_WRAP_R.
		/// </para>
		/// </param>
		/// <param name="param">
		/// <para>
		/// Specifies the value of pname.
		/// </para>
		/// </param>
		//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glTexParameteri")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
				void TexParameter(System.Graphics.ES11.All target, System.Graphics.ES11.All pname, Int32 param) {
			Delegates.glTexParameteri((System.Graphics.ES11.All) target, (System.Graphics.ES11.All) pname, (Int32) param);
		}


		/// <summary>[requires: v1.1 and 1.1]
		/// Set texture parameters
		/// </summary>
		/// <param name="target">
		/// <para>
		/// Specifies the target texture, which must be either GL_TEXTURE_1D, GL_TEXTURE_2D, GL_TEXTURE_3D, GL_TEXTURE_1D_ARRAY, GL_TEXTURE_2D_ARRAY, GL_TEXTURE_RECTANGLE, or GL_TEXTURE_CUBE_MAP.
		/// </para>
		/// </param>
		/// <param name="pname">
		/// <para>
		/// Specifies the symbolic name of a single-valued texture parameter. pname can be one of the following: GL_TEXTURE_BASE_LEVEL, GL_TEXTURE_COMPARE_FUNC, GL_TEXTURE_COMPARE_MODE, GL_TEXTURE_LOD_BIAS, GL_TEXTURE_MIN_FILTER, GL_TEXTURE_MAG_FILTER, GL_TEXTURE_MIN_LOD, GL_TEXTURE_MAX_LOD, GL_TEXTURE_MAX_LEVEL, GL_TEXTURE_SWIZZLE_R, GL_TEXTURE_SWIZZLE_G, GL_TEXTURE_SWIZZLE_B, GL_TEXTURE_SWIZZLE_A, GL_TEXTURE_WRAP_S, GL_TEXTURE_WRAP_T, or GL_TEXTURE_WRAP_R.
		/// </para>
		/// </param>
		/// <param name="params">
		/// <para>
		/// Specifies the value of pname.
		/// </para>
		/// </param>
		//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glTexParameteriv")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
				void TexParameter(System.Graphics.ES11.All target, System.Graphics.ES11.All pname, Int32[] @params) {
			unsafe
			{
				fixed (Int32* @params_ptr = @params) {
					Delegates.glTexParameteriv((System.Graphics.ES11.All) target, (System.Graphics.ES11.All) pname, (Int32*) @params_ptr);
				}
			}
		}


		/// <summary>[requires: v1.1 and 1.1]
		/// Set texture parameters
		/// </summary>
		/// <param name="target">
		/// <para>
		/// Specifies the target texture, which must be either GL_TEXTURE_1D, GL_TEXTURE_2D, GL_TEXTURE_3D, GL_TEXTURE_1D_ARRAY, GL_TEXTURE_2D_ARRAY, GL_TEXTURE_RECTANGLE, or GL_TEXTURE_CUBE_MAP.
		/// </para>
		/// </param>
		/// <param name="pname">
		/// <para>
		/// Specifies the symbolic name of a single-valued texture parameter. pname can be one of the following: GL_TEXTURE_BASE_LEVEL, GL_TEXTURE_COMPARE_FUNC, GL_TEXTURE_COMPARE_MODE, GL_TEXTURE_LOD_BIAS, GL_TEXTURE_MIN_FILTER, GL_TEXTURE_MAG_FILTER, GL_TEXTURE_MIN_LOD, GL_TEXTURE_MAX_LOD, GL_TEXTURE_MAX_LEVEL, GL_TEXTURE_SWIZZLE_R, GL_TEXTURE_SWIZZLE_G, GL_TEXTURE_SWIZZLE_B, GL_TEXTURE_SWIZZLE_A, GL_TEXTURE_WRAP_S, GL_TEXTURE_WRAP_T, or GL_TEXTURE_WRAP_R.
		/// </para>
		/// </param>
		/// <param name="params">
		/// <para>
		/// Specifies the value of pname.
		/// </para>
		/// </param>
		[System.CLSCompliant(false)]
		//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glTexParameteriv")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
		unsafe void TexParameter(System.Graphics.ES11.All target, System.Graphics.ES11.All pname, Int32* @params) {
			Delegates.glTexParameteriv((System.Graphics.ES11.All) target, (System.Graphics.ES11.All) pname, (Int32*) @params);
		}

		/// <summary>[requires: v1.1 and 1.1]</summary>
		//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glTexParameterx")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
				void TexParameterx(System.Graphics.ES11.All target, System.Graphics.ES11.All pname, int param) {
			Delegates.glTexParameterx((System.Graphics.ES11.All) target, (System.Graphics.ES11.All) pname, (int) param);
		}

		/// <summary>[requires: v1.1 and 1.1]</summary>
		//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glTexParameterxv")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
				void TexParameterx(System.Graphics.ES11.All target, System.Graphics.ES11.All pname, int[] @params) {
			unsafe
			{
				fixed (int* @params_ptr = @params) {
					Delegates.glTexParameterxv((System.Graphics.ES11.All) target, (System.Graphics.ES11.All) pname, (int*) @params_ptr);
				}
			}
		}

		/// <summary>[requires: v1.1 and 1.1]</summary>
		[System.CLSCompliant(false)]
		//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glTexParameterxv")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
		unsafe void TexParameterx(System.Graphics.ES11.All target, System.Graphics.ES11.All pname, int* @params) {
			Delegates.glTexParameterxv((System.Graphics.ES11.All) target, (System.Graphics.ES11.All) pname, (int*) @params);
		}


		/// <summary>[requires: v1.1 and 1.1]
		/// Specify a two-dimensional texture subimage
		/// </summary>
		/// <param name="target">
		/// <para>
		/// Specifies the target texture. Must be GL_TEXTURE_2D, GL_TEXTURE_CUBE_MAP_POSITIVE_X, GL_TEXTURE_CUBE_MAP_NEGATIVE_X, GL_TEXTURE_CUBE_MAP_POSITIVE_Y, GL_TEXTURE_CUBE_MAP_NEGATIVE_Y, GL_TEXTURE_CUBE_MAP_POSITIVE_Z, or GL_TEXTURE_CUBE_MAP_NEGATIVE_Z.
		/// </para>
		/// </param>
		/// <param name="level">
		/// <para>
		/// Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.
		/// </para>
		/// </param>
		/// <param name="xoffset">
		/// <para>
		/// Specifies a texel offset in the x direction within the texture array.
		/// </para>
		/// </param>
		/// <param name="yoffset">
		/// <para>
		/// Specifies a texel offset in the y direction within the texture array.
		/// </para>
		/// </param>
		/// <param name="width">
		/// <para>
		/// Specifies the width of the texture subimage.
		/// </para>
		/// </param>
		/// <param name="height">
		/// <para>
		/// Specifies the height of the texture subimage.
		/// </para>
		/// </param>
		/// <param name="format">
		/// <para>
		/// Specifies the format of the pixel data. The following symbolic values are accepted: GL_RED, GL_RG, GL_RGB, GL_BGR, GL_RGBA, and GL_BGRA.
		/// </para>
		/// </param>
		/// <param name="type">
		/// <para>
		/// Specifies the data type of the pixel data. The following symbolic values are accepted: GL_UNSIGNED_BYTE, GL_BYTE, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV.
		/// </para>
		/// </param>
		/// <param name="pixels">
		/// <para>
		/// Specifies a pointer to the image data in memory.
		/// </para>
		/// </param>
		//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glTexSubImage2D")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
				void TexSubImage2D(System.Graphics.ES11.All target, Int32 level, Int32 xoffset, Int32 yoffset, Int32 width, Int32 height, System.Graphics.ES11.All format, System.Graphics.ES11.All type, IntPtr pixels) {
			Delegates.glTexSubImage2D((System.Graphics.ES11.All) target, (Int32) level, (Int32) xoffset, (Int32) yoffset, (Int32) width, (Int32) height, (System.Graphics.ES11.All) format, (System.Graphics.ES11.All) type, (IntPtr) pixels);
		}


		/// <summary>[requires: v1.1 and 1.1]
		/// Specify a two-dimensional texture subimage
		/// </summary>
		/// <param name="target">
		/// <para>
		/// Specifies the target texture. Must be GL_TEXTURE_2D, GL_TEXTURE_CUBE_MAP_POSITIVE_X, GL_TEXTURE_CUBE_MAP_NEGATIVE_X, GL_TEXTURE_CUBE_MAP_POSITIVE_Y, GL_TEXTURE_CUBE_MAP_NEGATIVE_Y, GL_TEXTURE_CUBE_MAP_POSITIVE_Z, or GL_TEXTURE_CUBE_MAP_NEGATIVE_Z.
		/// </para>
		/// </param>
		/// <param name="level">
		/// <para>
		/// Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.
		/// </para>
		/// </param>
		/// <param name="xoffset">
		/// <para>
		/// Specifies a texel offset in the x direction within the texture array.
		/// </para>
		/// </param>
		/// <param name="yoffset">
		/// <para>
		/// Specifies a texel offset in the y direction within the texture array.
		/// </para>
		/// </param>
		/// <param name="width">
		/// <para>
		/// Specifies the width of the texture subimage.
		/// </para>
		/// </param>
		/// <param name="height">
		/// <para>
		/// Specifies the height of the texture subimage.
		/// </para>
		/// </param>
		/// <param name="format">
		/// <para>
		/// Specifies the format of the pixel data. The following symbolic values are accepted: GL_RED, GL_RG, GL_RGB, GL_BGR, GL_RGBA, and GL_BGRA.
		/// </para>
		/// </param>
		/// <param name="type">
		/// <para>
		/// Specifies the data type of the pixel data. The following symbolic values are accepted: GL_UNSIGNED_BYTE, GL_BYTE, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV.
		/// </para>
		/// </param>
		/// <param name="pixels">
		/// <para>
		/// Specifies a pointer to the image data in memory.
		/// </para>
		/// </param>
		//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glTexSubImage2D")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
				void TexSubImage2D<T8>(System.Graphics.ES11.All target, Int32 level, Int32 xoffset, Int32 yoffset, Int32 width, Int32 height, System.Graphics.ES11.All format, System.Graphics.ES11.All type, [InAttribute, OutAttribute] T8[] pixels)
					where T8 : struct {
			GCHandle pixels_ptr = GCHandle.Alloc(pixels, GCHandleType.Pinned);
			try {
				Delegates.glTexSubImage2D((System.Graphics.ES11.All) target, (Int32) level, (Int32) xoffset, (Int32) yoffset, (Int32) width, (Int32) height, (System.Graphics.ES11.All) format, (System.Graphics.ES11.All) type, (IntPtr) pixels_ptr.AddrOfPinnedObject());
			} finally {
				pixels_ptr.Free();
			}
		}


		/// <summary>[requires: v1.1 and 1.1]
		/// Specify a two-dimensional texture subimage
		/// </summary>
		/// <param name="target">
		/// <para>
		/// Specifies the target texture. Must be GL_TEXTURE_2D, GL_TEXTURE_CUBE_MAP_POSITIVE_X, GL_TEXTURE_CUBE_MAP_NEGATIVE_X, GL_TEXTURE_CUBE_MAP_POSITIVE_Y, GL_TEXTURE_CUBE_MAP_NEGATIVE_Y, GL_TEXTURE_CUBE_MAP_POSITIVE_Z, or GL_TEXTURE_CUBE_MAP_NEGATIVE_Z.
		/// </para>
		/// </param>
		/// <param name="level">
		/// <para>
		/// Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.
		/// </para>
		/// </param>
		/// <param name="xoffset">
		/// <para>
		/// Specifies a texel offset in the x direction within the texture array.
		/// </para>
		/// </param>
		/// <param name="yoffset">
		/// <para>
		/// Specifies a texel offset in the y direction within the texture array.
		/// </para>
		/// </param>
		/// <param name="width">
		/// <para>
		/// Specifies the width of the texture subimage.
		/// </para>
		/// </param>
		/// <param name="height">
		/// <para>
		/// Specifies the height of the texture subimage.
		/// </para>
		/// </param>
		/// <param name="format">
		/// <para>
		/// Specifies the format of the pixel data. The following symbolic values are accepted: GL_RED, GL_RG, GL_RGB, GL_BGR, GL_RGBA, and GL_BGRA.
		/// </para>
		/// </param>
		/// <param name="type">
		/// <para>
		/// Specifies the data type of the pixel data. The following symbolic values are accepted: GL_UNSIGNED_BYTE, GL_BYTE, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV.
		/// </para>
		/// </param>
		/// <param name="pixels">
		/// <para>
		/// Specifies a pointer to the image data in memory.
		/// </para>
		/// </param>
		//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glTexSubImage2D")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
				void TexSubImage2D<T8>(System.Graphics.ES11.All target, Int32 level, Int32 xoffset, Int32 yoffset, Int32 width, Int32 height, System.Graphics.ES11.All format, System.Graphics.ES11.All type, [InAttribute, OutAttribute] T8[,] pixels)
					where T8 : struct {
			GCHandle pixels_ptr = GCHandle.Alloc(pixels, GCHandleType.Pinned);
			try {
				Delegates.glTexSubImage2D((System.Graphics.ES11.All) target, (Int32) level, (Int32) xoffset, (Int32) yoffset, (Int32) width, (Int32) height, (System.Graphics.ES11.All) format, (System.Graphics.ES11.All) type, (IntPtr) pixels_ptr.AddrOfPinnedObject());
			} finally {
				pixels_ptr.Free();
			}
		}


		/// <summary>[requires: v1.1 and 1.1]
		/// Specify a two-dimensional texture subimage
		/// </summary>
		/// <param name="target">
		/// <para>
		/// Specifies the target texture. Must be GL_TEXTURE_2D, GL_TEXTURE_CUBE_MAP_POSITIVE_X, GL_TEXTURE_CUBE_MAP_NEGATIVE_X, GL_TEXTURE_CUBE_MAP_POSITIVE_Y, GL_TEXTURE_CUBE_MAP_NEGATIVE_Y, GL_TEXTURE_CUBE_MAP_POSITIVE_Z, or GL_TEXTURE_CUBE_MAP_NEGATIVE_Z.
		/// </para>
		/// </param>
		/// <param name="level">
		/// <para>
		/// Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.
		/// </para>
		/// </param>
		/// <param name="xoffset">
		/// <para>
		/// Specifies a texel offset in the x direction within the texture array.
		/// </para>
		/// </param>
		/// <param name="yoffset">
		/// <para>
		/// Specifies a texel offset in the y direction within the texture array.
		/// </para>
		/// </param>
		/// <param name="width">
		/// <para>
		/// Specifies the width of the texture subimage.
		/// </para>
		/// </param>
		/// <param name="height">
		/// <para>
		/// Specifies the height of the texture subimage.
		/// </para>
		/// </param>
		/// <param name="format">
		/// <para>
		/// Specifies the format of the pixel data. The following symbolic values are accepted: GL_RED, GL_RG, GL_RGB, GL_BGR, GL_RGBA, and GL_BGRA.
		/// </para>
		/// </param>
		/// <param name="type">
		/// <para>
		/// Specifies the data type of the pixel data. The following symbolic values are accepted: GL_UNSIGNED_BYTE, GL_BYTE, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV.
		/// </para>
		/// </param>
		/// <param name="pixels">
		/// <para>
		/// Specifies a pointer to the image data in memory.
		/// </para>
		/// </param>
		//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glTexSubImage2D")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
				void TexSubImage2D<T8>(System.Graphics.ES11.All target, Int32 level, Int32 xoffset, Int32 yoffset, Int32 width, Int32 height, System.Graphics.ES11.All format, System.Graphics.ES11.All type, [InAttribute, OutAttribute] T8[,,] pixels)
					where T8 : struct {
			GCHandle pixels_ptr = GCHandle.Alloc(pixels, GCHandleType.Pinned);
			try {
				Delegates.glTexSubImage2D((System.Graphics.ES11.All) target, (Int32) level, (Int32) xoffset, (Int32) yoffset, (Int32) width, (Int32) height, (System.Graphics.ES11.All) format, (System.Graphics.ES11.All) type, (IntPtr) pixels_ptr.AddrOfPinnedObject());
			} finally {
				pixels_ptr.Free();
			}
		}


		/// <summary>[requires: v1.1 and 1.1]
		/// Specify a two-dimensional texture subimage
		/// </summary>
		/// <param name="target">
		/// <para>
		/// Specifies the target texture. Must be GL_TEXTURE_2D, GL_TEXTURE_CUBE_MAP_POSITIVE_X, GL_TEXTURE_CUBE_MAP_NEGATIVE_X, GL_TEXTURE_CUBE_MAP_POSITIVE_Y, GL_TEXTURE_CUBE_MAP_NEGATIVE_Y, GL_TEXTURE_CUBE_MAP_POSITIVE_Z, or GL_TEXTURE_CUBE_MAP_NEGATIVE_Z.
		/// </para>
		/// </param>
		/// <param name="level">
		/// <para>
		/// Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.
		/// </para>
		/// </param>
		/// <param name="xoffset">
		/// <para>
		/// Specifies a texel offset in the x direction within the texture array.
		/// </para>
		/// </param>
		/// <param name="yoffset">
		/// <para>
		/// Specifies a texel offset in the y direction within the texture array.
		/// </para>
		/// </param>
		/// <param name="width">
		/// <para>
		/// Specifies the width of the texture subimage.
		/// </para>
		/// </param>
		/// <param name="height">
		/// <para>
		/// Specifies the height of the texture subimage.
		/// </para>
		/// </param>
		/// <param name="format">
		/// <para>
		/// Specifies the format of the pixel data. The following symbolic values are accepted: GL_RED, GL_RG, GL_RGB, GL_BGR, GL_RGBA, and GL_BGRA.
		/// </para>
		/// </param>
		/// <param name="type">
		/// <para>
		/// Specifies the data type of the pixel data. The following symbolic values are accepted: GL_UNSIGNED_BYTE, GL_BYTE, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV.
		/// </para>
		/// </param>
		/// <param name="pixels">
		/// <para>
		/// Specifies a pointer to the image data in memory.
		/// </para>
		/// </param>
		//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glTexSubImage2D")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
				void TexSubImage2D<T8>(System.Graphics.ES11.All target, Int32 level, Int32 xoffset, Int32 yoffset, Int32 width, Int32 height, System.Graphics.ES11.All format, System.Graphics.ES11.All type, [InAttribute, OutAttribute] ref T8 pixels)
					where T8 : struct {
			GCHandle pixels_ptr = GCHandle.Alloc(pixels, GCHandleType.Pinned);
			try {
				Delegates.glTexSubImage2D((System.Graphics.ES11.All) target, (Int32) level, (Int32) xoffset, (Int32) yoffset, (Int32) width, (Int32) height, (System.Graphics.ES11.All) format, (System.Graphics.ES11.All) type, (IntPtr) pixels_ptr.AddrOfPinnedObject());
				pixels = (T8) pixels_ptr.Target;
			} finally {
				pixels_ptr.Free();
			}
		}


		/// <summary>[requires: v1.1 and 1.1]
		/// Multiply the current matrix by a translation matrix
		/// </summary>
		//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glTranslatef")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
				void Translate(Single x, Single y, Single z) {
			Delegates.glTranslatef((Single) x, (Single) y, (Single) z);
		}

		/// <summary>[requires: v1.1 and 1.1]</summary>
		//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glTranslatex")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
				void Translatex(int x, int y, int z) {
			Delegates.glTranslatex((int) x, (int) y, (int) z);
		}


		/// <summary>[requires: v1.1 and 1.1]
		/// Define an array of vertex data
		/// </summary>
		/// <param name="size">
		/// <para>
		/// Specifies the number of coordinates per vertex. Must be 2, 3, or 4. The initial value is 4.
		/// </para>
		/// </param>
		/// <param name="type">
		/// <para>
		/// Specifies the data type of each coordinate in the array. Symbolic constants GL_SHORT, GL_INT, GL_FLOAT, or GL_DOUBLE are accepted. The initial value is GL_FLOAT.
		/// </para>
		/// </param>
		/// <param name="stride">
		/// <para>
		/// Specifies the byte offset between consecutive points. If stride is 0, the points are understood to be tightly packed in the array. The initial value is 0.
		/// </para>
		/// </param>
		/// <param name="pointer">
		/// <para>
		/// Specifies a pointer to the first coordinate of the first vertex in the array. The initial value is 0.
		/// </para>
		/// </param>
		//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glVertexPointer")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
				void VertexPointer(Int32 size, System.Graphics.ES11.All type, Int32 stride, IntPtr pointer) {
			Delegates.glVertexPointer((Int32) size, (System.Graphics.ES11.All) type, (Int32) stride, (IntPtr) pointer);
		}


		/// <summary>[requires: v1.1 and 1.1]
		/// Define an array of vertex data
		/// </summary>
		/// <param name="size">
		/// <para>
		/// Specifies the number of coordinates per vertex. Must be 2, 3, or 4. The initial value is 4.
		/// </para>
		/// </param>
		/// <param name="type">
		/// <para>
		/// Specifies the data type of each coordinate in the array. Symbolic constants GL_SHORT, GL_INT, GL_FLOAT, or GL_DOUBLE are accepted. The initial value is GL_FLOAT.
		/// </para>
		/// </param>
		/// <param name="stride">
		/// <para>
		/// Specifies the byte offset between consecutive points. If stride is 0, the points are understood to be tightly packed in the array. The initial value is 0.
		/// </para>
		/// </param>
		/// <param name="pointer">
		/// <para>
		/// Specifies a pointer to the first coordinate of the first vertex in the array. The initial value is 0.
		/// </para>
		/// </param>
		//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glVertexPointer")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
				void VertexPointer<T3>(Int32 size, System.Graphics.ES11.All type, Int32 stride, [InAttribute, OutAttribute] T3[] pointer)
					where T3 : struct {
			GCHandle pointer_ptr = GCHandle.Alloc(pointer, GCHandleType.Pinned);
			try {
				Delegates.glVertexPointer((Int32) size, (System.Graphics.ES11.All) type, (Int32) stride, (IntPtr) pointer_ptr.AddrOfPinnedObject());
			} finally {
				pointer_ptr.Free();
			}
		}


		/// <summary>[requires: v1.1 and 1.1]
		/// Define an array of vertex data
		/// </summary>
		/// <param name="size">
		/// <para>
		/// Specifies the number of coordinates per vertex. Must be 2, 3, or 4. The initial value is 4.
		/// </para>
		/// </param>
		/// <param name="type">
		/// <para>
		/// Specifies the data type of each coordinate in the array. Symbolic constants GL_SHORT, GL_INT, GL_FLOAT, or GL_DOUBLE are accepted. The initial value is GL_FLOAT.
		/// </para>
		/// </param>
		/// <param name="stride">
		/// <para>
		/// Specifies the byte offset between consecutive points. If stride is 0, the points are understood to be tightly packed in the array. The initial value is 0.
		/// </para>
		/// </param>
		/// <param name="pointer">
		/// <para>
		/// Specifies a pointer to the first coordinate of the first vertex in the array. The initial value is 0.
		/// </para>
		/// </param>
		//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glVertexPointer")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
				void VertexPointer<T3>(Int32 size, System.Graphics.ES11.All type, Int32 stride, [InAttribute, OutAttribute] T3[,] pointer)
					where T3 : struct {
			GCHandle pointer_ptr = GCHandle.Alloc(pointer, GCHandleType.Pinned);
			try {
				Delegates.glVertexPointer((Int32) size, (System.Graphics.ES11.All) type, (Int32) stride, (IntPtr) pointer_ptr.AddrOfPinnedObject());
			} finally {
				pointer_ptr.Free();
			}
		}


		/// <summary>[requires: v1.1 and 1.1]
		/// Define an array of vertex data
		/// </summary>
		/// <param name="size">
		/// <para>
		/// Specifies the number of coordinates per vertex. Must be 2, 3, or 4. The initial value is 4.
		/// </para>
		/// </param>
		/// <param name="type">
		/// <para>
		/// Specifies the data type of each coordinate in the array. Symbolic constants GL_SHORT, GL_INT, GL_FLOAT, or GL_DOUBLE are accepted. The initial value is GL_FLOAT.
		/// </para>
		/// </param>
		/// <param name="stride">
		/// <para>
		/// Specifies the byte offset between consecutive points. If stride is 0, the points are understood to be tightly packed in the array. The initial value is 0.
		/// </para>
		/// </param>
		/// <param name="pointer">
		/// <para>
		/// Specifies a pointer to the first coordinate of the first vertex in the array. The initial value is 0.
		/// </para>
		/// </param>
		//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glVertexPointer")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
				void VertexPointer<T3>(Int32 size, System.Graphics.ES11.All type, Int32 stride, [InAttribute, OutAttribute] T3[,,] pointer)
					where T3 : struct {
			GCHandle pointer_ptr = GCHandle.Alloc(pointer, GCHandleType.Pinned);
			try {
				Delegates.glVertexPointer((Int32) size, (System.Graphics.ES11.All) type, (Int32) stride, (IntPtr) pointer_ptr.AddrOfPinnedObject());
			} finally {
				pointer_ptr.Free();
			}
		}


		/// <summary>[requires: v1.1 and 1.1]
		/// Define an array of vertex data
		/// </summary>
		/// <param name="size">
		/// <para>
		/// Specifies the number of coordinates per vertex. Must be 2, 3, or 4. The initial value is 4.
		/// </para>
		/// </param>
		/// <param name="type">
		/// <para>
		/// Specifies the data type of each coordinate in the array. Symbolic constants GL_SHORT, GL_INT, GL_FLOAT, or GL_DOUBLE are accepted. The initial value is GL_FLOAT.
		/// </para>
		/// </param>
		/// <param name="stride">
		/// <para>
		/// Specifies the byte offset between consecutive points. If stride is 0, the points are understood to be tightly packed in the array. The initial value is 0.
		/// </para>
		/// </param>
		/// <param name="pointer">
		/// <para>
		/// Specifies a pointer to the first coordinate of the first vertex in the array. The initial value is 0.
		/// </para>
		/// </param>
		//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glVertexPointer")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
				void VertexPointer<T3>(Int32 size, System.Graphics.ES11.All type, Int32 stride, [InAttribute, OutAttribute] ref T3 pointer)
					where T3 : struct {
			GCHandle pointer_ptr = GCHandle.Alloc(pointer, GCHandleType.Pinned);
			try {
				Delegates.glVertexPointer((Int32) size, (System.Graphics.ES11.All) type, (Int32) stride, (IntPtr) pointer_ptr.AddrOfPinnedObject());
				pointer = (T3) pointer_ptr.Target;
			} finally {
				pointer_ptr.Free();
			}
		}


		/// <summary>[requires: v1.1 and 1.1]
		/// Set the viewport
		/// </summary>
		//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glViewport")]
#if NET45
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
		public static
				void Viewport(Int32 x, Int32 y, Int32 width, Int32 height) {
			Delegates.glViewport((Int32) x, (Int32) y, (Int32) width, (Int32) height);
		}

		/// <summary>
		/// Accesses Nvidia extension methods.
		/// </summary>
		public static class NV {
			/// <summary>[requires: 1.1]</summary>
			//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glDeleteFencesNV")]
#if NET45
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
			public static
						void DeleteFences(Int32 n, Int32[] fences) {
				unsafe
				{
					fixed (Int32* fences_ptr = fences) {
						Delegates.glDeleteFencesNV((Int32) n, (UInt32*) fences_ptr);
					}
				}
			}

			/// <summary>[requires: 1.1]</summary>
			//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glDeleteFencesNV")]
#if NET45
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
			public static
						void DeleteFences(Int32 n, ref Int32 fences) {
				unsafe
				{
					fixed (Int32* fences_ptr = &fences) {
						Delegates.glDeleteFencesNV((Int32) n, (UInt32*) fences_ptr);
					}
				}
			}

			/// <summary>[requires: 1.1]</summary>
			[System.CLSCompliant(false)]
			//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glDeleteFencesNV")]
#if NET45
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
			public static
			unsafe void DeleteFences(Int32 n, Int32* fences) {
				Delegates.glDeleteFencesNV((Int32) n, (UInt32*) fences);
			}

			/// <summary>[requires: 1.1]</summary>
			[System.CLSCompliant(false)]
			//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glDeleteFencesNV")]
#if NET45
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
			public static
			void DeleteFences(Int32 n, UInt32[] fences) {
				unsafe
				{
					fixed (UInt32* fences_ptr = fences) {
						Delegates.glDeleteFencesNV((Int32) n, (UInt32*) fences_ptr);
					}
				}
			}

			/// <summary>[requires: 1.1]</summary>
			[System.CLSCompliant(false)]
			//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glDeleteFencesNV")]
#if NET45
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
			public static
			void DeleteFences(Int32 n, ref UInt32 fences) {
				unsafe
				{
					fixed (UInt32* fences_ptr = &fences) {
						Delegates.glDeleteFencesNV((Int32) n, (UInt32*) fences_ptr);
					}
				}
			}

			/// <summary>[requires: 1.1]</summary>
			[System.CLSCompliant(false)]
			//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glDeleteFencesNV")]
#if NET45
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
			public static
			unsafe void DeleteFences(Int32 n, UInt32* fences) {
				Delegates.glDeleteFencesNV((Int32) n, (UInt32*) fences);
			}

			/// <summary>[requires: 1.1]</summary>
			//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glFinishFenceNV")]
#if NET45
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
			public static
						void FinishFence(Int32 fence) {
				Delegates.glFinishFenceNV((UInt32) fence);
			}

			/// <summary>[requires: 1.1]</summary>
			[System.CLSCompliant(false)]
			//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glFinishFenceNV")]
#if NET45
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
			public static
			void FinishFence(UInt32 fence) {
				Delegates.glFinishFenceNV((UInt32) fence);
			}

			/// <summary>[requires: 1.1]</summary>
			//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glGenFencesNV")]
#if NET45
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
			public static
						void GenFences(Int32 n, Int32[] fences) {
				unsafe
				{
					fixed (Int32* fences_ptr = fences) {
						Delegates.glGenFencesNV((Int32) n, (UInt32*) fences_ptr);
					}
				}
			}

			/// <summary>[requires: 1.1]</summary>
			//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glGenFencesNV")]
#if NET45
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
			public static
						void GenFences(Int32 n, ref Int32 fences) {
				unsafe
				{
					fixed (Int32* fences_ptr = &fences) {
						Delegates.glGenFencesNV((Int32) n, (UInt32*) fences_ptr);
					}
				}
			}

			/// <summary>[requires: 1.1]</summary>
			[System.CLSCompliant(false)]
			//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glGenFencesNV")]
#if NET45
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
			public static
			unsafe void GenFences(Int32 n, Int32* fences) {
				Delegates.glGenFencesNV((Int32) n, (UInt32*) fences);
			}

			/// <summary>[requires: 1.1]</summary>
			[System.CLSCompliant(false)]
			//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glGenFencesNV")]
#if NET45
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
			public static
			void GenFences(Int32 n, UInt32[] fences) {
				unsafe
				{
					fixed (UInt32* fences_ptr = fences) {
						Delegates.glGenFencesNV((Int32) n, (UInt32*) fences_ptr);
					}
				}
			}

			/// <summary>[requires: 1.1]</summary>
			[System.CLSCompliant(false)]
			//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glGenFencesNV")]
#if NET45
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
			public static
			void GenFences(Int32 n, ref UInt32 fences) {
				unsafe
				{
					fixed (UInt32* fences_ptr = &fences) {
						Delegates.glGenFencesNV((Int32) n, (UInt32*) fences_ptr);
					}
				}
			}

			/// <summary>[requires: 1.1]</summary>
			[System.CLSCompliant(false)]
			//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glGenFencesNV")]
#if NET45
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
			public static
			unsafe void GenFences(Int32 n, UInt32* fences) {
				Delegates.glGenFencesNV((Int32) n, (UInt32*) fences);
			}

			/// <summary>[requires: 1.1]</summary>
			//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glGetFenceivNV")]
#if NET45
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
			public static
						void GetFence(Int32 fence, System.Graphics.ES11.All pname, Int32[] @params) {
				unsafe
				{
					fixed (Int32* @params_ptr = @params) {
						Delegates.glGetFenceivNV((UInt32) fence, (System.Graphics.ES11.All) pname, (Int32*) @params_ptr);
					}
				}
			}

			/// <summary>[requires: 1.1]</summary>
			//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glGetFenceivNV")]
#if NET45
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
			public static
						void GetFence(Int32 fence, System.Graphics.ES11.All pname, ref Int32 @params) {
				unsafe
				{
					fixed (Int32* @params_ptr = &@params) {
						Delegates.glGetFenceivNV((UInt32) fence, (System.Graphics.ES11.All) pname, (Int32*) @params_ptr);
					}
				}
			}

			/// <summary>[requires: 1.1]</summary>
			[System.CLSCompliant(false)]
			//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glGetFenceivNV")]
#if NET45
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
			public static
			unsafe void GetFence(Int32 fence, System.Graphics.ES11.All pname, Int32* @params) {
				Delegates.glGetFenceivNV((UInt32) fence, (System.Graphics.ES11.All) pname, (Int32*) @params);
			}

			/// <summary>[requires: 1.1]</summary>
			[System.CLSCompliant(false)]
			//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glGetFenceivNV")]
#if NET45
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
			public static
			void GetFence(UInt32 fence, System.Graphics.ES11.All pname, Int32[] @params) {
				unsafe
				{
					fixed (Int32* @params_ptr = @params) {
						Delegates.glGetFenceivNV((UInt32) fence, (System.Graphics.ES11.All) pname, (Int32*) @params_ptr);
					}
				}
			}

			/// <summary>[requires: 1.1]</summary>
			[System.CLSCompliant(false)]
			//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glGetFenceivNV")]
#if NET45
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
			public static
			void GetFence(UInt32 fence, System.Graphics.ES11.All pname, ref Int32 @params) {
				unsafe
				{
					fixed (Int32* @params_ptr = &@params) {
						Delegates.glGetFenceivNV((UInt32) fence, (System.Graphics.ES11.All) pname, (Int32*) @params_ptr);
					}
				}
			}

			/// <summary>[requires: 1.1]</summary>
			[System.CLSCompliant(false)]
			//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glGetFenceivNV")]
#if NET45
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
			public static
			unsafe void GetFence(UInt32 fence, System.Graphics.ES11.All pname, Int32* @params) {
				Delegates.glGetFenceivNV((UInt32) fence, (System.Graphics.ES11.All) pname, (Int32*) @params);
			}

			/// <summary>[requires: 1.1]</summary>
			//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glIsFenceNV")]
#if NET45
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
			public static
						bool IsFence(Int32 fence) {
				return Delegates.glIsFenceNV((UInt32) fence);
			}

			/// <summary>[requires: 1.1]</summary>
			[System.CLSCompliant(false)]
			//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glIsFenceNV")]
#if NET45
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
			public static
			bool IsFence(UInt32 fence) {
				return Delegates.glIsFenceNV((UInt32) fence);
			}

			/// <summary>[requires: 1.1]</summary>
			//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glSetFenceNV")]
#if NET45
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
			public static
						void SetFence(Int32 fence, System.Graphics.ES11.All condition) {
				Delegates.glSetFenceNV((UInt32) fence, (System.Graphics.ES11.All) condition);
			}

			/// <summary>[requires: 1.1]</summary>
			[System.CLSCompliant(false)]
			//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glSetFenceNV")]
#if NET45
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
			public static
			void SetFence(UInt32 fence, System.Graphics.ES11.All condition) {
				Delegates.glSetFenceNV((UInt32) fence, (System.Graphics.ES11.All) condition);
			}

			/// <summary>[requires: 1.1]</summary>
			//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glTestFenceNV")]
#if NET45
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
			public static
						bool TestFence(Int32 fence) {
				return Delegates.glTestFenceNV((UInt32) fence);
			}

			/// <summary>[requires: 1.1]</summary>
			[System.CLSCompliant(false)]
			//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glTestFenceNV")]
#if NET45
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
			public static
			bool TestFence(UInt32 fence) {
				return Delegates.glTestFenceNV((UInt32) fence);
			}

		}

		/// <summary>
		/// Oes extension methods
		/// </summary>
		public static class Oes {
			/// <summary>[requires: 1.1]</summary>
			//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glAlphaFuncxOES")]
#if NET45
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
			public static
						void AlphaFuncx(System.Graphics.ES11.All func, int @ref) {
				Delegates.glAlphaFuncxOES((System.Graphics.ES11.All) func, (int) @ref);
			}


			/// <summary>[requires: 1.1]
			/// Bind a framebuffer to a framebuffer target
			/// </summary>
			/// <param name="target">
			/// <para>
			/// Specifies the framebuffer target of the binding operation.
			/// </para>
			/// </param>
			/// <param name="framebuffer">
			/// <para>
			/// Specifies the name of the framebuffer object to bind.
			/// </para>
			/// </param>
			//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glBindFramebufferOES")]
#if NET45
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
			public static
						void BindFramebuffer(System.Graphics.ES11.All target, Int32 framebuffer) {
				Delegates.glBindFramebufferOES((System.Graphics.ES11.All) target, (UInt32) framebuffer);
			}


			/// <summary>[requires: 1.1]
			/// Bind a framebuffer to a framebuffer target
			/// </summary>
			/// <param name="target">
			/// <para>
			/// Specifies the framebuffer target of the binding operation.
			/// </para>
			/// </param>
			/// <param name="framebuffer">
			/// <para>
			/// Specifies the name of the framebuffer object to bind.
			/// </para>
			/// </param>
			[System.CLSCompliant(false)]
			//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glBindFramebufferOES")]
#if NET45
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
			public static
			void BindFramebuffer(System.Graphics.ES11.All target, UInt32 framebuffer) {
				Delegates.glBindFramebufferOES((System.Graphics.ES11.All) target, (UInt32) framebuffer);
			}


			/// <summary>[requires: 1.1]
			/// Bind a renderbuffer to a renderbuffer target
			/// </summary>
			/// <param name="target">
			/// <para>
			/// Specifies the renderbuffer target of the binding operation. target must be GL_RENDERBUFFER.
			/// </para>
			/// </param>
			/// <param name="renderbuffer">
			/// <para>
			/// Specifies the name of the renderbuffer object to bind.
			/// </para>
			/// </param>
			//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glBindRenderbufferOES")]
#if NET45
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
			public static
						void BindRenderbuffer(System.Graphics.ES11.All target, Int32 renderbuffer) {
				Delegates.glBindRenderbufferOES((System.Graphics.ES11.All) target, (UInt32) renderbuffer);
			}


			/// <summary>[requires: 1.1]
			/// Bind a renderbuffer to a renderbuffer target
			/// </summary>
			/// <param name="target">
			/// <para>
			/// Specifies the renderbuffer target of the binding operation. target must be GL_RENDERBUFFER.
			/// </para>
			/// </param>
			/// <param name="renderbuffer">
			/// <para>
			/// Specifies the name of the renderbuffer object to bind.
			/// </para>
			/// </param>
			[System.CLSCompliant(false)]
			//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glBindRenderbufferOES")]
#if NET45
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
			public static
			void BindRenderbuffer(System.Graphics.ES11.All target, UInt32 renderbuffer) {
				Delegates.glBindRenderbufferOES((System.Graphics.ES11.All) target, (UInt32) renderbuffer);
			}


			/// <summary>[requires: 1.1]
			/// Specify the equation used for both the RGB blend equation and the Alpha blend equation
			/// </summary>
			/// <param name="mode">
			/// <para>
			/// specifies how source and destination colors are combined. It must be GL_FUNC_ADD, GL_FUNC_SUBTRACT, GL_FUNC_REVERSE_SUBTRACT, GL_MIN, GL_MAX.
			/// </para>
			/// </param>
			//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glBlendEquationOES")]
#if NET45
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
			public static
						void BlendEquation(System.Graphics.ES11.All mode) {
				Delegates.glBlendEquationOES((System.Graphics.ES11.All) mode);
			}


			/// <summary>[requires: 1.1]
			/// Set the RGB blend equation and the alpha blend equation separately
			/// </summary>
			/// <param name="modeRGB">
			/// <para>
			/// specifies the RGB blend equation, how the red, green, and blue components of the source and destination colors are combined. It must be GL_FUNC_ADD, GL_FUNC_SUBTRACT, GL_FUNC_REVERSE_SUBTRACT, GL_MIN, GL_MAX.
			/// </para>
			/// </param>
			/// <param name="modeAlpha">
			/// <para>
			/// specifies the alpha blend equation, how the alpha component of the source and destination colors are combined. It must be GL_FUNC_ADD, GL_FUNC_SUBTRACT, GL_FUNC_REVERSE_SUBTRACT, GL_MIN, GL_MAX.
			/// </para>
			/// </param>
			//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glBlendEquationSeparateOES")]
#if NET45
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
			public static
						void BlendEquationSeparate(System.Graphics.ES11.All modeRGB, System.Graphics.ES11.All modeAlpha) {
				Delegates.glBlendEquationSeparateOES((System.Graphics.ES11.All) modeRGB, (System.Graphics.ES11.All) modeAlpha);
			}


			/// <summary>[requires: 1.1]
			/// Specify pixel arithmetic for RGB and alpha components separately
			/// </summary>
			/// <param name="srcRGB">
			/// <para>
			/// Specifies how the red, green, and blue blending factors are computed. The initial value is GL_ONE.
			/// </para>
			/// </param>
			/// <param name="dstRGB">
			/// <para>
			/// Specifies how the red, green, and blue destination blending factors are computed. The initial value is GL_ZERO.
			/// </para>
			/// </param>
			/// <param name="srcAlpha">
			/// <para>
			/// Specified how the alpha source blending factor is computed. The initial value is GL_ONE.
			/// </para>
			/// </param>
			/// <param name="dstAlpha">
			/// <para>
			/// Specified how the alpha destination blending factor is computed. The initial value is GL_ZERO.
			/// </para>
			/// </param>
			//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glBlendFuncSeparateOES")]
#if NET45
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
			public static
						void BlendFuncSeparate(System.Graphics.ES11.All srcRGB, System.Graphics.ES11.All dstRGB, System.Graphics.ES11.All srcAlpha, System.Graphics.ES11.All dstAlpha) {
				Delegates.glBlendFuncSeparateOES((System.Graphics.ES11.All) srcRGB, (System.Graphics.ES11.All) dstRGB, (System.Graphics.ES11.All) srcAlpha, (System.Graphics.ES11.All) dstAlpha);
			}


			/// <summary>[requires: 1.1]
			/// Check the completeness status of a framebuffer
			/// </summary>
			/// <param name="target">
			/// <para>
			/// Specify the target of the framebuffer completeness check.
			/// </para>
			/// </param>
			//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glCheckFramebufferStatusOES")]
#if NET45
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
			public static
						System.Graphics.ES11.All CheckFramebufferStatus(System.Graphics.ES11.All target) {
				return Delegates.glCheckFramebufferStatusOES((System.Graphics.ES11.All) target);
			}

			/// <summary>[requires: 1.1]</summary>
			//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glClearColorxOES")]
#if NET45
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
			public static
						void ClearColorx(int red, int green, int blue, int alpha) {
				Delegates.glClearColorxOES((int) red, (int) green, (int) blue, (int) alpha);
			}


			/// <summary>[requires: 1.1]
			/// Specify the clear value for the depth buffer
			/// </summary>
			/// <param name="depth">
			/// <para>
			/// Specifies the depth value used when the depth buffer is cleared. The initial value is 1.
			/// </para>
			/// </param>
			//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glClearDepthfOES")]
#if NET45
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
			public static
						void ClearDepth(Single depth) {
				Delegates.glClearDepthfOES((Single) depth);
			}

			/// <summary>[requires: 1.1]</summary>
			//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glClearDepthxOES")]
#if NET45
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
			public static
						void ClearDepthx(int depth) {
				Delegates.glClearDepthxOES((int) depth);
			}


			/// <summary>[requires: 1.1]
			/// Specify a plane against which all geometry is clipped
			/// </summary>
			/// <param name="plane">
			/// <para>
			/// Specifies which clipping plane is being positioned. Symbolic names of the form GL_CLIP_PLANEi, where i is an integer between 0 and GL_MAX_CLIP_PLANES - 1, are accepted.
			/// </para>
			/// </param>
			/// <param name="equation">
			/// <para>
			/// Specifies the address of an array of four double-precision floating-point values. These values are interpreted as a plane equation.
			/// </para>
			/// </param>
			//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glClipPlanefOES")]
#if NET45
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
			public static
						void ClipPlane(System.Graphics.ES11.All plane, Single[] equation) {
				unsafe
				{
					fixed (Single* equation_ptr = equation) {
						Delegates.glClipPlanefOES((System.Graphics.ES11.All) plane, (Single*) equation_ptr);
					}
				}
			}


			/// <summary>[requires: 1.1]
			/// Specify a plane against which all geometry is clipped
			/// </summary>
			/// <param name="plane">
			/// <para>
			/// Specifies which clipping plane is being positioned. Symbolic names of the form GL_CLIP_PLANEi, where i is an integer between 0 and GL_MAX_CLIP_PLANES - 1, are accepted.
			/// </para>
			/// </param>
			/// <param name="equation">
			/// <para>
			/// Specifies the address of an array of four double-precision floating-point values. These values are interpreted as a plane equation.
			/// </para>
			/// </param>
			//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glClipPlanefOES")]
#if NET45
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
			public static
						void ClipPlane(System.Graphics.ES11.All plane, ref Single equation) {
				unsafe
				{
					fixed (Single* equation_ptr = &equation) {
						Delegates.glClipPlanefOES((System.Graphics.ES11.All) plane, (Single*) equation_ptr);
					}
				}
			}


			/// <summary>[requires: 1.1]
			/// Specify a plane against which all geometry is clipped
			/// </summary>
			/// <param name="plane">
			/// <para>
			/// Specifies which clipping plane is being positioned. Symbolic names of the form GL_CLIP_PLANEi, where i is an integer between 0 and GL_MAX_CLIP_PLANES - 1, are accepted.
			/// </para>
			/// </param>
			/// <param name="equation">
			/// <para>
			/// Specifies the address of an array of four double-precision floating-point values. These values are interpreted as a plane equation.
			/// </para>
			/// </param>
			[System.CLSCompliant(false)]
			//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glClipPlanefOES")]
#if NET45
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
			public static
			unsafe void ClipPlane(System.Graphics.ES11.All plane, Single* equation) {
				Delegates.glClipPlanefOES((System.Graphics.ES11.All) plane, (Single*) equation);
			}

			/// <summary>[requires: 1.1]</summary>
			//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glClipPlanexOES")]
#if NET45
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
			public static
						void ClipPlanex(System.Graphics.ES11.All plane, int[] equation) {
				unsafe
				{
					fixed (int* equation_ptr = equation) {
						Delegates.glClipPlanexOES((System.Graphics.ES11.All) plane, (int*) equation_ptr);
					}
				}
			}

			/// <summary>[requires: 1.1]</summary>
			//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glClipPlanexOES")]
#if NET45
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
			public static
						void ClipPlanex(System.Graphics.ES11.All plane, ref int equation) {
				unsafe
				{
					fixed (int* equation_ptr = &equation) {
						Delegates.glClipPlanexOES((System.Graphics.ES11.All) plane, (int*) equation_ptr);
					}
				}
			}

			/// <summary>[requires: 1.1]</summary>
			[System.CLSCompliant(false)]
			//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glClipPlanexOES")]
#if NET45
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
			public static
			unsafe void ClipPlanex(System.Graphics.ES11.All plane, int* equation) {
				Delegates.glClipPlanexOES((System.Graphics.ES11.All) plane, (int*) equation);
			}

			/// <summary>[requires: 1.1]</summary>
			//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glColor4xOES")]
#if NET45
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
			public static
						void Color4x(int red, int green, int blue, int alpha) {
				Delegates.glColor4xOES((int) red, (int) green, (int) blue, (int) alpha);
			}

			/// <summary>[requires: 1.1]</summary>
			//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glCurrentPaletteMatrixOES")]
#if NET45
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
			public static
						void CurrentPaletteMatrix(Int32 matrixpaletteindex) {
				Delegates.glCurrentPaletteMatrixOES((UInt32) matrixpaletteindex);
			}

			/// <summary>[requires: 1.1]</summary>
			[System.CLSCompliant(false)]
			//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glCurrentPaletteMatrixOES")]
#if NET45
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
			public static
			void CurrentPaletteMatrix(UInt32 matrixpaletteindex) {
				Delegates.glCurrentPaletteMatrixOES((UInt32) matrixpaletteindex);
			}


			/// <summary>[requires: 1.1]
			/// Delete framebuffer objects
			/// </summary>
			/// <param name="n">
			/// <para>
			/// Specifies the number of framebuffer objects to be deleted.
			/// </para>
			/// </param>
			/// <param name="framebuffers">
			/// <para>
			/// A pointer to an array containing n framebuffer objects to be deleted.
			/// </para>
			/// </param>
			//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glDeleteFramebuffersOES")]
#if NET45
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
			public static
						void DeleteFramebuffers(Int32 n, Int32[] framebuffers) {
				unsafe
				{
					fixed (Int32* framebuffers_ptr = framebuffers) {
						Delegates.glDeleteFramebuffersOES((Int32) n, (UInt32*) framebuffers_ptr);
					}
				}
			}


			/// <summary>[requires: 1.1]
			/// Delete framebuffer objects
			/// </summary>
			/// <param name="n">
			/// <para>
			/// Specifies the number of framebuffer objects to be deleted.
			/// </para>
			/// </param>
			/// <param name="framebuffers">
			/// <para>
			/// A pointer to an array containing n framebuffer objects to be deleted.
			/// </para>
			/// </param>
			//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glDeleteFramebuffersOES")]
#if NET45
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
			public static
						void DeleteFramebuffers(Int32 n, ref Int32 framebuffers) {
				unsafe
				{
					fixed (Int32* framebuffers_ptr = &framebuffers) {
						Delegates.glDeleteFramebuffersOES((Int32) n, (UInt32*) framebuffers_ptr);
					}
				}
			}


			/// <summary>[requires: 1.1]
			/// Delete framebuffer objects
			/// </summary>
			/// <param name="n">
			/// <para>
			/// Specifies the number of framebuffer objects to be deleted.
			/// </para>
			/// </param>
			/// <param name="framebuffers">
			/// <para>
			/// A pointer to an array containing n framebuffer objects to be deleted.
			/// </para>
			/// </param>
			[System.CLSCompliant(false)]
			//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glDeleteFramebuffersOES")]
#if NET45
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
			public static
			unsafe void DeleteFramebuffers(Int32 n, Int32* framebuffers) {
				Delegates.glDeleteFramebuffersOES((Int32) n, (UInt32*) framebuffers);
			}


			/// <summary>[requires: 1.1]
			/// Delete framebuffer objects
			/// </summary>
			/// <param name="n">
			/// <para>
			/// Specifies the number of framebuffer objects to be deleted.
			/// </para>
			/// </param>
			/// <param name="framebuffers">
			/// <para>
			/// A pointer to an array containing n framebuffer objects to be deleted.
			/// </para>
			/// </param>
			[System.CLSCompliant(false)]
			//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glDeleteFramebuffersOES")]
#if NET45
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
			public static
			void DeleteFramebuffers(Int32 n, UInt32[] framebuffers) {
				unsafe
				{
					fixed (UInt32* framebuffers_ptr = framebuffers) {
						Delegates.glDeleteFramebuffersOES((Int32) n, (UInt32*) framebuffers_ptr);
					}
				}
			}


			/// <summary>[requires: 1.1]
			/// Delete framebuffer objects
			/// </summary>
			/// <param name="n">
			/// <para>
			/// Specifies the number of framebuffer objects to be deleted.
			/// </para>
			/// </param>
			/// <param name="framebuffers">
			/// <para>
			/// A pointer to an array containing n framebuffer objects to be deleted.
			/// </para>
			/// </param>
			[System.CLSCompliant(false)]
			//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glDeleteFramebuffersOES")]
#if NET45
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
			public static
			void DeleteFramebuffers(Int32 n, ref UInt32 framebuffers) {
				unsafe
				{
					fixed (UInt32* framebuffers_ptr = &framebuffers) {
						Delegates.glDeleteFramebuffersOES((Int32) n, (UInt32*) framebuffers_ptr);
					}
				}
			}


			/// <summary>[requires: 1.1]
			/// Delete framebuffer objects
			/// </summary>
			/// <param name="n">
			/// <para>
			/// Specifies the number of framebuffer objects to be deleted.
			/// </para>
			/// </param>
			/// <param name="framebuffers">
			/// <para>
			/// A pointer to an array containing n framebuffer objects to be deleted.
			/// </para>
			/// </param>
			[System.CLSCompliant(false)]
			//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glDeleteFramebuffersOES")]
#if NET45
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
			public static
			unsafe void DeleteFramebuffers(Int32 n, UInt32* framebuffers) {
				Delegates.glDeleteFramebuffersOES((Int32) n, (UInt32*) framebuffers);
			}


			/// <summary>[requires: 1.1]
			/// Delete renderbuffer objects
			/// </summary>
			/// <param name="n">
			/// <para>
			/// Specifies the number of renderbuffer objects to be deleted.
			/// </para>
			/// </param>
			/// <param name="renderbuffers">
			/// <para>
			/// A pointer to an array containing n renderbuffer objects to be deleted.
			/// </para>
			/// </param>
			//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glDeleteRenderbuffersOES")]
#if NET45
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
			public static
						void DeleteRenderbuffers(Int32 n, Int32[] renderbuffers) {
				unsafe
				{
					fixed (Int32* renderbuffers_ptr = renderbuffers) {
						Delegates.glDeleteRenderbuffersOES((Int32) n, (UInt32*) renderbuffers_ptr);
					}
				}
			}


			/// <summary>[requires: 1.1]
			/// Delete renderbuffer objects
			/// </summary>
			/// <param name="n">
			/// <para>
			/// Specifies the number of renderbuffer objects to be deleted.
			/// </para>
			/// </param>
			/// <param name="renderbuffers">
			/// <para>
			/// A pointer to an array containing n renderbuffer objects to be deleted.
			/// </para>
			/// </param>
			//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glDeleteRenderbuffersOES")]
#if NET45
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
			public static
						void DeleteRenderbuffers(Int32 n, ref Int32 renderbuffers) {
				unsafe
				{
					fixed (Int32* renderbuffers_ptr = &renderbuffers) {
						Delegates.glDeleteRenderbuffersOES((Int32) n, (UInt32*) renderbuffers_ptr);
					}
				}
			}


			/// <summary>[requires: 1.1]
			/// Delete renderbuffer objects
			/// </summary>
			/// <param name="n">
			/// <para>
			/// Specifies the number of renderbuffer objects to be deleted.
			/// </para>
			/// </param>
			/// <param name="renderbuffers">
			/// <para>
			/// A pointer to an array containing n renderbuffer objects to be deleted.
			/// </para>
			/// </param>
			[System.CLSCompliant(false)]
			//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glDeleteRenderbuffersOES")]
#if NET45
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
			public static
			unsafe void DeleteRenderbuffers(Int32 n, Int32* renderbuffers) {
				Delegates.glDeleteRenderbuffersOES((Int32) n, (UInt32*) renderbuffers);
			}


			/// <summary>[requires: 1.1]
			/// Delete renderbuffer objects
			/// </summary>
			/// <param name="n">
			/// <para>
			/// Specifies the number of renderbuffer objects to be deleted.
			/// </para>
			/// </param>
			/// <param name="renderbuffers">
			/// <para>
			/// A pointer to an array containing n renderbuffer objects to be deleted.
			/// </para>
			/// </param>
			[System.CLSCompliant(false)]
			//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glDeleteRenderbuffersOES")]
#if NET45
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
			public static
			void DeleteRenderbuffers(Int32 n, UInt32[] renderbuffers) {
				unsafe
				{
					fixed (UInt32* renderbuffers_ptr = renderbuffers) {
						Delegates.glDeleteRenderbuffersOES((Int32) n, (UInt32*) renderbuffers_ptr);
					}
				}
			}


			/// <summary>[requires: 1.1]
			/// Delete renderbuffer objects
			/// </summary>
			/// <param name="n">
			/// <para>
			/// Specifies the number of renderbuffer objects to be deleted.
			/// </para>
			/// </param>
			/// <param name="renderbuffers">
			/// <para>
			/// A pointer to an array containing n renderbuffer objects to be deleted.
			/// </para>
			/// </param>
			[System.CLSCompliant(false)]
			//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glDeleteRenderbuffersOES")]
#if NET45
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
			public static
			void DeleteRenderbuffers(Int32 n, ref UInt32 renderbuffers) {
				unsafe
				{
					fixed (UInt32* renderbuffers_ptr = &renderbuffers) {
						Delegates.glDeleteRenderbuffersOES((Int32) n, (UInt32*) renderbuffers_ptr);
					}
				}
			}


			/// <summary>[requires: 1.1]
			/// Delete renderbuffer objects
			/// </summary>
			/// <param name="n">
			/// <para>
			/// Specifies the number of renderbuffer objects to be deleted.
			/// </para>
			/// </param>
			/// <param name="renderbuffers">
			/// <para>
			/// A pointer to an array containing n renderbuffer objects to be deleted.
			/// </para>
			/// </param>
			[System.CLSCompliant(false)]
			//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glDeleteRenderbuffersOES")]
#if NET45
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
			public static
			unsafe void DeleteRenderbuffers(Int32 n, UInt32* renderbuffers) {
				Delegates.glDeleteRenderbuffersOES((Int32) n, (UInt32*) renderbuffers);
			}


			/// <summary>[requires: 1.1]
			/// Specify mapping of depth values from normalized device coordinates to window coordinates
			/// </summary>
			/// <param name="zNear">
			/// <para>
			/// Specifies the mapping of the near clipping plane to window coordinates. The initial value is 0.
			/// </para>
			/// </param>
			/// <param name="zFar">
			/// <para>
			/// Specifies the mapping of the far clipping plane to window coordinates. The initial value is 1.
			/// </para>
			/// </param>
			//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glDepthRangefOES")]
#if NET45
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
			public static
						void DepthRange(Single zNear, Single zFar) {
				Delegates.glDepthRangefOES((Single) zNear, (Single) zFar);
			}

			/// <summary>[requires: 1.1]</summary>
			//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glDepthRangexOES")]
#if NET45
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
			public static
						void DepthRangex(int zNear, int zFar) {
				Delegates.glDepthRangexOES((int) zNear, (int) zFar);
			}

			/// <summary>[requires: 1.1]</summary>
			//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glDrawTexfOES")]
#if NET45
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
			public static
						void DrawTex(Single x, Single y, Single z, Single width, Single height) {
				Delegates.glDrawTexfOES((Single) x, (Single) y, (Single) z, (Single) width, (Single) height);
			}

			/// <summary>[requires: 1.1]</summary>
			//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glDrawTexfvOES")]
#if NET45
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
			public static
						void DrawTex(Single[] coords) {
				unsafe
				{
					fixed (Single* coords_ptr = coords) {
						Delegates.glDrawTexfvOES((Single*) coords_ptr);
					}
				}
			}

			/// <summary>[requires: 1.1]</summary>
			//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glDrawTexfvOES")]
#if NET45
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
			public static
						void DrawTex(ref Single coords) {
				unsafe
				{
					fixed (Single* coords_ptr = &coords) {
						Delegates.glDrawTexfvOES((Single*) coords_ptr);
					}
				}
			}

			/// <summary>[requires: 1.1]</summary>
			[System.CLSCompliant(false)]
			//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glDrawTexfvOES")]
#if NET45
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
			public static
			unsafe void DrawTex(Single* coords) {
				Delegates.glDrawTexfvOES((Single*) coords);
			}

			/// <summary>[requires: 1.1]</summary>
			//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glDrawTexiOES")]
#if NET45
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
			public static
						void DrawTex(Int32 x, Int32 y, Int32 z, Int32 width, Int32 height) {
				Delegates.glDrawTexiOES((Int32) x, (Int32) y, (Int32) z, (Int32) width, (Int32) height);
			}

			/// <summary>[requires: 1.1]</summary>
			//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glDrawTexivOES")]
#if NET45
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
			public static
						void DrawTex(Int32[] coords) {
				unsafe
				{
					fixed (Int32* coords_ptr = coords) {
						Delegates.glDrawTexivOES((Int32*) coords_ptr);
					}
				}
			}

			/// <summary>[requires: 1.1]</summary>
			//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glDrawTexivOES")]
#if NET45
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
			public static
						void DrawTex(ref Int32 coords) {
				unsafe
				{
					fixed (Int32* coords_ptr = &coords) {
						Delegates.glDrawTexivOES((Int32*) coords_ptr);
					}
				}
			}

			/// <summary>[requires: 1.1]</summary>
			[System.CLSCompliant(false)]
			//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glDrawTexivOES")]
#if NET45
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
			public static
			unsafe void DrawTex(Int32* coords) {
				Delegates.glDrawTexivOES((Int32*) coords);
			}

			/// <summary>[requires: 1.1]</summary>
			//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glDrawTexsOES")]
#if NET45
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
			public static
						void DrawTex(Int16 x, Int16 y, Int16 z, Int16 width, Int16 height) {
				Delegates.glDrawTexsOES((Int16) x, (Int16) y, (Int16) z, (Int16) width, (Int16) height);
			}

			/// <summary>[requires: 1.1]</summary>
			//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glDrawTexsvOES")]
#if NET45
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
			public static
						void DrawTex(Int16[] coords) {
				unsafe
				{
					fixed (Int16* coords_ptr = coords) {
						Delegates.glDrawTexsvOES((Int16*) coords_ptr);
					}
				}
			}

			/// <summary>[requires: 1.1]</summary>
			//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glDrawTexsvOES")]
#if NET45
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
			public static
						void DrawTex(ref Int16 coords) {
				unsafe
				{
					fixed (Int16* coords_ptr = &coords) {
						Delegates.glDrawTexsvOES((Int16*) coords_ptr);
					}
				}
			}

			/// <summary>[requires: 1.1]</summary>
			[System.CLSCompliant(false)]
			//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glDrawTexsvOES")]
#if NET45
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
			public static
			unsafe void DrawTex(Int16* coords) {
				Delegates.glDrawTexsvOES((Int16*) coords);
			}

			/// <summary>[requires: 1.1]</summary>
			//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glDrawTexxOES")]
#if NET45
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
			public static
						void DrawTexx(int x, int y, int z, int width, int height) {
				Delegates.glDrawTexxOES((int) x, (int) y, (int) z, (int) width, (int) height);
			}

			/// <summary>[requires: 1.1]</summary>
			//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glDrawTexxvOES")]
#if NET45
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
			public static
						void DrawTexx(int[] coords) {
				unsafe
				{
					fixed (int* coords_ptr = coords) {
						Delegates.glDrawTexxvOES((int*) coords_ptr);
					}
				}
			}

			/// <summary>[requires: 1.1]</summary>
			//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glDrawTexxvOES")]
#if NET45
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
			public static
						void DrawTexx(ref int coords) {
				unsafe
				{
					fixed (int* coords_ptr = &coords) {
						Delegates.glDrawTexxvOES((int*) coords_ptr);
					}
				}
			}

			/// <summary>[requires: 1.1]</summary>
			[System.CLSCompliant(false)]
			//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glDrawTexxvOES")]
#if NET45
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
			public static
			unsafe void DrawTexx(int* coords) {
				Delegates.glDrawTexxvOES((int*) coords);
			}

			/// <summary>[requires: 1.1]</summary>
			//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glEGLImageTargetRenderbufferStorageOES")]
#if NET45
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
			public static
						void EGLImageTargetRenderbufferStorage(System.Graphics.ES11.All target, IntPtr image) {
				Delegates.glEGLImageTargetRenderbufferStorageOES((System.Graphics.ES11.All) target, (IntPtr) image);
			}

			/// <summary>[requires: 1.1]</summary>
			//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glEGLImageTargetTexture2DOES")]
#if NET45
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
			public static
						void EGLImageTargetTexture2D(System.Graphics.ES11.All target, IntPtr image) {
				Delegates.glEGLImageTargetTexture2DOES((System.Graphics.ES11.All) target, (IntPtr) image);
			}

			/// <summary>[requires: 1.1]</summary>
			//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glFogxOES")]
#if NET45
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
			public static
						void Fogx(System.Graphics.ES11.All pname, int param) {
				Delegates.glFogxOES((System.Graphics.ES11.All) pname, (int) param);
			}

			/// <summary>[requires: 1.1]</summary>
			//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glFogxvOES")]
#if NET45
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
			public static
						void Fogx(System.Graphics.ES11.All pname, int[] @params) {
				unsafe
				{
					fixed (int* @params_ptr = @params) {
						Delegates.glFogxvOES((System.Graphics.ES11.All) pname, (int*) @params_ptr);
					}
				}
			}

			/// <summary>[requires: 1.1]</summary>
			[System.CLSCompliant(false)]
			//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glFogxvOES")]
#if NET45
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
			public static
			unsafe void Fogx(System.Graphics.ES11.All pname, int* @params) {
				Delegates.glFogxvOES((System.Graphics.ES11.All) pname, (int*) @params);
			}


			/// <summary>[requires: 1.1]
			/// Attach a renderbuffer as a logical buffer to the currently bound framebuffer object
			/// </summary>
			/// <param name="target">
			/// <para>
			/// Specifies the framebuffer target. target must be GL_DRAW_FRAMEBUFFER, GL_READ_FRAMEBUFFER, or GL_FRAMEBUFFER. GL_FRAMEBUFFER is equivalent to GL_DRAW_FRAMEBUFFER.
			/// </para>
			/// </param>
			/// <param name="attachment">
			/// <para>
			/// Specifies the attachment point of the framebuffer.
			/// </para>
			/// </param>
			/// <param name="renderbuffertarget">
			/// <para>
			/// Specifies the renderbuffer target and must be GL_RENDERBUFFER.
			/// </para>
			/// </param>
			/// <param name="renderbuffer">
			/// <para>
			/// Specifies the name of an existing renderbuffer object of type renderbuffertarget to attach.
			/// </para>
			/// </param>
			//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glFramebufferRenderbufferOES")]
#if NET45
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
			public static
						void FramebufferRenderbuffer(System.Graphics.ES11.All target, System.Graphics.ES11.All attachment, System.Graphics.ES11.All renderbuffertarget, Int32 renderbuffer) {
				Delegates.glFramebufferRenderbufferOES((System.Graphics.ES11.All) target, (System.Graphics.ES11.All) attachment, (System.Graphics.ES11.All) renderbuffertarget, (UInt32) renderbuffer);
			}


			/// <summary>[requires: 1.1]
			/// Attach a renderbuffer as a logical buffer to the currently bound framebuffer object
			/// </summary>
			/// <param name="target">
			/// <para>
			/// Specifies the framebuffer target. target must be GL_DRAW_FRAMEBUFFER, GL_READ_FRAMEBUFFER, or GL_FRAMEBUFFER. GL_FRAMEBUFFER is equivalent to GL_DRAW_FRAMEBUFFER.
			/// </para>
			/// </param>
			/// <param name="attachment">
			/// <para>
			/// Specifies the attachment point of the framebuffer.
			/// </para>
			/// </param>
			/// <param name="renderbuffertarget">
			/// <para>
			/// Specifies the renderbuffer target and must be GL_RENDERBUFFER.
			/// </para>
			/// </param>
			/// <param name="renderbuffer">
			/// <para>
			/// Specifies the name of an existing renderbuffer object of type renderbuffertarget to attach.
			/// </para>
			/// </param>
			[System.CLSCompliant(false)]
			//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glFramebufferRenderbufferOES")]
#if NET45
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
			public static
			void FramebufferRenderbuffer(System.Graphics.ES11.All target, System.Graphics.ES11.All attachment, System.Graphics.ES11.All renderbuffertarget, UInt32 renderbuffer) {
				Delegates.glFramebufferRenderbufferOES((System.Graphics.ES11.All) target, (System.Graphics.ES11.All) attachment, (System.Graphics.ES11.All) renderbuffertarget, (UInt32) renderbuffer);
			}

			/// <summary>[requires: 1.1]</summary>
			//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glFramebufferTexture2DOES")]
#if NET45
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
			public static
						void FramebufferTexture2D(System.Graphics.ES11.All target, System.Graphics.ES11.All attachment, System.Graphics.ES11.All textarget, Int32 texture, Int32 level) {
				Delegates.glFramebufferTexture2DOES((System.Graphics.ES11.All) target, (System.Graphics.ES11.All) attachment, (System.Graphics.ES11.All) textarget, (UInt32) texture, (Int32) level);
			}

			/// <summary>[requires: 1.1]</summary>
			[System.CLSCompliant(false)]
			//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glFramebufferTexture2DOES")]
#if NET45
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
			public static
			void FramebufferTexture2D(System.Graphics.ES11.All target, System.Graphics.ES11.All attachment, System.Graphics.ES11.All textarget, UInt32 texture, Int32 level) {
				Delegates.glFramebufferTexture2DOES((System.Graphics.ES11.All) target, (System.Graphics.ES11.All) attachment, (System.Graphics.ES11.All) textarget, (UInt32) texture, (Int32) level);
			}


			/// <summary>[requires: 1.1]
			/// Multiply the current matrix by a perspective matrix
			/// </summary>
			//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glFrustumfOES")]
#if NET45
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
			public static
						void Frustum(Single left, Single right, Single bottom, Single top, Single zNear, Single zFar) {
				Delegates.glFrustumfOES((Single) left, (Single) right, (Single) bottom, (Single) top, (Single) zNear, (Single) zFar);
			}

			/// <summary>[requires: 1.1]</summary>
			//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glFrustumxOES")]
#if NET45
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
			public static
						void Frustumx(int left, int right, int bottom, int top, int zNear, int zFar) {
				Delegates.glFrustumxOES((int) left, (int) right, (int) bottom, (int) top, (int) zNear, (int) zFar);
			}


			/// <summary>[requires: 1.1]
			/// Generate mipmaps for a specified texture target
			/// </summary>
			/// <param name="target">
			/// <para>
			/// Specifies the target to which the texture whose mimaps to generate is bound. target must be GL_TEXTURE_1D, GL_TEXTURE_2D, GL_TEXTURE_3D, GL_TEXTURE_1D_ARRAY, GL_TEXTURE_2D_ARRAY or GL_TEXTURE_CUBE_MAP.
			/// </para>
			/// </param>
			//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glGenerateMipmapOES")]
#if NET45
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
			public static
						void GenerateMipmap(System.Graphics.ES11.All target) {
				Delegates.glGenerateMipmapOES((System.Graphics.ES11.All) target);
			}


			/// <summary>[requires: 1.1]
			/// Generate framebuffer object names
			/// </summary>
			/// <param name="n">
			/// <para>
			/// Specifies the number of framebuffer object names to generate.
			/// </para>
			/// </param>
			/// <param name="framebuffers">
			/// <para>
			/// Specifies an array in which the generated framebuffer object names are stored.
			/// </para>
			/// </param>
			//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glGenFramebuffersOES")]
#if NET45
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
			public static
						void GenFramebuffers(Int32 n, Int32[] framebuffers) {
				unsafe
				{
					fixed (Int32* framebuffers_ptr = framebuffers) {
						Delegates.glGenFramebuffersOES((Int32) n, (UInt32*) framebuffers_ptr);
					}
				}
			}


			/// <summary>[requires: 1.1]
			/// Generate framebuffer object names
			/// </summary>
			/// <param name="n">
			/// <para>
			/// Specifies the number of framebuffer object names to generate.
			/// </para>
			/// </param>
			/// <param name="framebuffers">
			/// <para>
			/// Specifies an array in which the generated framebuffer object names are stored.
			/// </para>
			/// </param>
			//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glGenFramebuffersOES")]
#if NET45
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
			public static
						void GenFramebuffers(Int32 n, ref Int32 framebuffers) {
				unsafe
				{
					fixed (Int32* framebuffers_ptr = &framebuffers) {
						Delegates.glGenFramebuffersOES((Int32) n, (UInt32*) framebuffers_ptr);
					}
				}
			}


			/// <summary>[requires: 1.1]
			/// Generate framebuffer object names
			/// </summary>
			/// <param name="n">
			/// <para>
			/// Specifies the number of framebuffer object names to generate.
			/// </para>
			/// </param>
			/// <param name="framebuffers">
			/// <para>
			/// Specifies an array in which the generated framebuffer object names are stored.
			/// </para>
			/// </param>
			[System.CLSCompliant(false)]
			//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glGenFramebuffersOES")]
#if NET45
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
			public static
			unsafe void GenFramebuffers(Int32 n, Int32* framebuffers) {
				Delegates.glGenFramebuffersOES((Int32) n, (UInt32*) framebuffers);
			}


			/// <summary>[requires: 1.1]
			/// Generate framebuffer object names
			/// </summary>
			/// <param name="n">
			/// <para>
			/// Specifies the number of framebuffer object names to generate.
			/// </para>
			/// </param>
			/// <param name="framebuffers">
			/// <para>
			/// Specifies an array in which the generated framebuffer object names are stored.
			/// </para>
			/// </param>
			[System.CLSCompliant(false)]
			//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glGenFramebuffersOES")]
#if NET45
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
			public static
			void GenFramebuffers(Int32 n, UInt32[] framebuffers) {
				unsafe
				{
					fixed (UInt32* framebuffers_ptr = framebuffers) {
						Delegates.glGenFramebuffersOES((Int32) n, (UInt32*) framebuffers_ptr);
					}
				}
			}


			/// <summary>[requires: 1.1]
			/// Generate framebuffer object names
			/// </summary>
			/// <param name="n">
			/// <para>
			/// Specifies the number of framebuffer object names to generate.
			/// </para>
			/// </param>
			/// <param name="framebuffers">
			/// <para>
			/// Specifies an array in which the generated framebuffer object names are stored.
			/// </para>
			/// </param>
			[System.CLSCompliant(false)]
			//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glGenFramebuffersOES")]
#if NET45
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
			public static
			void GenFramebuffers(Int32 n, ref UInt32 framebuffers) {
				unsafe
				{
					fixed (UInt32* framebuffers_ptr = &framebuffers) {
						Delegates.glGenFramebuffersOES((Int32) n, (UInt32*) framebuffers_ptr);
					}
				}
			}


			/// <summary>[requires: 1.1]
			/// Generate framebuffer object names
			/// </summary>
			/// <param name="n">
			/// <para>
			/// Specifies the number of framebuffer object names to generate.
			/// </para>
			/// </param>
			/// <param name="framebuffers">
			/// <para>
			/// Specifies an array in which the generated framebuffer object names are stored.
			/// </para>
			/// </param>
			[System.CLSCompliant(false)]
			//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glGenFramebuffersOES")]
#if NET45
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
			public static
			unsafe void GenFramebuffers(Int32 n, UInt32* framebuffers) {
				Delegates.glGenFramebuffersOES((Int32) n, (UInt32*) framebuffers);
			}


			/// <summary>[requires: 1.1]
			/// Generate renderbuffer object names
			/// </summary>
			/// <param name="n">
			/// <para>
			/// Specifies the number of renderbuffer object names to generate.
			/// </para>
			/// </param>
			/// <param name="renderbuffers">
			/// <para>
			/// Specifies an array in which the generated renderbuffer object names are stored.
			/// </para>
			/// </param>
			//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glGenRenderbuffersOES")]
#if NET45
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
			public static
						void GenRenderbuffers(Int32 n, Int32[] renderbuffers) {
				unsafe
				{
					fixed (Int32* renderbuffers_ptr = renderbuffers) {
						Delegates.glGenRenderbuffersOES((Int32) n, (UInt32*) renderbuffers_ptr);
					}
				}
			}


			/// <summary>[requires: 1.1]
			/// Generate renderbuffer object names
			/// </summary>
			/// <param name="n">
			/// <para>
			/// Specifies the number of renderbuffer object names to generate.
			/// </para>
			/// </param>
			/// <param name="renderbuffers">
			/// <para>
			/// Specifies an array in which the generated renderbuffer object names are stored.
			/// </para>
			/// </param>
			//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glGenRenderbuffersOES")]
#if NET45
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
			public static
						void GenRenderbuffers(Int32 n, ref Int32 renderbuffers) {
				unsafe
				{
					fixed (Int32* renderbuffers_ptr = &renderbuffers) {
						Delegates.glGenRenderbuffersOES((Int32) n, (UInt32*) renderbuffers_ptr);
					}
				}
			}


			/// <summary>[requires: 1.1]
			/// Generate renderbuffer object names
			/// </summary>
			/// <param name="n">
			/// <para>
			/// Specifies the number of renderbuffer object names to generate.
			/// </para>
			/// </param>
			/// <param name="renderbuffers">
			/// <para>
			/// Specifies an array in which the generated renderbuffer object names are stored.
			/// </para>
			/// </param>
			[System.CLSCompliant(false)]
			//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glGenRenderbuffersOES")]
#if NET45
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
			public static
			unsafe void GenRenderbuffers(Int32 n, Int32* renderbuffers) {
				Delegates.glGenRenderbuffersOES((Int32) n, (UInt32*) renderbuffers);
			}


			/// <summary>[requires: 1.1]
			/// Generate renderbuffer object names
			/// </summary>
			/// <param name="n">
			/// <para>
			/// Specifies the number of renderbuffer object names to generate.
			/// </para>
			/// </param>
			/// <param name="renderbuffers">
			/// <para>
			/// Specifies an array in which the generated renderbuffer object names are stored.
			/// </para>
			/// </param>
			[System.CLSCompliant(false)]
			//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glGenRenderbuffersOES")]
#if NET45
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
			public static
			void GenRenderbuffers(Int32 n, UInt32[] renderbuffers) {
				unsafe
				{
					fixed (UInt32* renderbuffers_ptr = renderbuffers) {
						Delegates.glGenRenderbuffersOES((Int32) n, (UInt32*) renderbuffers_ptr);
					}
				}
			}


			/// <summary>[requires: 1.1]
			/// Generate renderbuffer object names
			/// </summary>
			/// <param name="n">
			/// <para>
			/// Specifies the number of renderbuffer object names to generate.
			/// </para>
			/// </param>
			/// <param name="renderbuffers">
			/// <para>
			/// Specifies an array in which the generated renderbuffer object names are stored.
			/// </para>
			/// </param>
			[System.CLSCompliant(false)]
			//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glGenRenderbuffersOES")]
#if NET45
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
			public static
			void GenRenderbuffers(Int32 n, ref UInt32 renderbuffers) {
				unsafe
				{
					fixed (UInt32* renderbuffers_ptr = &renderbuffers) {
						Delegates.glGenRenderbuffersOES((Int32) n, (UInt32*) renderbuffers_ptr);
					}
				}
			}


			/// <summary>[requires: 1.1]
			/// Generate renderbuffer object names
			/// </summary>
			/// <param name="n">
			/// <para>
			/// Specifies the number of renderbuffer object names to generate.
			/// </para>
			/// </param>
			/// <param name="renderbuffers">
			/// <para>
			/// Specifies an array in which the generated renderbuffer object names are stored.
			/// </para>
			/// </param>
			[System.CLSCompliant(false)]
			//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glGenRenderbuffersOES")]
#if NET45
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
			public static
			unsafe void GenRenderbuffers(Int32 n, UInt32* renderbuffers) {
				Delegates.glGenRenderbuffersOES((Int32) n, (UInt32*) renderbuffers);
			}

			/// <summary>[requires: 1.1]</summary>
			//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glGetBufferPointervOES")]
#if NET45
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
			public static
						void GetBufferPointer(System.Graphics.ES11.All target, System.Graphics.ES11.All pname, IntPtr @params) {
				Delegates.glGetBufferPointervOES((System.Graphics.ES11.All) target, (System.Graphics.ES11.All) pname, (IntPtr) @params);
			}

			/// <summary>[requires: 1.1]</summary>
			//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glGetBufferPointervOES")]
#if NET45
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
			public static
						void GetBufferPointer<T2>(System.Graphics.ES11.All target, System.Graphics.ES11.All pname, [InAttribute, OutAttribute] T2[] @params)
							where T2 : struct {
				GCHandle @params_ptr = GCHandle.Alloc(@params, GCHandleType.Pinned);
				try {
					Delegates.glGetBufferPointervOES((System.Graphics.ES11.All) target, (System.Graphics.ES11.All) pname, (IntPtr) @params_ptr.AddrOfPinnedObject());
				} finally {
					@params_ptr.Free();
				}
			}

			/// <summary>[requires: 1.1]</summary>
			//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glGetBufferPointervOES")]
#if NET45
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
			public static
						void GetBufferPointer<T2>(System.Graphics.ES11.All target, System.Graphics.ES11.All pname, [InAttribute, OutAttribute] T2[,] @params)
							where T2 : struct {
				GCHandle @params_ptr = GCHandle.Alloc(@params, GCHandleType.Pinned);
				try {
					Delegates.glGetBufferPointervOES((System.Graphics.ES11.All) target, (System.Graphics.ES11.All) pname, (IntPtr) @params_ptr.AddrOfPinnedObject());
				} finally {
					@params_ptr.Free();
				}
			}

			/// <summary>[requires: 1.1]</summary>
			//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glGetBufferPointervOES")]
#if NET45
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
			public static
						void GetBufferPointer<T2>(System.Graphics.ES11.All target, System.Graphics.ES11.All pname, [InAttribute, OutAttribute] T2[,,] @params)
							where T2 : struct {
				GCHandle @params_ptr = GCHandle.Alloc(@params, GCHandleType.Pinned);
				try {
					Delegates.glGetBufferPointervOES((System.Graphics.ES11.All) target, (System.Graphics.ES11.All) pname, (IntPtr) @params_ptr.AddrOfPinnedObject());
				} finally {
					@params_ptr.Free();
				}
			}

			/// <summary>[requires: 1.1]</summary>
			//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glGetBufferPointervOES")]
#if NET45
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
			public static
						void GetBufferPointer<T2>(System.Graphics.ES11.All target, System.Graphics.ES11.All pname, [InAttribute, OutAttribute] ref T2 @params)
							where T2 : struct {
				GCHandle @params_ptr = GCHandle.Alloc(@params, GCHandleType.Pinned);
				try {
					Delegates.glGetBufferPointervOES((System.Graphics.ES11.All) target, (System.Graphics.ES11.All) pname, (IntPtr) @params_ptr.AddrOfPinnedObject());
					@params = (T2) @params_ptr.Target;
				} finally {
					@params_ptr.Free();
				}
			}


			/// <summary>[requires: 1.1]
			/// Return the coefficients of the specified clipping plane
			/// </summary>
			/// <param name="pname">
			/// <para>
			/// Specifies a clipping plane. The number of clipping planes depends on the implementation, but at least six clipping planes are supported. They are identified by symbolic names of the form GL_CLIP_PLANE where i ranges from 0 to the value of GL_MAX_CLIP_PLANES - 1.
			/// </para>
			/// </param>
			/// <param name="eqn">
			/// <para>
			/// Returns four double-precision values that are the coefficients of the plane equation of plane in eye coordinates. The initial value is (0, 0, 0, 0).
			/// </para>
			/// </param>
			//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glGetClipPlanefOES")]
#if NET45
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
			public static
						void GetClipPlane(System.Graphics.ES11.All pname, Single[] eqn) {
				unsafe
				{
					fixed (Single* eqn_ptr = eqn) {
						Delegates.glGetClipPlanefOES((System.Graphics.ES11.All) pname, (Single*) eqn_ptr);
					}
				}
			}


			/// <summary>[requires: 1.1]
			/// Return the coefficients of the specified clipping plane
			/// </summary>
			/// <param name="pname">
			/// <para>
			/// Specifies a clipping plane. The number of clipping planes depends on the implementation, but at least six clipping planes are supported. They are identified by symbolic names of the form GL_CLIP_PLANE where i ranges from 0 to the value of GL_MAX_CLIP_PLANES - 1.
			/// </para>
			/// </param>
			/// <param name="eqn">
			/// <para>
			/// Returns four double-precision values that are the coefficients of the plane equation of plane in eye coordinates. The initial value is (0, 0, 0, 0).
			/// </para>
			/// </param>
			//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glGetClipPlanefOES")]
#if NET45
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
			public static
						void GetClipPlane(System.Graphics.ES11.All pname, ref Single eqn) {
				unsafe
				{
					fixed (Single* eqn_ptr = &eqn) {
						Delegates.glGetClipPlanefOES((System.Graphics.ES11.All) pname, (Single*) eqn_ptr);
					}
				}
			}


			/// <summary>[requires: 1.1]
			/// Return the coefficients of the specified clipping plane
			/// </summary>
			/// <param name="pname">
			/// <para>
			/// Specifies a clipping plane. The number of clipping planes depends on the implementation, but at least six clipping planes are supported. They are identified by symbolic names of the form GL_CLIP_PLANE where i ranges from 0 to the value of GL_MAX_CLIP_PLANES - 1.
			/// </para>
			/// </param>
			/// <param name="eqn">
			/// <para>
			/// Returns four double-precision values that are the coefficients of the plane equation of plane in eye coordinates. The initial value is (0, 0, 0, 0).
			/// </para>
			/// </param>
			[System.CLSCompliant(false)]
			//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glGetClipPlanefOES")]
#if NET45
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
			public static
			unsafe void GetClipPlane(System.Graphics.ES11.All pname, Single* eqn) {
				Delegates.glGetClipPlanefOES((System.Graphics.ES11.All) pname, (Single*) eqn);
			}

			/// <summary>[requires: 1.1]</summary>
			//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glGetClipPlanexOES")]
#if NET45
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
			public static
						void GetClipPlanex(System.Graphics.ES11.All pname, int[] eqn) {
				unsafe
				{
					fixed (int* eqn_ptr = eqn) {
						Delegates.glGetClipPlanexOES((System.Graphics.ES11.All) pname, (int*) eqn_ptr);
					}
				}
			}

			/// <summary>[requires: 1.1]</summary>
			//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glGetClipPlanexOES")]
#if NET45
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
			public static
						void GetClipPlanex(System.Graphics.ES11.All pname, ref int eqn) {
				unsafe
				{
					fixed (int* eqn_ptr = &eqn) {
						Delegates.glGetClipPlanexOES((System.Graphics.ES11.All) pname, (int*) eqn_ptr);
					}
				}
			}

			/// <summary>[requires: 1.1]</summary>
			[System.CLSCompliant(false)]
			//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glGetClipPlanexOES")]
#if NET45
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
			public static
			unsafe void GetClipPlanex(System.Graphics.ES11.All pname, int* eqn) {
				Delegates.glGetClipPlanexOES((System.Graphics.ES11.All) pname, (int*) eqn);
			}

			/// <summary>[requires: 1.1]</summary>
			//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glGetFixedvOES")]
#if NET45
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
			public static
						void GetFixed(System.Graphics.ES11.All pname, int[] @params) {
				unsafe
				{
					fixed (int* @params_ptr = @params) {
						Delegates.glGetFixedvOES((System.Graphics.ES11.All) pname, (int*) @params_ptr);
					}
				}
			}

			/// <summary>[requires: 1.1]</summary>
			//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glGetFixedvOES")]
#if NET45
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
			public static
						void GetFixed(System.Graphics.ES11.All pname, ref int @params) {
				unsafe
				{
					fixed (int* @params_ptr = &@params) {
						Delegates.glGetFixedvOES((System.Graphics.ES11.All) pname, (int*) @params_ptr);
					}
				}
			}

			/// <summary>[requires: 1.1]</summary>
			[System.CLSCompliant(false)]
			//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glGetFixedvOES")]
#if NET45
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
			public static
			unsafe void GetFixed(System.Graphics.ES11.All pname, int* @params) {
				Delegates.glGetFixedvOES((System.Graphics.ES11.All) pname, (int*) @params);
			}


			/// <summary>[requires: 1.1]
			/// Retrieve information about attachments of a bound framebuffer object
			/// </summary>
			/// <param name="target">
			/// <para>
			/// Specifies the target of the query operation.
			/// </para>
			/// </param>
			/// <param name="attachment">
			/// <para>
			/// Specifies the attachment within target
			/// </para>
			/// </param>
			/// <param name="pname">
			/// <para>
			/// Specifies the parameter of attachment to query.
			/// </para>
			/// </param>
			/// <param name="params">
			/// <para>
			/// Specifies the address of a variable receive the value of pname for attachment.
			/// </para>
			/// </param>
			//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glGetFramebufferAttachmentParameterivOES")]
#if NET45
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
			public static
						void GetFramebufferAttachmentParameter(System.Graphics.ES11.All target, System.Graphics.ES11.All attachment, System.Graphics.ES11.All pname, Int32[] @params) {
				unsafe
				{
					fixed (Int32* @params_ptr = @params) {
						Delegates.glGetFramebufferAttachmentParameterivOES((System.Graphics.ES11.All) target, (System.Graphics.ES11.All) attachment, (System.Graphics.ES11.All) pname, (Int32*) @params_ptr);
					}
				}
			}


			/// <summary>[requires: 1.1]
			/// Retrieve information about attachments of a bound framebuffer object
			/// </summary>
			/// <param name="target">
			/// <para>
			/// Specifies the target of the query operation.
			/// </para>
			/// </param>
			/// <param name="attachment">
			/// <para>
			/// Specifies the attachment within target
			/// </para>
			/// </param>
			/// <param name="pname">
			/// <para>
			/// Specifies the parameter of attachment to query.
			/// </para>
			/// </param>
			/// <param name="params">
			/// <para>
			/// Specifies the address of a variable receive the value of pname for attachment.
			/// </para>
			/// </param>
			//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glGetFramebufferAttachmentParameterivOES")]
#if NET45
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
			public static
						void GetFramebufferAttachmentParameter(System.Graphics.ES11.All target, System.Graphics.ES11.All attachment, System.Graphics.ES11.All pname, ref Int32 @params) {
				unsafe
				{
					fixed (Int32* @params_ptr = &@params) {
						Delegates.glGetFramebufferAttachmentParameterivOES((System.Graphics.ES11.All) target, (System.Graphics.ES11.All) attachment, (System.Graphics.ES11.All) pname, (Int32*) @params_ptr);
					}
				}
			}


			/// <summary>[requires: 1.1]
			/// Retrieve information about attachments of a bound framebuffer object
			/// </summary>
			/// <param name="target">
			/// <para>
			/// Specifies the target of the query operation.
			/// </para>
			/// </param>
			/// <param name="attachment">
			/// <para>
			/// Specifies the attachment within target
			/// </para>
			/// </param>
			/// <param name="pname">
			/// <para>
			/// Specifies the parameter of attachment to query.
			/// </para>
			/// </param>
			/// <param name="params">
			/// <para>
			/// Specifies the address of a variable receive the value of pname for attachment.
			/// </para>
			/// </param>
			[System.CLSCompliant(false)]
			//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glGetFramebufferAttachmentParameterivOES")]
#if NET45
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
			public static
			unsafe void GetFramebufferAttachmentParameter(System.Graphics.ES11.All target, System.Graphics.ES11.All attachment, System.Graphics.ES11.All pname, Int32* @params) {
				Delegates.glGetFramebufferAttachmentParameterivOES((System.Graphics.ES11.All) target, (System.Graphics.ES11.All) attachment, (System.Graphics.ES11.All) pname, (Int32*) @params);
			}

			/// <summary>[requires: 1.1]</summary>
			//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glGetLightxvOES")]
#if NET45
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
			public static
						void GetLightx(System.Graphics.ES11.All light, System.Graphics.ES11.All pname, int[] @params) {
				unsafe
				{
					fixed (int* @params_ptr = @params) {
						Delegates.glGetLightxvOES((System.Graphics.ES11.All) light, (System.Graphics.ES11.All) pname, (int*) @params_ptr);
					}
				}
			}

			/// <summary>[requires: 1.1]</summary>
			//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glGetLightxvOES")]
#if NET45
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
			public static
						void GetLightx(System.Graphics.ES11.All light, System.Graphics.ES11.All pname, ref int @params) {
				unsafe
				{
					fixed (int* @params_ptr = &@params) {
						Delegates.glGetLightxvOES((System.Graphics.ES11.All) light, (System.Graphics.ES11.All) pname, (int*) @params_ptr);
					}
				}
			}

			/// <summary>[requires: 1.1]</summary>
			[System.CLSCompliant(false)]
			//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glGetLightxvOES")]
#if NET45
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
			public static
			unsafe void GetLightx(System.Graphics.ES11.All light, System.Graphics.ES11.All pname, int* @params) {
				Delegates.glGetLightxvOES((System.Graphics.ES11.All) light, (System.Graphics.ES11.All) pname, (int*) @params);
			}

			/// <summary>[requires: 1.1]</summary>
			//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glGetMaterialxvOES")]
#if NET45
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
			public static
						void GetMaterialx(System.Graphics.ES11.All face, System.Graphics.ES11.All pname, int[] @params) {
				unsafe
				{
					fixed (int* @params_ptr = @params) {
						Delegates.glGetMaterialxvOES((System.Graphics.ES11.All) face, (System.Graphics.ES11.All) pname, (int*) @params_ptr);
					}
				}
			}

			/// <summary>[requires: 1.1]</summary>
			//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glGetMaterialxvOES")]
#if NET45
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
			public static
						void GetMaterialx(System.Graphics.ES11.All face, System.Graphics.ES11.All pname, ref int @params) {
				unsafe
				{
					fixed (int* @params_ptr = &@params) {
						Delegates.glGetMaterialxvOES((System.Graphics.ES11.All) face, (System.Graphics.ES11.All) pname, (int*) @params_ptr);
					}
				}
			}

			/// <summary>[requires: 1.1]</summary>
			[System.CLSCompliant(false)]
			//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glGetMaterialxvOES")]
#if NET45
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
			public static
			unsafe void GetMaterialx(System.Graphics.ES11.All face, System.Graphics.ES11.All pname, int* @params) {
				Delegates.glGetMaterialxvOES((System.Graphics.ES11.All) face, (System.Graphics.ES11.All) pname, (int*) @params);
			}


			/// <summary>[requires: 1.1]
			/// Retrieve information about a bound renderbuffer object
			/// </summary>
			/// <param name="target">
			/// <para>
			/// Specifies the target of the query operation. target must be GL_RENDERBUFFER.
			/// </para>
			/// </param>
			/// <param name="pname">
			/// <para>
			/// Specifies the parameter whose value to retrieve from the renderbuffer bound to target.
			/// </para>
			/// </param>
			/// <param name="params">
			/// <para>
			/// Specifies the address of an array to receive the value of the queried parameter.
			/// </para>
			/// </param>
			//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glGetRenderbufferParameterivOES")]
#if NET45
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
			public static
						void GetRenderbufferParameter(System.Graphics.ES11.All target, System.Graphics.ES11.All pname, Int32[] @params) {
				unsafe
				{
					fixed (Int32* @params_ptr = @params) {
						Delegates.glGetRenderbufferParameterivOES((System.Graphics.ES11.All) target, (System.Graphics.ES11.All) pname, (Int32*) @params_ptr);
					}
				}
			}


			/// <summary>[requires: 1.1]
			/// Retrieve information about a bound renderbuffer object
			/// </summary>
			/// <param name="target">
			/// <para>
			/// Specifies the target of the query operation. target must be GL_RENDERBUFFER.
			/// </para>
			/// </param>
			/// <param name="pname">
			/// <para>
			/// Specifies the parameter whose value to retrieve from the renderbuffer bound to target.
			/// </para>
			/// </param>
			/// <param name="params">
			/// <para>
			/// Specifies the address of an array to receive the value of the queried parameter.
			/// </para>
			/// </param>
			//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glGetRenderbufferParameterivOES")]
#if NET45
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
			public static
						void GetRenderbufferParameter(System.Graphics.ES11.All target, System.Graphics.ES11.All pname, ref Int32 @params) {
				unsafe
				{
					fixed (Int32* @params_ptr = &@params) {
						Delegates.glGetRenderbufferParameterivOES((System.Graphics.ES11.All) target, (System.Graphics.ES11.All) pname, (Int32*) @params_ptr);
					}
				}
			}


			/// <summary>[requires: 1.1]
			/// Retrieve information about a bound renderbuffer object
			/// </summary>
			/// <param name="target">
			/// <para>
			/// Specifies the target of the query operation. target must be GL_RENDERBUFFER.
			/// </para>
			/// </param>
			/// <param name="pname">
			/// <para>
			/// Specifies the parameter whose value to retrieve from the renderbuffer bound to target.
			/// </para>
			/// </param>
			/// <param name="params">
			/// <para>
			/// Specifies the address of an array to receive the value of the queried parameter.
			/// </para>
			/// </param>
			[System.CLSCompliant(false)]
			//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glGetRenderbufferParameterivOES")]
#if NET45
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
			public static
			unsafe void GetRenderbufferParameter(System.Graphics.ES11.All target, System.Graphics.ES11.All pname, Int32* @params) {
				Delegates.glGetRenderbufferParameterivOES((System.Graphics.ES11.All) target, (System.Graphics.ES11.All) pname, (Int32*) @params);
			}

			/// <summary>[requires: 1.1]</summary>
			//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glGetTexEnvxvOES")]
#if NET45
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
			public static
						void GetTexEnvx(System.Graphics.ES11.All env, System.Graphics.ES11.All pname, int[] @params) {
				unsafe
				{
					fixed (int* @params_ptr = @params) {
						Delegates.glGetTexEnvxvOES((System.Graphics.ES11.All) env, (System.Graphics.ES11.All) pname, (int*) @params_ptr);
					}
				}
			}

			/// <summary>[requires: 1.1]</summary>
			//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glGetTexEnvxvOES")]
#if NET45
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
			public static
						void GetTexEnvx(System.Graphics.ES11.All env, System.Graphics.ES11.All pname, ref int @params) {
				unsafe
				{
					fixed (int* @params_ptr = &@params) {
						Delegates.glGetTexEnvxvOES((System.Graphics.ES11.All) env, (System.Graphics.ES11.All) pname, (int*) @params_ptr);
					}
				}
			}

			/// <summary>[requires: 1.1]</summary>
			[System.CLSCompliant(false)]
			//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glGetTexEnvxvOES")]
#if NET45
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
			public static
			unsafe void GetTexEnvx(System.Graphics.ES11.All env, System.Graphics.ES11.All pname, int* @params) {
				Delegates.glGetTexEnvxvOES((System.Graphics.ES11.All) env, (System.Graphics.ES11.All) pname, (int*) @params);
			}


			/// <summary>[requires: 1.1]
			/// Return texture coordinate generation parameters
			/// </summary>
			/// <param name="coord">
			/// <para>
			/// Specifies a texture coordinate. Must be GL_S, GL_T, GL_R, or GL_Q.
			/// </para>
			/// </param>
			/// <param name="pname">
			/// <para>
			/// Specifies the symbolic name of the value(s) to be returned. Must be either GL_TEXTURE_GEN_MODE or the name of one of the texture generation plane equations: GL_OBJECT_PLANE or GL_EYE_PLANE.
			/// </para>
			/// </param>
			/// <param name="params">
			/// <para>
			/// Returns the requested data.
			/// </para>
			/// </param>
			//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glGetTexGenfvOES")]
#if NET45
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
			public static
						void GetTexGen(System.Graphics.ES11.All coord, System.Graphics.ES11.All pname, Single[] @params) {
				unsafe
				{
					fixed (Single* @params_ptr = @params) {
						Delegates.glGetTexGenfvOES((System.Graphics.ES11.All) coord, (System.Graphics.ES11.All) pname, (Single*) @params_ptr);
					}
				}
			}


			/// <summary>[requires: 1.1]
			/// Return texture coordinate generation parameters
			/// </summary>
			/// <param name="coord">
			/// <para>
			/// Specifies a texture coordinate. Must be GL_S, GL_T, GL_R, or GL_Q.
			/// </para>
			/// </param>
			/// <param name="pname">
			/// <para>
			/// Specifies the symbolic name of the value(s) to be returned. Must be either GL_TEXTURE_GEN_MODE or the name of one of the texture generation plane equations: GL_OBJECT_PLANE or GL_EYE_PLANE.
			/// </para>
			/// </param>
			/// <param name="params">
			/// <para>
			/// Returns the requested data.
			/// </para>
			/// </param>
			//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glGetTexGenfvOES")]
#if NET45
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
			public static
						void GetTexGen(System.Graphics.ES11.All coord, System.Graphics.ES11.All pname, ref Single @params) {
				unsafe
				{
					fixed (Single* @params_ptr = &@params) {
						Delegates.glGetTexGenfvOES((System.Graphics.ES11.All) coord, (System.Graphics.ES11.All) pname, (Single*) @params_ptr);
					}
				}
			}


			/// <summary>[requires: 1.1]
			/// Return texture coordinate generation parameters
			/// </summary>
			/// <param name="coord">
			/// <para>
			/// Specifies a texture coordinate. Must be GL_S, GL_T, GL_R, or GL_Q.
			/// </para>
			/// </param>
			/// <param name="pname">
			/// <para>
			/// Specifies the symbolic name of the value(s) to be returned. Must be either GL_TEXTURE_GEN_MODE or the name of one of the texture generation plane equations: GL_OBJECT_PLANE or GL_EYE_PLANE.
			/// </para>
			/// </param>
			/// <param name="params">
			/// <para>
			/// Returns the requested data.
			/// </para>
			/// </param>
			[System.CLSCompliant(false)]
			//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glGetTexGenfvOES")]
#if NET45
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
			public static
			unsafe void GetTexGen(System.Graphics.ES11.All coord, System.Graphics.ES11.All pname, Single* @params) {
				Delegates.glGetTexGenfvOES((System.Graphics.ES11.All) coord, (System.Graphics.ES11.All) pname, (Single*) @params);
			}


			/// <summary>[requires: 1.1]
			/// Return texture coordinate generation parameters
			/// </summary>
			/// <param name="coord">
			/// <para>
			/// Specifies a texture coordinate. Must be GL_S, GL_T, GL_R, or GL_Q.
			/// </para>
			/// </param>
			/// <param name="pname">
			/// <para>
			/// Specifies the symbolic name of the value(s) to be returned. Must be either GL_TEXTURE_GEN_MODE or the name of one of the texture generation plane equations: GL_OBJECT_PLANE or GL_EYE_PLANE.
			/// </para>
			/// </param>
			/// <param name="params">
			/// <para>
			/// Returns the requested data.
			/// </para>
			/// </param>
			//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glGetTexGenivOES")]
#if NET45
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
			public static
						void GetTexGen(System.Graphics.ES11.All coord, System.Graphics.ES11.All pname, Int32[] @params) {
				unsafe
				{
					fixed (Int32* @params_ptr = @params) {
						Delegates.glGetTexGenivOES((System.Graphics.ES11.All) coord, (System.Graphics.ES11.All) pname, (Int32*) @params_ptr);
					}
				}
			}


			/// <summary>[requires: 1.1]
			/// Return texture coordinate generation parameters
			/// </summary>
			/// <param name="coord">
			/// <para>
			/// Specifies a texture coordinate. Must be GL_S, GL_T, GL_R, or GL_Q.
			/// </para>
			/// </param>
			/// <param name="pname">
			/// <para>
			/// Specifies the symbolic name of the value(s) to be returned. Must be either GL_TEXTURE_GEN_MODE or the name of one of the texture generation plane equations: GL_OBJECT_PLANE or GL_EYE_PLANE.
			/// </para>
			/// </param>
			/// <param name="params">
			/// <para>
			/// Returns the requested data.
			/// </para>
			/// </param>
			//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glGetTexGenivOES")]
#if NET45
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
			public static
						void GetTexGen(System.Graphics.ES11.All coord, System.Graphics.ES11.All pname, ref Int32 @params) {
				unsafe
				{
					fixed (Int32* @params_ptr = &@params) {
						Delegates.glGetTexGenivOES((System.Graphics.ES11.All) coord, (System.Graphics.ES11.All) pname, (Int32*) @params_ptr);
					}
				}
			}


			/// <summary>[requires: 1.1]
			/// Return texture coordinate generation parameters
			/// </summary>
			/// <param name="coord">
			/// <para>
			/// Specifies a texture coordinate. Must be GL_S, GL_T, GL_R, or GL_Q.
			/// </para>
			/// </param>
			/// <param name="pname">
			/// <para>
			/// Specifies the symbolic name of the value(s) to be returned. Must be either GL_TEXTURE_GEN_MODE or the name of one of the texture generation plane equations: GL_OBJECT_PLANE or GL_EYE_PLANE.
			/// </para>
			/// </param>
			/// <param name="params">
			/// <para>
			/// Returns the requested data.
			/// </para>
			/// </param>
			[System.CLSCompliant(false)]
			//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glGetTexGenivOES")]
#if NET45
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
			public static
			unsafe void GetTexGen(System.Graphics.ES11.All coord, System.Graphics.ES11.All pname, Int32* @params) {
				Delegates.glGetTexGenivOES((System.Graphics.ES11.All) coord, (System.Graphics.ES11.All) pname, (Int32*) @params);
			}

			/// <summary>[requires: 1.1]</summary>
			//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glGetTexGenxvOES")]
#if NET45
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
			public static
						void GetTexGenx(System.Graphics.ES11.All coord, System.Graphics.ES11.All pname, int[] @params) {
				unsafe
				{
					fixed (int* @params_ptr = @params) {
						Delegates.glGetTexGenxvOES((System.Graphics.ES11.All) coord, (System.Graphics.ES11.All) pname, (int*) @params_ptr);
					}
				}
			}

			/// <summary>[requires: 1.1]</summary>
			//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glGetTexGenxvOES")]
#if NET45
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
			public static
						void GetTexGenx(System.Graphics.ES11.All coord, System.Graphics.ES11.All pname, ref int @params) {
				unsafe
				{
					fixed (int* @params_ptr = &@params) {
						Delegates.glGetTexGenxvOES((System.Graphics.ES11.All) coord, (System.Graphics.ES11.All) pname, (int*) @params_ptr);
					}
				}
			}

			/// <summary>[requires: 1.1]</summary>
			[System.CLSCompliant(false)]
			//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glGetTexGenxvOES")]
#if NET45
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
			public static
			unsafe void GetTexGenx(System.Graphics.ES11.All coord, System.Graphics.ES11.All pname, int* @params) {
				Delegates.glGetTexGenxvOES((System.Graphics.ES11.All) coord, (System.Graphics.ES11.All) pname, (int*) @params);
			}

			/// <summary>[requires: 1.1]</summary>
			//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glGetTexParameterxvOES")]
#if NET45
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
			public static
						void GetTexParameterx(System.Graphics.ES11.All target, System.Graphics.ES11.All pname, int[] @params) {
				unsafe
				{
					fixed (int* @params_ptr = @params) {
						Delegates.glGetTexParameterxvOES((System.Graphics.ES11.All) target, (System.Graphics.ES11.All) pname, (int*) @params_ptr);
					}
				}
			}

			/// <summary>[requires: 1.1]</summary>
			//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glGetTexParameterxvOES")]
#if NET45
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
			public static
						void GetTexParameterx(System.Graphics.ES11.All target, System.Graphics.ES11.All pname, ref int @params) {
				unsafe
				{
					fixed (int* @params_ptr = &@params) {
						Delegates.glGetTexParameterxvOES((System.Graphics.ES11.All) target, (System.Graphics.ES11.All) pname, (int*) @params_ptr);
					}
				}
			}

			/// <summary>[requires: 1.1]</summary>
			[System.CLSCompliant(false)]
			//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glGetTexParameterxvOES")]
#if NET45
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
			public static
			unsafe void GetTexParameterx(System.Graphics.ES11.All target, System.Graphics.ES11.All pname, int* @params) {
				Delegates.glGetTexParameterxvOES((System.Graphics.ES11.All) target, (System.Graphics.ES11.All) pname, (int*) @params);
			}


			/// <summary>[requires: 1.1]
			/// Determine if a name corresponds to a framebuffer object
			/// </summary>
			/// <param name="framebuffer">
			/// <para>
			/// Specifies a value that may be the name of a framebuffer object.
			/// </para>
			/// </param>
			//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glIsFramebufferOES")]
#if NET45
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
			public static
						bool IsFramebuffer(Int32 framebuffer) {
				return Delegates.glIsFramebufferOES((UInt32) framebuffer);
			}


			/// <summary>[requires: 1.1]
			/// Determine if a name corresponds to a framebuffer object
			/// </summary>
			/// <param name="framebuffer">
			/// <para>
			/// Specifies a value that may be the name of a framebuffer object.
			/// </para>
			/// </param>
			[System.CLSCompliant(false)]
			//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glIsFramebufferOES")]
#if NET45
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
			public static
			bool IsFramebuffer(UInt32 framebuffer) {
				return Delegates.glIsFramebufferOES((UInt32) framebuffer);
			}


			/// <summary>[requires: 1.1]
			/// Determine if a name corresponds to a renderbuffer object
			/// </summary>
			/// <param name="renderbuffer">
			/// <para>
			/// Specifies a value that may be the name of a renderbuffer object.
			/// </para>
			/// </param>
			//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glIsRenderbufferOES")]
#if NET45
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
			public static
						bool IsRenderbuffer(Int32 renderbuffer) {
				return Delegates.glIsRenderbufferOES((UInt32) renderbuffer);
			}


			/// <summary>[requires: 1.1]
			/// Determine if a name corresponds to a renderbuffer object
			/// </summary>
			/// <param name="renderbuffer">
			/// <para>
			/// Specifies a value that may be the name of a renderbuffer object.
			/// </para>
			/// </param>
			[System.CLSCompliant(false)]
			//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glIsRenderbufferOES")]
#if NET45
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
			public static
			bool IsRenderbuffer(UInt32 renderbuffer) {
				return Delegates.glIsRenderbufferOES((UInt32) renderbuffer);
			}

			/// <summary>[requires: 1.1]</summary>
			//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glLightModelxOES")]
#if NET45
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
			public static
						void LightModelx(System.Graphics.ES11.All pname, int param) {
				Delegates.glLightModelxOES((System.Graphics.ES11.All) pname, (int) param);
			}

			/// <summary>[requires: 1.1]</summary>
			//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glLightModelxvOES")]
#if NET45
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
			public static
						void LightModelx(System.Graphics.ES11.All pname, int[] @params) {
				unsafe
				{
					fixed (int* @params_ptr = @params) {
						Delegates.glLightModelxvOES((System.Graphics.ES11.All) pname, (int*) @params_ptr);
					}
				}
			}

			/// <summary>[requires: 1.1]</summary>
			[System.CLSCompliant(false)]
			//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glLightModelxvOES")]
#if NET45
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
			public static
			unsafe void LightModelx(System.Graphics.ES11.All pname, int* @params) {
				Delegates.glLightModelxvOES((System.Graphics.ES11.All) pname, (int*) @params);
			}

			/// <summary>[requires: 1.1]</summary>
			//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glLightxOES")]
#if NET45
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
			public static
						void Lightx(System.Graphics.ES11.All light, System.Graphics.ES11.All pname, int param) {
				Delegates.glLightxOES((System.Graphics.ES11.All) light, (System.Graphics.ES11.All) pname, (int) param);
			}

			/// <summary>[requires: 1.1]</summary>
			//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glLightxvOES")]
#if NET45
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
			public static
						void Lightx(System.Graphics.ES11.All light, System.Graphics.ES11.All pname, int[] @params) {
				unsafe
				{
					fixed (int* @params_ptr = @params) {
						Delegates.glLightxvOES((System.Graphics.ES11.All) light, (System.Graphics.ES11.All) pname, (int*) @params_ptr);
					}
				}
			}

			/// <summary>[requires: 1.1]</summary>
			[System.CLSCompliant(false)]
			//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glLightxvOES")]
#if NET45
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
			public static
			unsafe void Lightx(System.Graphics.ES11.All light, System.Graphics.ES11.All pname, int* @params) {
				Delegates.glLightxvOES((System.Graphics.ES11.All) light, (System.Graphics.ES11.All) pname, (int*) @params);
			}

			/// <summary>[requires: 1.1]</summary>
			//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glLineWidthxOES")]
#if NET45
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
			public static
						void LineWidthx(int width) {
				Delegates.glLineWidthxOES((int) width);
			}

			/// <summary>[requires: 1.1]</summary>
			//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glLoadMatrixxOES")]
#if NET45
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
			public static
						void LoadMatrixx(int[] m) {
				unsafe
				{
					fixed (int* m_ptr = m) {
						Delegates.glLoadMatrixxOES((int*) m_ptr);
					}
				}
			}

			/// <summary>[requires: 1.1]</summary>
			//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glLoadMatrixxOES")]
#if NET45
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
			public static
						void LoadMatrixx(ref int m) {
				unsafe
				{
					fixed (int* m_ptr = &m) {
						Delegates.glLoadMatrixxOES((int*) m_ptr);
					}
				}
			}

			/// <summary>[requires: 1.1]</summary>
			[System.CLSCompliant(false)]
			//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glLoadMatrixxOES")]
#if NET45
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
			public static
			unsafe void LoadMatrixx(int* m) {
				Delegates.glLoadMatrixxOES((int*) m);
			}

			/// <summary>[requires: 1.1]</summary>
			//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glLoadPaletteFromModelViewMatrixOES")]
#if NET45
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
			public static
						void LoadPaletteFromModelViewMatrix() {
				Delegates.glLoadPaletteFromModelViewMatrixOES();
			}


			/// <summary>[requires: 1.1]
			/// Map a buffer object's data store
			/// </summary>
			/// <param name="target">
			/// <para>
			/// Specifies the target buffer object being mapped. The symbolic constant must be GL_ARRAY_BUFFER, GL_COPY_READ_BUFFER, GL_COPY_WRITE_BUFFER, GL_ELEMENT_ARRAY_BUFFER, GL_PIXEL_PACK_BUFFER, GL_PIXEL_UNPACK_BUFFER, GL_TEXTURE_BUFFER, GL_TRANSFORM_FEEDBACK_BUFFER or GL_UNIFORM_BUFFER.
			/// </para>
			/// </param>
			/// <param name="access">
			/// <para>
			/// Specifies the access policy, indicating whether it will be possible to read from, write to, or both read from and write to the buffer object's mapped data store. The symbolic constant must be GL_READ_ONLY, GL_WRITE_ONLY, or GL_READ_WRITE.
			/// </para>
			/// </param>
			[System.CLSCompliant(false)]
			//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glMapBufferOES")]
#if NET45
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
			public static
			unsafe System.IntPtr MapBuffer(System.Graphics.ES11.All target, System.Graphics.ES11.All access) {
				return Delegates.glMapBufferOES((System.Graphics.ES11.All) target, (System.Graphics.ES11.All) access);
			}

			/// <summary>[requires: 1.1]</summary>
			//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glMaterialxOES")]
#if NET45
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
			public static
						void Materialx(System.Graphics.ES11.All face, System.Graphics.ES11.All pname, int param) {
				Delegates.glMaterialxOES((System.Graphics.ES11.All) face, (System.Graphics.ES11.All) pname, (int) param);
			}

			/// <summary>[requires: 1.1]</summary>
			//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glMaterialxvOES")]
#if NET45
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
			public static
						void Materialx(System.Graphics.ES11.All face, System.Graphics.ES11.All pname, int[] @params) {
				unsafe
				{
					fixed (int* @params_ptr = @params) {
						Delegates.glMaterialxvOES((System.Graphics.ES11.All) face, (System.Graphics.ES11.All) pname, (int*) @params_ptr);
					}
				}
			}

			/// <summary>[requires: 1.1]</summary>
			[System.CLSCompliant(false)]
			//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glMaterialxvOES")]
#if NET45
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
			public static
			unsafe void Materialx(System.Graphics.ES11.All face, System.Graphics.ES11.All pname, int* @params) {
				Delegates.glMaterialxvOES((System.Graphics.ES11.All) face, (System.Graphics.ES11.All) pname, (int*) @params);
			}

			/// <summary>[requires: 1.1]</summary>
			//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glMatrixIndexPointerOES")]
#if NET45
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
			public static
						void MatrixIndexPointer(Int32 size, System.Graphics.ES11.All type, Int32 stride, IntPtr pointer) {
				Delegates.glMatrixIndexPointerOES((Int32) size, (System.Graphics.ES11.All) type, (Int32) stride, (IntPtr) pointer);
			}

			/// <summary>[requires: 1.1]</summary>
			//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glMatrixIndexPointerOES")]
#if NET45
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
			public static
						void MatrixIndexPointer<T3>(Int32 size, System.Graphics.ES11.All type, Int32 stride, [InAttribute, OutAttribute] T3[] pointer)
							where T3 : struct {
				GCHandle pointer_ptr = GCHandle.Alloc(pointer, GCHandleType.Pinned);
				try {
					Delegates.glMatrixIndexPointerOES((Int32) size, (System.Graphics.ES11.All) type, (Int32) stride, (IntPtr) pointer_ptr.AddrOfPinnedObject());
				} finally {
					pointer_ptr.Free();
				}
			}

			/// <summary>[requires: 1.1]</summary>
			//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glMatrixIndexPointerOES")]
#if NET45
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
			public static
						void MatrixIndexPointer<T3>(Int32 size, System.Graphics.ES11.All type, Int32 stride, [InAttribute, OutAttribute] T3[,] pointer)
							where T3 : struct {
				GCHandle pointer_ptr = GCHandle.Alloc(pointer, GCHandleType.Pinned);
				try {
					Delegates.glMatrixIndexPointerOES((Int32) size, (System.Graphics.ES11.All) type, (Int32) stride, (IntPtr) pointer_ptr.AddrOfPinnedObject());
				} finally {
					pointer_ptr.Free();
				}
			}

			/// <summary>[requires: 1.1]</summary>
			//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glMatrixIndexPointerOES")]
#if NET45
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
			public static
						void MatrixIndexPointer<T3>(Int32 size, System.Graphics.ES11.All type, Int32 stride, [InAttribute, OutAttribute] T3[,,] pointer)
							where T3 : struct {
				GCHandle pointer_ptr = GCHandle.Alloc(pointer, GCHandleType.Pinned);
				try {
					Delegates.glMatrixIndexPointerOES((Int32) size, (System.Graphics.ES11.All) type, (Int32) stride, (IntPtr) pointer_ptr.AddrOfPinnedObject());
				} finally {
					pointer_ptr.Free();
				}
			}

			/// <summary>[requires: 1.1]</summary>
			//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glMatrixIndexPointerOES")]
#if NET45
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
			public static
						void MatrixIndexPointer<T3>(Int32 size, System.Graphics.ES11.All type, Int32 stride, [InAttribute, OutAttribute] ref T3 pointer)
							where T3 : struct {
				GCHandle pointer_ptr = GCHandle.Alloc(pointer, GCHandleType.Pinned);
				try {
					Delegates.glMatrixIndexPointerOES((Int32) size, (System.Graphics.ES11.All) type, (Int32) stride, (IntPtr) pointer_ptr.AddrOfPinnedObject());
					pointer = (T3) pointer_ptr.Target;
				} finally {
					pointer_ptr.Free();
				}
			}

			/// <summary>[requires: 1.1]</summary>
			//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glMultiTexCoord4xOES")]
#if NET45
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
			public static
						void MultiTexCoord4x(System.Graphics.ES11.All target, int s, int t, int r, int q) {
				Delegates.glMultiTexCoord4xOES((System.Graphics.ES11.All) target, (int) s, (int) t, (int) r, (int) q);
			}

			/// <summary>[requires: 1.1]</summary>
			//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glMultMatrixxOES")]
#if NET45
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
			public static
						void MultMatrixx(int[] m) {
				unsafe
				{
					fixed (int* m_ptr = m) {
						Delegates.glMultMatrixxOES((int*) m_ptr);
					}
				}
			}

			/// <summary>[requires: 1.1]</summary>
			//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glMultMatrixxOES")]
#if NET45
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
			public static
						void MultMatrixx(ref int m) {
				unsafe
				{
					fixed (int* m_ptr = &m) {
						Delegates.glMultMatrixxOES((int*) m_ptr);
					}
				}
			}

			/// <summary>[requires: 1.1]</summary>
			[System.CLSCompliant(false)]
			//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glMultMatrixxOES")]
#if NET45
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
			public static
			unsafe void MultMatrixx(int* m) {
				Delegates.glMultMatrixxOES((int*) m);
			}

			/// <summary>[requires: 1.1]</summary>
			//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glNormal3xOES")]
#if NET45
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
			public static
						void Normal3x(int nx, int ny, int nz) {
				Delegates.glNormal3xOES((int) nx, (int) ny, (int) nz);
			}


			/// <summary>[requires: 1.1]
			/// Multiply the current matrix with an orthographic matrix
			/// </summary>
			//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glOrthofOES")]
#if NET45
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
			public static
						void Ortho(Single left, Single right, Single bottom, Single top, Single zNear, Single zFar) {
				Delegates.glOrthofOES((Single) left, (Single) right, (Single) bottom, (Single) top, (Single) zNear, (Single) zFar);
			}

			/// <summary>[requires: 1.1]</summary>
			//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glOrthoxOES")]
#if NET45
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
			public static
						void Orthox(int left, int right, int bottom, int top, int zNear, int zFar) {
				Delegates.glOrthoxOES((int) left, (int) right, (int) bottom, (int) top, (int) zNear, (int) zFar);
			}

			/// <summary>[requires: 1.1]</summary>
			//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glPointParameterxOES")]
#if NET45
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
			public static
						void PointParameterx(System.Graphics.ES11.All pname, int param) {
				Delegates.glPointParameterxOES((System.Graphics.ES11.All) pname, (int) param);
			}

			/// <summary>[requires: 1.1]</summary>
			//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glPointParameterxvOES")]
#if NET45
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
			public static
						void PointParameterx(System.Graphics.ES11.All pname, int[] @params) {
				unsafe
				{
					fixed (int* @params_ptr = @params) {
						Delegates.glPointParameterxvOES((System.Graphics.ES11.All) pname, (int*) @params_ptr);
					}
				}
			}

			/// <summary>[requires: 1.1]</summary>
			[System.CLSCompliant(false)]
			//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glPointParameterxvOES")]
#if NET45
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
			public static
			unsafe void PointParameterx(System.Graphics.ES11.All pname, int* @params) {
				Delegates.glPointParameterxvOES((System.Graphics.ES11.All) pname, (int*) @params);
			}

			/// <summary>[requires: 1.1]</summary>
			//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glPointSizePointerOES")]
#if NET45
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
			public static
						void PointSizePointer(System.Graphics.ES11.All type, Int32 stride, IntPtr pointer) {
				Delegates.glPointSizePointerOES((System.Graphics.ES11.All) type, (Int32) stride, (IntPtr) pointer);
			}

			/// <summary>[requires: 1.1]</summary>
			//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glPointSizePointerOES")]
#if NET45
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
			public static
						void PointSizePointer<T2>(System.Graphics.ES11.All type, Int32 stride, [InAttribute, OutAttribute] T2[] pointer)
							where T2 : struct {
				GCHandle pointer_ptr = GCHandle.Alloc(pointer, GCHandleType.Pinned);
				try {
					Delegates.glPointSizePointerOES((System.Graphics.ES11.All) type, (Int32) stride, (IntPtr) pointer_ptr.AddrOfPinnedObject());
				} finally {
					pointer_ptr.Free();
				}
			}

			/// <summary>[requires: 1.1]</summary>
			//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glPointSizePointerOES")]
#if NET45
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
			public static
						void PointSizePointer<T2>(System.Graphics.ES11.All type, Int32 stride, [InAttribute, OutAttribute] T2[,] pointer)
							where T2 : struct {
				GCHandle pointer_ptr = GCHandle.Alloc(pointer, GCHandleType.Pinned);
				try {
					Delegates.glPointSizePointerOES((System.Graphics.ES11.All) type, (Int32) stride, (IntPtr) pointer_ptr.AddrOfPinnedObject());
				} finally {
					pointer_ptr.Free();
				}
			}

			/// <summary>[requires: 1.1]</summary>
			//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glPointSizePointerOES")]
#if NET45
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
			public static
						void PointSizePointer<T2>(System.Graphics.ES11.All type, Int32 stride, [InAttribute, OutAttribute] T2[,,] pointer)
							where T2 : struct {
				GCHandle pointer_ptr = GCHandle.Alloc(pointer, GCHandleType.Pinned);
				try {
					Delegates.glPointSizePointerOES((System.Graphics.ES11.All) type, (Int32) stride, (IntPtr) pointer_ptr.AddrOfPinnedObject());
				} finally {
					pointer_ptr.Free();
				}
			}

			/// <summary>[requires: 1.1]</summary>
			//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glPointSizePointerOES")]
#if NET45
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
			public static
						void PointSizePointer<T2>(System.Graphics.ES11.All type, Int32 stride, [InAttribute, OutAttribute] ref T2 pointer)
							where T2 : struct {
				GCHandle pointer_ptr = GCHandle.Alloc(pointer, GCHandleType.Pinned);
				try {
					Delegates.glPointSizePointerOES((System.Graphics.ES11.All) type, (Int32) stride, (IntPtr) pointer_ptr.AddrOfPinnedObject());
					pointer = (T2) pointer_ptr.Target;
				} finally {
					pointer_ptr.Free();
				}
			}

			/// <summary>[requires: 1.1]</summary>
			//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glPointSizexOES")]
#if NET45
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
			public static
						void PointSizex(int size) {
				Delegates.glPointSizexOES((int) size);
			}

			/// <summary>[requires: 1.1]</summary>
			//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glPolygonOffsetxOES")]
#if NET45
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
			public static
						void PolygonOffsetx(int factor, int units) {
				Delegates.glPolygonOffsetxOES((int) factor, (int) units);
			}

			/// <summary>[requires: 1.1]</summary>
			//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glQueryMatrixxOES")]
#if NET45
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
			public static
						Int32 QueryMatrixx(int[] mantissa, Int32[] exponent) {
				unsafe
				{
					fixed (int* mantissa_ptr = mantissa)
					fixed (Int32* exponent_ptr = exponent) {
						return Delegates.glQueryMatrixxOES((int*) mantissa_ptr, (Int32*) exponent_ptr);
					}
				}
			}

			/// <summary>[requires: 1.1]</summary>
			//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glQueryMatrixxOES")]
#if NET45
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
			public static
						Int32 QueryMatrixx(ref int mantissa, ref Int32 exponent) {
				unsafe
				{
					fixed (int* mantissa_ptr = &mantissa)
					fixed (Int32* exponent_ptr = &exponent) {
						return Delegates.glQueryMatrixxOES((int*) mantissa_ptr, (Int32*) exponent_ptr);
					}
				}
			}

			/// <summary>[requires: 1.1]</summary>
			[System.CLSCompliant(false)]
			//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glQueryMatrixxOES")]
#if NET45
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
			public static
			unsafe Int32 QueryMatrixx(int* mantissa, Int32* exponent) {
				return Delegates.glQueryMatrixxOES((int*) mantissa, (Int32*) exponent);
			}


			/// <summary>[requires: 1.1]
			/// Establish data storage, format and dimensions of a renderbuffer object's image
			/// </summary>
			/// <param name="target">
			/// <para>
			/// Specifies a binding to which the target of the allocation and must be GL_RENDERBUFFER.
			/// </para>
			/// </param>
			/// <param name="internalformat">
			/// <para>
			/// Specifies the internal format to use for the renderbuffer object's image.
			/// </para>
			/// </param>
			/// <param name="width">
			/// <para>
			/// Specifies the width of the renderbuffer, in pixels.
			/// </para>
			/// </param>
			/// <param name="height">
			/// <para>
			/// Specifies the height of the renderbuffer, in pixels.
			/// </para>
			/// </param>
			//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glRenderbufferStorageOES")]
#if NET45
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
			public static
						void RenderbufferStorage(System.Graphics.ES11.All target, System.Graphics.ES11.All internalformat, Int32 width, Int32 height) {
				Delegates.glRenderbufferStorageOES((System.Graphics.ES11.All) target, (System.Graphics.ES11.All) internalformat, (Int32) width, (Int32) height);
			}

			/// <summary>[requires: 1.1]</summary>
			//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glRotatexOES")]
#if NET45
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
			public static
						void Rotatex(int angle, int x, int y, int z) {
				Delegates.glRotatexOES((int) angle, (int) x, (int) y, (int) z);
			}

			/// <summary>[requires: 1.1]</summary>
			//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glSampleCoveragexOES")]
#if NET45
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
			public static
						void SampleCoveragex(int value, bool invert) {
				Delegates.glSampleCoveragexOES((int) value, (bool) invert);
			}

			/// <summary>[requires: 1.1]</summary>
			//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glScalexOES")]
#if NET45
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
			public static
						void Scalex(int x, int y, int z) {
				Delegates.glScalexOES((int) x, (int) y, (int) z);
			}

			/// <summary>[requires: 1.1]</summary>
			//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glTexEnvxOES")]
#if NET45
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
			public static
						void TexEnvx(System.Graphics.ES11.All target, System.Graphics.ES11.All pname, int param) {
				Delegates.glTexEnvxOES((System.Graphics.ES11.All) target, (System.Graphics.ES11.All) pname, (int) param);
			}

			/// <summary>[requires: 1.1]</summary>
			//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glTexEnvxvOES")]
#if NET45
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
			public static
						void TexEnvx(System.Graphics.ES11.All target, System.Graphics.ES11.All pname, int[] @params) {
				unsafe
				{
					fixed (int* @params_ptr = @params) {
						Delegates.glTexEnvxvOES((System.Graphics.ES11.All) target, (System.Graphics.ES11.All) pname, (int*) @params_ptr);
					}
				}
			}

			/// <summary>[requires: 1.1]</summary>
			[System.CLSCompliant(false)]
			//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glTexEnvxvOES")]
#if NET45
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
			public static
			unsafe void TexEnvx(System.Graphics.ES11.All target, System.Graphics.ES11.All pname, int* @params) {
				Delegates.glTexEnvxvOES((System.Graphics.ES11.All) target, (System.Graphics.ES11.All) pname, (int*) @params);
			}


			/// <summary>[requires: 1.1]
			/// Control the generation of texture coordinates
			/// </summary>
			/// <param name="coord">
			/// <para>
			/// Specifies a texture coordinate. Must be one of GL_S, GL_T, GL_R, or GL_Q.
			/// </para>
			/// </param>
			/// <param name="pname">
			/// <para>
			/// Specifies the symbolic name of the texture-coordinate generation function. Must be GL_TEXTURE_GEN_MODE.
			/// </para>
			/// </param>
			/// <param name="param">
			/// <para>
			/// Specifies a single-valued texture generation parameter, one of GL_OBJECT_LINEAR, GL_EYE_LINEAR, GL_SPHERE_MAP, GL_NORMAL_MAP, or GL_REFLECTION_MAP.
			/// </para>
			/// </param>
			//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glTexGenfOES")]
#if NET45
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
			public static
						void TexGen(System.Graphics.ES11.All coord, System.Graphics.ES11.All pname, Single param) {
				Delegates.glTexGenfOES((System.Graphics.ES11.All) coord, (System.Graphics.ES11.All) pname, (Single) param);
			}


			/// <summary>[requires: 1.1]
			/// Control the generation of texture coordinates
			/// </summary>
			/// <param name="coord">
			/// <para>
			/// Specifies a texture coordinate. Must be one of GL_S, GL_T, GL_R, or GL_Q.
			/// </para>
			/// </param>
			/// <param name="pname">
			/// <para>
			/// Specifies the symbolic name of the texture-coordinate generation function. Must be GL_TEXTURE_GEN_MODE.
			/// </para>
			/// </param>
			/// <param name="params">
			/// <para>
			/// Specifies a single-valued texture generation parameter, one of GL_OBJECT_LINEAR, GL_EYE_LINEAR, GL_SPHERE_MAP, GL_NORMAL_MAP, or GL_REFLECTION_MAP.
			/// </para>
			/// </param>
			//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glTexGenfvOES")]
#if NET45
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
			public static
						void TexGen(System.Graphics.ES11.All coord, System.Graphics.ES11.All pname, Single[] @params) {
				unsafe
				{
					fixed (Single* @params_ptr = @params) {
						Delegates.glTexGenfvOES((System.Graphics.ES11.All) coord, (System.Graphics.ES11.All) pname, (Single*) @params_ptr);
					}
				}
			}


			/// <summary>[requires: 1.1]
			/// Control the generation of texture coordinates
			/// </summary>
			/// <param name="coord">
			/// <para>
			/// Specifies a texture coordinate. Must be one of GL_S, GL_T, GL_R, or GL_Q.
			/// </para>
			/// </param>
			/// <param name="pname">
			/// <para>
			/// Specifies the symbolic name of the texture-coordinate generation function. Must be GL_TEXTURE_GEN_MODE.
			/// </para>
			/// </param>
			/// <param name="params">
			/// <para>
			/// Specifies a single-valued texture generation parameter, one of GL_OBJECT_LINEAR, GL_EYE_LINEAR, GL_SPHERE_MAP, GL_NORMAL_MAP, or GL_REFLECTION_MAP.
			/// </para>
			/// </param>
			[System.CLSCompliant(false)]
			//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glTexGenfvOES")]
#if NET45
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
			public static
			unsafe void TexGen(System.Graphics.ES11.All coord, System.Graphics.ES11.All pname, Single* @params) {
				Delegates.glTexGenfvOES((System.Graphics.ES11.All) coord, (System.Graphics.ES11.All) pname, (Single*) @params);
			}


			/// <summary>[requires: 1.1]
			/// Control the generation of texture coordinates
			/// </summary>
			/// <param name="coord">
			/// <para>
			/// Specifies a texture coordinate. Must be one of GL_S, GL_T, GL_R, or GL_Q.
			/// </para>
			/// </param>
			/// <param name="pname">
			/// <para>
			/// Specifies the symbolic name of the texture-coordinate generation function. Must be GL_TEXTURE_GEN_MODE.
			/// </para>
			/// </param>
			/// <param name="param">
			/// <para>
			/// Specifies a single-valued texture generation parameter, one of GL_OBJECT_LINEAR, GL_EYE_LINEAR, GL_SPHERE_MAP, GL_NORMAL_MAP, or GL_REFLECTION_MAP.
			/// </para>
			/// </param>
			//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glTexGeniOES")]
#if NET45
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
			public static
						void TexGen(System.Graphics.ES11.All coord, System.Graphics.ES11.All pname, Int32 param) {
				Delegates.glTexGeniOES((System.Graphics.ES11.All) coord, (System.Graphics.ES11.All) pname, (Int32) param);
			}


			/// <summary>[requires: 1.1]
			/// Control the generation of texture coordinates
			/// </summary>
			/// <param name="coord">
			/// <para>
			/// Specifies a texture coordinate. Must be one of GL_S, GL_T, GL_R, or GL_Q.
			/// </para>
			/// </param>
			/// <param name="pname">
			/// <para>
			/// Specifies the symbolic name of the texture-coordinate generation function. Must be GL_TEXTURE_GEN_MODE.
			/// </para>
			/// </param>
			/// <param name="params">
			/// <para>
			/// Specifies a single-valued texture generation parameter, one of GL_OBJECT_LINEAR, GL_EYE_LINEAR, GL_SPHERE_MAP, GL_NORMAL_MAP, or GL_REFLECTION_MAP.
			/// </para>
			/// </param>
			//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glTexGenivOES")]
#if NET45
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
			public static
						void TexGen(System.Graphics.ES11.All coord, System.Graphics.ES11.All pname, Int32[] @params) {
				unsafe
				{
					fixed (Int32* @params_ptr = @params) {
						Delegates.glTexGenivOES((System.Graphics.ES11.All) coord, (System.Graphics.ES11.All) pname, (Int32*) @params_ptr);
					}
				}
			}


			/// <summary>[requires: 1.1]
			/// Control the generation of texture coordinates
			/// </summary>
			/// <param name="coord">
			/// <para>
			/// Specifies a texture coordinate. Must be one of GL_S, GL_T, GL_R, or GL_Q.
			/// </para>
			/// </param>
			/// <param name="pname">
			/// <para>
			/// Specifies the symbolic name of the texture-coordinate generation function. Must be GL_TEXTURE_GEN_MODE.
			/// </para>
			/// </param>
			/// <param name="params">
			/// <para>
			/// Specifies a single-valued texture generation parameter, one of GL_OBJECT_LINEAR, GL_EYE_LINEAR, GL_SPHERE_MAP, GL_NORMAL_MAP, or GL_REFLECTION_MAP.
			/// </para>
			/// </param>
			[System.CLSCompliant(false)]
			//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glTexGenivOES")]
#if NET45
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
			public static
			unsafe void TexGen(System.Graphics.ES11.All coord, System.Graphics.ES11.All pname, Int32* @params) {
				Delegates.glTexGenivOES((System.Graphics.ES11.All) coord, (System.Graphics.ES11.All) pname, (Int32*) @params);
			}

			/// <summary>[requires: 1.1]</summary>
			//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glTexGenxOES")]
#if NET45
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
			public static
						void TexGenx(System.Graphics.ES11.All coord, System.Graphics.ES11.All pname, int param) {
				Delegates.glTexGenxOES((System.Graphics.ES11.All) coord, (System.Graphics.ES11.All) pname, (int) param);
			}

			/// <summary>[requires: 1.1]</summary>
			//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glTexGenxvOES")]
#if NET45
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
			public static
						void TexGenx(System.Graphics.ES11.All coord, System.Graphics.ES11.All pname, int[] @params) {
				unsafe
				{
					fixed (int* @params_ptr = @params) {
						Delegates.glTexGenxvOES((System.Graphics.ES11.All) coord, (System.Graphics.ES11.All) pname, (int*) @params_ptr);
					}
				}
			}

			/// <summary>[requires: 1.1]</summary>
			[System.CLSCompliant(false)]
			//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glTexGenxvOES")]
#if NET45
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
			public static
			unsafe void TexGenx(System.Graphics.ES11.All coord, System.Graphics.ES11.All pname, int* @params) {
				Delegates.glTexGenxvOES((System.Graphics.ES11.All) coord, (System.Graphics.ES11.All) pname, (int*) @params);
			}

			/// <summary>[requires: 1.1]</summary>
			//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glTexParameterxOES")]
#if NET45
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
			public static
						void TexParameterx(System.Graphics.ES11.All target, System.Graphics.ES11.All pname, int param) {
				Delegates.glTexParameterxOES((System.Graphics.ES11.All) target, (System.Graphics.ES11.All) pname, (int) param);
			}

			/// <summary>[requires: 1.1]</summary>
			//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glTexParameterxvOES")]
#if NET45
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
			public static
						void TexParameterx(System.Graphics.ES11.All target, System.Graphics.ES11.All pname, int[] @params) {
				unsafe
				{
					fixed (int* @params_ptr = @params) {
						Delegates.glTexParameterxvOES((System.Graphics.ES11.All) target, (System.Graphics.ES11.All) pname, (int*) @params_ptr);
					}
				}
			}

			/// <summary>[requires: 1.1]</summary>
			[System.CLSCompliant(false)]
			//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glTexParameterxvOES")]
#if NET45
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
			public static
			unsafe void TexParameterx(System.Graphics.ES11.All target, System.Graphics.ES11.All pname, int* @params) {
				Delegates.glTexParameterxvOES((System.Graphics.ES11.All) target, (System.Graphics.ES11.All) pname, (int*) @params);
			}

			/// <summary>[requires: 1.1]</summary>
			//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glTranslatexOES")]
#if NET45
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
			public static
						void Translatex(int x, int y, int z) {
				Delegates.glTranslatexOES((int) x, (int) y, (int) z);
			}

			/// <summary>[requires: 1.1]</summary>
			//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glUnmapBufferOES")]
#if NET45
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
			public static
						bool UnmapBuffer(System.Graphics.ES11.All target) {
				return Delegates.glUnmapBufferOES((System.Graphics.ES11.All) target);
			}

			/// <summary>[requires: 1.1]</summary>
			//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glWeightPointerOES")]
#if NET45
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
			public static
						void WeightPointer(Int32 size, System.Graphics.ES11.All type, Int32 stride, IntPtr pointer) {
				Delegates.glWeightPointerOES((Int32) size, (System.Graphics.ES11.All) type, (Int32) stride, (IntPtr) pointer);
			}

			/// <summary>[requires: 1.1]</summary>
			//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glWeightPointerOES")]
#if NET45
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
			public static
						void WeightPointer<T3>(Int32 size, System.Graphics.ES11.All type, Int32 stride, [InAttribute, OutAttribute] T3[] pointer)
							where T3 : struct {
				GCHandle pointer_ptr = GCHandle.Alloc(pointer, GCHandleType.Pinned);
				try {
					Delegates.glWeightPointerOES((Int32) size, (System.Graphics.ES11.All) type, (Int32) stride, (IntPtr) pointer_ptr.AddrOfPinnedObject());
				} finally {
					pointer_ptr.Free();
				}
			}

			/// <summary>[requires: 1.1]</summary>
			//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glWeightPointerOES")]
#if NET45
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
			public static
						void WeightPointer<T3>(Int32 size, System.Graphics.ES11.All type, Int32 stride, [InAttribute, OutAttribute] T3[,] pointer)
							where T3 : struct {
				GCHandle pointer_ptr = GCHandle.Alloc(pointer, GCHandleType.Pinned);
				try {
					Delegates.glWeightPointerOES((Int32) size, (System.Graphics.ES11.All) type, (Int32) stride, (IntPtr) pointer_ptr.AddrOfPinnedObject());
				} finally {
					pointer_ptr.Free();
				}
			}

			/// <summary>[requires: 1.1]</summary>
			//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glWeightPointerOES")]
#if NET45
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
			public static
						void WeightPointer<T3>(Int32 size, System.Graphics.ES11.All type, Int32 stride, [InAttribute, OutAttribute] T3[,,] pointer)
							where T3 : struct {
				GCHandle pointer_ptr = GCHandle.Alloc(pointer, GCHandleType.Pinned);
				try {
					Delegates.glWeightPointerOES((Int32) size, (System.Graphics.ES11.All) type, (Int32) stride, (IntPtr) pointer_ptr.AddrOfPinnedObject());
				} finally {
					pointer_ptr.Free();
				}
			}

			/// <summary>[requires: 1.1]</summary>
			//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glWeightPointerOES")]
#if NET45
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
			public static
						void WeightPointer<T3>(Int32 size, System.Graphics.ES11.All type, Int32 stride, [InAttribute, OutAttribute] ref T3 pointer)
							where T3 : struct {
				GCHandle pointer_ptr = GCHandle.Alloc(pointer, GCHandleType.Pinned);
				try {
					Delegates.glWeightPointerOES((Int32) size, (System.Graphics.ES11.All) type, (Int32) stride, (IntPtr) pointer_ptr.AddrOfPinnedObject());
					pointer = (T3) pointer_ptr.Target;
				} finally {
					pointer_ptr.Free();
				}
			}

		}

		/// <summary>
		/// Qualcomm extension methods.
		/// </summary>
		public static class Qcom {
			/// <summary>[requires: 1.1]</summary>
			//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glDisableDriverControlQCOM")]
#if NET45
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
			public static
						void DisableDriverControl(Int32 driverControl) {
				Delegates.glDisableDriverControlQCOM((UInt32) driverControl);
			}

			/// <summary>[requires: 1.1]</summary>
			[System.CLSCompliant(false)]
			//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glDisableDriverControlQCOM")]
#if NET45
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
			public static
			void DisableDriverControl(UInt32 driverControl) {
				Delegates.glDisableDriverControlQCOM((UInt32) driverControl);
			}

			/// <summary>[requires: 1.1]</summary>
			//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glEnableDriverControlQCOM")]
#if NET45
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
			public static
						void EnableDriverControl(Int32 driverControl) {
				Delegates.glEnableDriverControlQCOM((UInt32) driverControl);
			}

			/// <summary>[requires: 1.1]</summary>
			[System.CLSCompliant(false)]
			//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glEnableDriverControlQCOM")]
#if NET45
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
			public static
			void EnableDriverControl(UInt32 driverControl) {
				Delegates.glEnableDriverControlQCOM((UInt32) driverControl);
			}

			/// <summary>[requires: 1.1]</summary>
			//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glGetDriverControlsQCOM")]
#if NET45
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
			public static
						void GetDriverControl(Int32[] num, Int32 size, Int32[] driverControls) {
				unsafe
				{
					fixed (Int32* num_ptr = num)
					fixed (Int32* driverControls_ptr = driverControls) {
						Delegates.glGetDriverControlsQCOM((Int32*) num_ptr, (Int32) size, (UInt32*) driverControls_ptr);
					}
				}
			}

			/// <summary>[requires: 1.1]</summary>
			[System.CLSCompliant(false)]
			//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glGetDriverControlsQCOM")]
#if NET45
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
			public static
			void GetDriverControl(Int32[] num, Int32 size, UInt32[] driverControls) {
				unsafe
				{
					fixed (Int32* num_ptr = num)
					fixed (UInt32* driverControls_ptr = driverControls) {
						Delegates.glGetDriverControlsQCOM((Int32*) num_ptr, (Int32) size, (UInt32*) driverControls_ptr);
					}
				}
			}

			/// <summary>[requires: 1.1]</summary>
			//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glGetDriverControlsQCOM")]
#if NET45
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
			public static
						void GetDriverControl(ref Int32 num, Int32 size, ref Int32 driverControls) {
				unsafe
				{
					fixed (Int32* num_ptr = &num)
					fixed (Int32* driverControls_ptr = &driverControls) {
						Delegates.glGetDriverControlsQCOM((Int32*) num_ptr, (Int32) size, (UInt32*) driverControls_ptr);
					}
				}
			}

			/// <summary>[requires: 1.1]</summary>
			[System.CLSCompliant(false)]
			//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glGetDriverControlsQCOM")]
#if NET45
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
			public static
			void GetDriverControl(ref Int32 num, Int32 size, ref UInt32 driverControls) {
				unsafe
				{
					fixed (Int32* num_ptr = &num)
					fixed (UInt32* driverControls_ptr = &driverControls) {
						Delegates.glGetDriverControlsQCOM((Int32*) num_ptr, (Int32) size, (UInt32*) driverControls_ptr);
					}
				}
			}

			/// <summary>[requires: 1.1]</summary>
			[System.CLSCompliant(false)]
			//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glGetDriverControlsQCOM")]
#if NET45
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
			public static
			unsafe void GetDriverControl(Int32* num, Int32 size, Int32* driverControls) {
				Delegates.glGetDriverControlsQCOM((Int32*) num, (Int32) size, (UInt32*) driverControls);
			}

			/// <summary>[requires: 1.1]</summary>
			[System.CLSCompliant(false)]
			//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glGetDriverControlsQCOM")]
#if NET45
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
			public static
			unsafe void GetDriverControl(Int32* num, Int32 size, UInt32* driverControls) {
				Delegates.glGetDriverControlsQCOM((Int32*) num, (Int32) size, (UInt32*) driverControls);
			}

			/// <summary>[requires: 1.1]</summary>
			//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glGetDriverControlStringQCOM")]
#if NET45
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
			public static
						void GetDriverControlString(Int32 driverControl, Int32 bufSize, Int32[] length, String driverControlString) {
				unsafe
				{
					fixed (Int32* length_ptr = length) {
						Delegates.glGetDriverControlStringQCOM((UInt32) driverControl, (Int32) bufSize, (Int32*) length_ptr, (String) driverControlString);
					}
				}
			}

			/// <summary>[requires: 1.1]</summary>
			//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glGetDriverControlStringQCOM")]
#if NET45
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
			public static
						void GetDriverControlString(Int32 driverControl, Int32 bufSize, ref Int32 length, String driverControlString) {
				unsafe
				{
					fixed (Int32* length_ptr = &length) {
						Delegates.glGetDriverControlStringQCOM((UInt32) driverControl, (Int32) bufSize, (Int32*) length_ptr, (String) driverControlString);
					}
				}
			}

			/// <summary>[requires: 1.1]</summary>
			[System.CLSCompliant(false)]
			//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glGetDriverControlStringQCOM")]
#if NET45
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
			public static
			unsafe void GetDriverControlString(Int32 driverControl, Int32 bufSize, Int32* length, String driverControlString) {
				Delegates.glGetDriverControlStringQCOM((UInt32) driverControl, (Int32) bufSize, (Int32*) length, (String) driverControlString);
			}

			/// <summary>[requires: 1.1]</summary>
			[System.CLSCompliant(false)]
			//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glGetDriverControlStringQCOM")]
#if NET45
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
			public static
			void GetDriverControlString(UInt32 driverControl, Int32 bufSize, Int32[] length, String driverControlString) {
				unsafe
				{
					fixed (Int32* length_ptr = length) {
						Delegates.glGetDriverControlStringQCOM((UInt32) driverControl, (Int32) bufSize, (Int32*) length_ptr, (String) driverControlString);
					}
				}
			}

			/// <summary>[requires: 1.1]</summary>
			[System.CLSCompliant(false)]
			//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glGetDriverControlStringQCOM")]
#if NET45
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
			public static
			void GetDriverControlString(UInt32 driverControl, Int32 bufSize, ref Int32 length, String driverControlString) {
				unsafe
				{
					fixed (Int32* length_ptr = &length) {
						Delegates.glGetDriverControlStringQCOM((UInt32) driverControl, (Int32) bufSize, (Int32*) length_ptr, (String) driverControlString);
					}
				}
			}

			/// <summary>[requires: 1.1]</summary>
			[System.CLSCompliant(false)]
			//[AutoGenerated(Category = "1.1", Version = "1.1", EntryPoint = "glGetDriverControlStringQCOM")]
#if NET45
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
			public static
			unsafe void GetDriverControlString(UInt32 driverControl, Int32 bufSize, Int32* length, String driverControlString) {
				Delegates.glGetDriverControlStringQCOM((UInt32) driverControl, (Int32) bufSize, (Int32*) length, (String) driverControlString);
			}

		}


	}
}