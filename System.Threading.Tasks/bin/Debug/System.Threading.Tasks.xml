<?xml version="1.0"?>
<doc>
    <assembly>
        <name>System.Threading.Tasks</name>
    </assembly>
    <members>
        <member name="T:System.Threading.Barrier">
            <summary>
            Enables multiple tasks to cooperatively work on an algorithm in parallel through multiple phases.
            </summary>
            <remarks>
            <para>
            A group of tasks cooperate by moving through a series of phases, where each in the group signals it
            has arrived at the <see cref="T:System.Threading.Barrier" /> in a given phase and implicitly waits for all others to
            arrive. The same <see cref="T:System.Threading.Barrier" /> can be used for multiple phases.
            </para>
            <para>
            All public and protected members of <see cref="T:System.Threading.Barrier" /> are thread-safe and may be used
            concurrently from multiple threads, with the exception of Dispose, which
            must only be used when all other operations on the <see cref="T:System.Threading.Barrier" /> have
            completed.
            </para>
            </remarks>
        </member>
        <member name="P:System.Threading.Barrier.ParticipantsRemaining">
            <summary>
            Gets the number of participants in the barrier that havenâ€™t yet signaled
            in the current phase.
            </summary>
            <remarks>
            This could be 0 during a post-phase action delegate execution or if the
            ParticipantCount is 0.
            </remarks>
        </member>
        <member name="P:System.Threading.Barrier.ParticipantCount">
            <summary>Gets the total number of participants in the barrier.</summary>
        </member>
        <member name="P:System.Threading.Barrier.CurrentPhaseNumber">
            <summary>Gets the number of the barrier's current phase.</summary>
        </member>
        <member name="M:System.Threading.Barrier.#ctor(System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:System.Threading.Barrier" /> class.
            </summary>
            <param name="participantCount">The number of participating threads.</param>
            <exception cref="T:System.ArgumentOutOfRangeException"> <paramref name="participantCount" /> is less than 0
            or greater than <see cref="T:System.Int32.MaxValue" />.</exception>
        </member>
        <member name="M:System.Threading.Barrier.#ctor(System.Int32,System.Action{System.Threading.Barrier})">
            <summary>
            Initializes a new instance of the <see cref="T:System.Threading.Barrier" /> class.
            </summary>
            <param name="participantCount">The number of participating threads.</param>
            <param name="postPhaseAction">The <see cref="T:System.Action`1" /> to be executed after each
            phase.</param>
            <exception cref="T:System.ArgumentOutOfRangeException"> <paramref name="participantCount" /> is less than 0
            or greater than <see cref="T:System.Int32.MaxValue" />.</exception>
            <remarks>
            The <paramref name="postPhaseAction" /> delegate will be executed after
            all participants have arrived at the barrier in one phase.  The participants
            will not be released to the next phase until the postPhaseAction delegate
            has completed execution.
            </remarks>
        </member>
        <member name="M:System.Threading.Barrier.GetCurrentTotal(System.Int32,System.Int32@,System.Int32@,System.Boolean@)">
            <summary>
            Extract the three variables current, total and sense from a given big variable
            </summary>
            <param name="currentTotal">The integer variable that contains the other three variables</param>
            <param name="current">The current cparticipant count</param>
            <param name="total">The total participants count</param>
            <param name="sense">The sense flag</param>
        </member>
        <member name="M:System.Threading.Barrier.SetCurrentTotal(System.Int32,System.Int32,System.Int32,System.Boolean)">
            <summary>
            Write the three variables current. total and the sense to the m_currentTotal
            </summary>
            <param name="currentTotal">The old current total to compare</param>
            <param name="current">The current cparticipant count</param>
            <param name="total">The total participants count</param>
            <param name="sense">The sense flag</param>
            <returns>True if the CAS succeeded, false otherwise</returns>
        </member>
        <member name="M:System.Threading.Barrier.AddParticipant">
            <summary>
            Notifies the <see cref="T:System.Threading.Barrier" /> that there will be an additional participant.
            </summary>
            <returns>The phase number of the barrier in which the new participants will first
            participate.</returns>
            <exception cref="T:System.InvalidOperationException">
            Adding a participant would cause the barrier's participant count to
            exceed <see cref="T:System.Int16.MaxValue" />.
            </exception>
            <exception cref="T:System.InvalidOperationException">
            The method was invoked from within a post-phase action.
            </exception>
            <exception cref="T:System.ObjectDisposedException">The current instance has already been
            disposed.</exception>
        </member>
        <member name="M:System.Threading.Barrier.AddParticipants(System.Int32)">
            <summary>
            Notifies the <see cref="T:System.Threading.Barrier" /> that there will be additional participants.
            </summary>
            <param name="participantCount">The number of additional participants to add to the
            barrier.</param>
            <returns>The phase number of the barrier in which the new participants will first
            participate.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="participantCount" /> is less than
            0.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">Adding <paramref name="participantCount" /> participants would cause the
            barrier's participant count to exceed <see cref="T:System.Int16.MaxValue" />.</exception>
            <exception cref="T:System.InvalidOperationException">
            The method was invoked from within a post-phase action.
            </exception>
            <exception cref="T:System.ObjectDisposedException">The current instance has already been
            disposed.</exception>
        </member>
        <member name="M:System.Threading.Barrier.RemoveParticipant">
            <summary>
            Notifies the <see cref="T:System.Threading.Barrier" /> that there will be one less participant.
            </summary>
            <exception cref="T:System.InvalidOperationException">The barrier already has 0
            participants.</exception>
            <exception cref="T:System.InvalidOperationException">
            The method was invoked from within a post-phase action.
            </exception>
            <exception cref="T:System.ObjectDisposedException">The current instance has already been
            disposed.</exception>
        </member>
        <member name="M:System.Threading.Barrier.RemoveParticipants(System.Int32)">
            <summary>
            Notifies the <see cref="T:System.Threading.Barrier" /> that there will be fewer participants.
            </summary>
            <param name="participantCount">The number of additional participants to remove from the barrier.</param>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="participantCount" /> is less than
            0.</exception>
            <exception cref="T:System.InvalidOperationException">The barrier already has 0 participants.</exception>
            <exception cref="T:System.InvalidOperationException">
            The method was invoked from within a post-phase action.
            </exception>
            <exception cref="T:System.ObjectDisposedException">The current instance has already been
            disposed.</exception>
        </member>
        <member name="M:System.Threading.Barrier.SignalAndWait">
            <summary>
            Signals that a participant has reached the <see cref="T:System.Threading.Barrier" /> and waits for all other
            participants to reach the barrier as well.
            </summary>
            <exception cref="T:System.InvalidOperationException">
            The method was invoked from within a post-phase action, the barrier currently has 0 participants,
            or the barrier is being used by more threads than are registered as participants.
            </exception>
            <exception cref="T:System.ObjectDisposedException">The current instance has already been
            disposed.</exception>
        </member>
        <member name="M:System.Threading.Barrier.SignalAndWait(System.Threading.CancellationToken)">
            <summary>
            Signals that a participant has reached the <see cref="T:System.Threading.Barrier" /> and waits for all other
            participants to reach the barrier, while observing a <see cref="T:System.Threading.CancellationToken" />.
            </summary>
            <param name="cancellationToken">The <see cref="T:System.Threading.CancellationToken" /> to
            observe.</param>
            <exception cref="T:System.InvalidOperationException">
            The method was invoked from within a post-phase action, the barrier currently has 0 participants,
            or the barrier is being used by more threads than are registered as participants.
            </exception>
            <exception cref="T:System.OperationCanceledException"><paramref name="cancellationToken" /> has been
            canceled.</exception>
            <exception cref="T:System.ObjectDisposedException">The current instance has already been
            disposed.</exception>
        </member>
        <member name="M:System.Threading.Barrier.SignalAndWait(System.TimeSpan)">
            <summary>
            Signals that a participant has reached the <see cref="T:System.Threading.Barrier" /> and waits for all other
            participants to reach the barrier as well, using a
            <see cref="T:System.TimeSpan" /> to measure the time interval.
            </summary>
            <param name="timeout">A <see cref="T:System.TimeSpan" /> that represents the number of
            milliseconds to wait, or a <see cref="T:System.TimeSpan" /> that represents -1 milliseconds to
            wait indefinitely.</param>
            <returns>true if all other participants reached the barrier; otherwise, false.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="timeout" />is a negative number
            other than -1 milliseconds, which represents an infinite time-out, or it is greater than
            <see cref="T:System.Int32.MaxValue" />.</exception>
            <exception cref="T:System.InvalidOperationException">
            The method was invoked from within a post-phase action, the barrier currently has 0 participants,
            or the barrier is being used by more threads than are registered as participants.
            </exception>
            <exception cref="T:System.ObjectDisposedException">The current instance has already been
            disposed.</exception>
        </member>
        <member name="M:System.Threading.Barrier.SignalAndWait(System.TimeSpan,System.Threading.CancellationToken)">
            <summary>
            Signals that a participant has reached the <see cref="T:System.Threading.Barrier" /> and waits for all other
            participants to reach the barrier as well, using a
            <see cref="T:System.TimeSpan" /> to measure the time interval, while observing a <see cref="T:System.Threading.CancellationToken" />.
            </summary>
            <param name="timeout">A <see cref="T:System.TimeSpan" /> that represents the number of
            milliseconds to wait, or a <see cref="T:System.TimeSpan" /> that represents -1 milliseconds to
            wait indefinitely.</param>
            <param name="cancellationToken">The <see cref="T:System.Threading.CancellationToken" /> to
            observe.</param>
            <returns>true if all other participants reached the barrier; otherwise, false.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="timeout" />is a negative number
            other than -1 milliseconds, which represents an infinite time-out.</exception>
            <exception cref="T:System.InvalidOperationException">
            The method was invoked from within a post-phase action, the barrier currently has 0 participants,
            or the barrier is being used by more threads than are registered as participants.
            </exception>
            <exception cref="T:System.OperationCanceledException"><paramref name="cancellationToken" /> has been
            canceled.</exception>
            <exception cref="T:System.ObjectDisposedException">The current instance has already been
            disposed.</exception>
        </member>
        <member name="M:System.Threading.Barrier.SignalAndWait(System.Int32)">
            <summary>
            Signals that a participant has reached the <see cref="T:System.Threading.Barrier" /> and waits for all other
            participants to reach the barrier as well, using a
            32-bit signed integer to measure the time interval.
            </summary>
            <param name="millisecondsTimeout">The number of milliseconds to wait, or <see cref="F:System.Threading.Timeout.Infinite" />(-1) to wait indefinitely.</param>
            <returns>true if all other participants reached the barrier; otherwise, false.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="millisecondsTimeout" /> is a
            negative number other than -1, which represents an infinite time-out.</exception>
            <exception cref="T:System.InvalidOperationException">
            The method was invoked from within a post-phase action, the barrier currently has 0 participants,
            or the barrier is being used by more threads than are registered as participants.
            </exception>
            <exception cref="T:System.ObjectDisposedException">The current instance has already been
            disposed.</exception>
        </member>
        <member name="M:System.Threading.Barrier.SignalAndWait(System.Int32,System.Threading.CancellationToken)">
            <summary>
            Signals that a participant has reached the barrier and waits for all other participants to reach
            the barrier as well, using a
            32-bit signed integer to measure the time interval, while observing a <see cref="T:System.Threading.CancellationToken" />.
            </summary>
            <param name="millisecondsTimeout">The number of milliseconds to wait, or <see cref="F:System.Threading.Timeout.Infinite" />(-1) to wait indefinitely.</param>
            <param name="cancellationToken">The <see cref="T:System.Threading.CancellationToken" /> to
            observe.</param>
            <returns>true if all other participants reached the barrier; otherwise, false.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="millisecondsTimeout" /> is a
            negative number other than -1, which represents an infinite time-out.</exception>
            <exception cref="T:System.InvalidOperationException">
            The method was invoked from within a post-phase action, the barrier currently has 0 participants,
            or the barrier is being used by more threads than are registered as participants.
            </exception>
            <exception cref="T:System.OperationCanceledException"><paramref name="cancellationToken" /> has been
            canceled.</exception>
            <exception cref="T:System.ObjectDisposedException">The current instance has already been
            disposed.</exception>
        </member>
        <member name="M:System.Threading.Barrier.FinishPhase(System.Boolean)">
            <summary>
            Finish the phase by invoking the post phase action, and setting the event, this must be called by the
            last arrival thread
            </summary>
            <param name="observedSense">The current phase sense</param>
        </member>
        <member name="M:System.Threading.Barrier.SetResetEvents(System.Boolean)">
            <summary>
            Sets the current phase event and reset the next phase event
            </summary>
            <param name="observedSense">The current phase sense</param>
        </member>
        <member name="M:System.Threading.Barrier.Dispose">
            <summary>
            Releases all resources used by the current instance of <see cref="T:System.Threading.Barrier" />.
            </summary>
            <exception cref="T:System.InvalidOperationException">
            The method was invoked from within a post-phase action.
            </exception>
            <remarks>
            Unlike most of the members of <see cref="T:System.Threading.Barrier" />, Dispose is not thread-safe and may not be
            used concurrently with other members of this instance.
            </remarks>
        </member>
        <member name="M:System.Threading.Barrier.Dispose(System.Boolean)">
            <summary>
            When overridden in a derived class, releases the unmanaged resources used by the
            <see cref="T:System.Threading.Barrier" />, and optionally releases the managed resources.
            </summary>
            <param name="disposing">true to release both managed and unmanaged resources; false to release
            only unmanaged resources.</param>
            <remarks>
            Unlike most of the members of <see cref="T:System.Threading.Barrier" />, Dispose is not thread-safe and may not be
            used concurrently with other members of this instance.
            </remarks>
        </member>
        <member name="M:System.Threading.Barrier.ThrowIfDisposed">
            <summary>
            Throw ObjectDisposedException if the barrier is disposed
            </summary>
        </member>
        <member name="T:System.Threading.BarrierPostPhaseException">
            <summary>
            The exception that is thrown when the post-phase action of a <see cref="T:System.Threading.Barrier" /> fails.
            </summary>
        </member>
        <member name="M:System.Threading.BarrierPostPhaseException.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:System.Threading.BarrierPostPhaseException" /> class.
            </summary>
        </member>
        <member name="M:System.Threading.BarrierPostPhaseException.#ctor(System.Exception)">
            <summary>
            Initializes a new instance of the <see cref="T:System.Threading.BarrierPostPhaseException" /> class with the specified inner exception.
            </summary>
            <param name="innerException">The exception that is the cause of the current exception.</param>
        </member>
        <member name="M:System.Threading.BarrierPostPhaseException.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:System.Threading.BarrierPostPhaseException" /> class with a specified error message.
            </summary>
            <param name="message">A string that describes the exception.</param>
        </member>
        <member name="M:System.Threading.BarrierPostPhaseException.#ctor(System.String,System.Exception)">
            <summary>
            Initializes a new instance of the <see cref="T:System.Threading.BarrierPostPhaseException" /> class with a specified error message and inner exception.
            </summary>
            <param name="message">A string that describes the exception.</param>
            <param name="innerException">The exception that is the cause of the current exception.</param>
        </member>
        <member name="M:System.Threading.BarrierPostPhaseException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Initializes a new instance of the <see cref="T:System.Threading.BarrierPostPhaseException" /> class with serialized data.
            </summary>
            <param name="info">The object that holds the serialized object data.</param>
            <param name="context">An object that describes the source or destination of the serialized data.</param>
        </member>
        <member name="T:System.Threading.CancellationCallbackInfo">
            <summary>
            A helper class for collating the various bits of information required to execute
            cancellation callbacks.
            </summary>
        </member>
        <member name="M:System.Threading.CancellationCallbackInfo.ExecuteCallback">
            <summary>
            InternalExecuteCallbackSynchronously_GeneralPath
            This will be called on the target synchronization context, however, we still need to restore the required execution context
            </summary>
        </member>
        <member name="T:System.Threading.LazyInitializer">
            <summary>Provides lazy initialization routines.</summary>
            <remarks>
            These routines avoid needing to allocate a dedicated, lazy-initialization instance, instead using
            references to ensure targets have been initialized as they are accessed.
            </remarks>
        </member>
        <member name="M:System.Threading.LazyInitializer.EnsureInitialized``1(``0@)">
            <summary>
            Initializes a target reference type with the type's default constructor if the target has not
            already been initialized.
            </summary>
            <typeparam name="T">The refence type of the reference to be initialized.</typeparam>
            <param name="target">A reference of type <typeparamref name="T" /> to initialize if it has not
            already been initialized.</param>
            <returns>The initialized reference of type <typeparamref name="T" />.</returns>
            <exception cref="T:System.MissingMemberException">Type <typeparamref name="T" /> does not have a default
            constructor.</exception>
            <exception cref="T:System.MemberAccessException">
            Permissions to access the constructor of type <typeparamref name="T" /> were missing.
            </exception>
            <remarks>
            <para>
            This method may only be used on reference types. To ensure initialization of value
            types, see other overloads of EnsureInitialized.
            </para>
            <para>
            This method may be used concurrently by multiple threads to initialize <paramref name="target" />.
            In the event that multiple threads access this method concurrently, multiple instances of <typeparamref name="T" />
            may be created, but only one will be stored into <paramref name="target" />. In such an occurrence, this method will not dispose of the
            objects that were not stored.  If such objects must be disposed, it is up to the caller to determine
            if an object was not used and to then dispose of the object appropriately.
            </para>
            </remarks>
        </member>
        <member name="M:System.Threading.LazyInitializer.EnsureInitialized``1(``0@,System.Func{``0})">
            <summary>
            Initializes a target reference type using the specified function if it has not already been
            initialized.
            </summary>
            <typeparam name="T">The reference type of the reference to be initialized.</typeparam>
            <param name="target">The reference of type <typeparamref name="T" /> to initialize if it has not
            already been initialized.</param>
            <param name="valueFactory">The <see cref="T:System.Func{T}" /> invoked to initialize the
            reference.</param>
            <returns>The initialized reference of type <typeparamref name="T" />.</returns>
            <exception cref="T:System.MissingMemberException">Type <typeparamref name="T" /> does not have a
            default constructor.</exception>
            <exception cref="T:System.InvalidOperationException"><paramref name="valueFactory" /> returned
            null.</exception>
            <remarks>
            <para>
            This method may only be used on reference types, and <paramref name="valueFactory" /> may
            not return a null reference (Nothing in Visual Basic). To ensure initialization of value types or
            to allow null reference types, see other overloads of EnsureInitialized.
            </para>
            <para>
            This method may be used concurrently by multiple threads to initialize <paramref name="target" />.
            In the event that multiple threads access this method concurrently, multiple instances of <typeparamref name="T" />
            may be created, but only one will be stored into <paramref name="target" />. In such an occurrence, this method will not dispose of the
            objects that were not stored.  If such objects must be disposed, it is up to the caller to determine
            if an object was not used and to then dispose of the object appropriately.
            </para>
            </remarks>
        </member>
        <member name="M:System.Threading.LazyInitializer.EnsureInitializedCore``1(``0@,System.Func{``0})">
            <summary>
            Initialize the target using the given delegate (slow path).
            </summary>
            <typeparam name="T">The reference type of the reference to be initialized.</typeparam>
            <param name="target">The variable that need to be initialized</param>
            <param name="valueFactory">The delegate that will be executed to initialize the target</param>
            <returns>The initialized variable</returns>
        </member>
        <member name="M:System.Threading.LazyInitializer.EnsureInitialized``1(``0@,System.Boolean@,System.Object@)">
            <summary>
            Initializes a target reference or value type with its default constructor if it has not already
            been initialized.
            </summary>
            <typeparam name="T">The type of the reference to be initialized.</typeparam>
            <param name="target">A reference or value of type <typeparamref name="T" /> to initialize if it
            has not already been initialized.</param>
            <param name="initialized">A reference to a boolean that determines whether the target has already
            been initialized.</param>
            <param name="syncLock">A reference to an object used as the mutually exclusive lock for initializing
            <paramref name="target" />.</param>
            <returns>The initialized value of type <typeparamref name="T" />.</returns>
        </member>
        <member name="M:System.Threading.LazyInitializer.EnsureInitialized``1(``0@,System.Boolean@,System.Object@,System.Func{``0})">
            <summary>
            Initializes a target reference or value type with a specified function if it has not already been
            initialized.
            </summary>
            <typeparam name="T">The type of the reference to be initialized.</typeparam>
            <param name="target">A reference or value of type <typeparamref name="T" /> to initialize if it
            has not already been initialized.</param>
            <param name="initialized">A reference to a boolean that determines whether the target has already
            been initialized.</param>
            <param name="syncLock">A reference to an object used as the mutually exclusive lock for initializing
            <paramref name="target" />.</param>
            <param name="valueFactory">The <see cref="T:System.Func{T}" /> invoked to initialize the
            reference or value.</param>
            <returns>The initialized value of type <typeparamref name="T" />.</returns>
        </member>
        <member name="M:System.Threading.LazyInitializer.EnsureInitializedCore``1(``0@,System.Boolean@,System.Object@,System.Func{``0})">
            <summary>
            Ensure the target is initialized and return the value (slow path). This overload permits nulls
            and also works for value type targets. Uses the supplied function to create the value.
            </summary>
            <typeparam name="T">The type of target.</typeparam>
            <param name="target">A reference to the target to be initialized.</param>
            <param name="initialized">A reference to a location tracking whether the target has been initialized.</param>
            <param name="syncLock">A reference to a location containing a mutual exclusive lock.</param>
            <param name="valueFactory">
            The <see cref="T:System.Func{T}" /> to invoke in order to produce the lazily-initialized value.
            </param>
            <returns>The initialized object.</returns>
        </member>
        <member name="T:System.Threading.LazyThreadSafetyMode">
            <summary>
            Specifies how a <see cref="T:System.Threading.Lazy{T}" /> instance should synchronize access among multiple threads.
            </summary>
        </member>
        <member name="T:System.Threading.SemaphoreSlim">
            <summary>
            Limits the number of threads that can access a resource or pool of resources concurrently.
            </summary>
            <remarks>
            <para>
            The <see cref="T:System.Threading.SemaphoreSlim" /> provides a lightweight semaphore class that doesn't
            use Windows kernel semaphores.
            </para>
            <para>
            All public and protected members of <see cref="T:System.Threading.SemaphoreSlim" /> are thread-safe and may be used
            concurrently from multiple threads, with the exception of Dispose, which
            must only be used when all other operations on the <see cref="T:System.Threading.SemaphoreSlim" /> have
            completed.
            </para>
            </remarks>
        </member>
        <member name="F:System.Threading.SemaphoreSlim.s_cancellationTokenCanceledEventHandler">
            <summary>
            Private helper method to wake up waiters when a cancellationToken gets canceled.
            </summary>
        </member>
        <member name="P:System.Threading.SemaphoreSlim.CurrentCount">
            <summary>
            Gets the current count of the <see cref="T:System.Threading.SemaphoreSlim" />.
            </summary>
            <value>The current count of the <see cref="T:System.Threading.SemaphoreSlim" />.</value>
        </member>
        <member name="P:System.Threading.SemaphoreSlim.AvailableWaitHandle">
            <summary>
            Returns a <see cref="T:System.Threading.WaitHandle" /> that can be used to wait on the semaphore.
            </summary>
            <value>A <see cref="T:System.Threading.WaitHandle" /> that can be used to wait on the
            semaphore.</value>
            <remarks>
            A successful wait on the <see cref="P:System.Threading.SemaphoreSlim.AvailableWaitHandle" /> does not imply a successful wait on
            the <see cref="T:System.Threading.SemaphoreSlim" /> itself, nor does it decrement the semaphore's
            count. <see cref="P:System.Threading.SemaphoreSlim.AvailableWaitHandle" /> exists to allow a thread to block waiting on multiple
            semaphores, but such a wait should be followed by a true wait on the target semaphore.
            </remarks>
            <exception cref="T:System.ObjectDisposedException">The <see cref="T:System.Threading.SemaphoreSlim" /> has been disposed.</exception>
        </member>
        <member name="M:System.Threading.SemaphoreSlim.#ctor(System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:System.Threading.SemaphoreSlim" /> class, specifying
            the initial number of requests that can be granted concurrently.
            </summary>
            <param name="initialCount">The initial number of requests for the semaphore that can be granted
            concurrently.</param>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="initialCount" />
            is less than 0.</exception>
        </member>
        <member name="M:System.Threading.SemaphoreSlim.#ctor(System.Int32,System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:System.Threading.SemaphoreSlim" /> class, specifying
            the initial and maximum number of requests that can be granted concurrently.
            </summary>
            <param name="initialCount">The initial number of requests for the semaphore that can be granted
            concurrently.</param>
            <param name="maxCount">The maximum number of requests for the semaphore that can be granted
            concurrently.</param>
            <exception cref="T:System.ArgumentOutOfRangeException"> <paramref name="initialCount" />
            is less than 0. -or-
            <paramref name="initialCount" /> is greater than <paramref name="maxCount" />. -or-
            <paramref name="maxCount" /> is less than 0.</exception>
        </member>
        <member name="M:System.Threading.SemaphoreSlim.Wait">
            <summary>
            Blocks the current thread until it can enter the <see cref="T:System.Threading.SemaphoreSlim" />.
            </summary>
            <exception cref="T:System.ObjectDisposedException">The current instance has already been
            disposed.</exception>
        </member>
        <member name="M:System.Threading.SemaphoreSlim.Wait(System.Threading.CancellationToken)">
            <summary>
            Blocks the current thread until it can enter the <see cref="T:System.Threading.SemaphoreSlim" />, while observing a
            <see cref="T:System.Threading.CancellationToken" />.
            </summary>
            <param name="cancellationToken">The <see cref="T:System.Threading.CancellationToken" /> token to
            observe.</param>
            <exception cref="T:System.OperationCanceledException"><paramref name="cancellationToken" /> was
            canceled.</exception>
            <exception cref="T:System.ObjectDisposedException">The current instance has already been
            disposed.</exception>
        </member>
        <member name="M:System.Threading.SemaphoreSlim.Wait(System.TimeSpan)">
            <summary>
            Blocks the current thread until it can enter the <see cref="T:System.Threading.SemaphoreSlim" />, using a <see cref="T:System.TimeSpan" /> to measure the time interval.
            </summary>
            <param name="timeout">A <see cref="T:System.TimeSpan" /> that represents the number of milliseconds
            to wait, or a <see cref="T:System.TimeSpan" /> that represents -1 milliseconds to wait indefinitely.
            </param>
            <returns>true if the current thread successfully entered the <see cref="T:System.Threading.SemaphoreSlim" />;
            otherwise, false.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="timeout" /> is a negative
            number other than -1 milliseconds, which represents an infinite time-out -or- timeout is greater
            than <see cref="F:System.Int32.MaxValue" />.</exception>
        </member>
        <member name="M:System.Threading.SemaphoreSlim.Wait(System.TimeSpan,System.Threading.CancellationToken)">
            <summary>
            Blocks the current thread until it can enter the <see cref="T:System.Threading.SemaphoreSlim" />, using a <see cref="T:System.TimeSpan" /> to measure the time interval, while observing a <see cref="T:System.Threading.CancellationToken" />.
            </summary>
            <param name="timeout">A <see cref="T:System.TimeSpan" /> that represents the number of milliseconds
            to wait, or a <see cref="T:System.TimeSpan" /> that represents -1 milliseconds to wait indefinitely.
            </param>
            <param name="cancellationToken">The <see cref="T:System.Threading.CancellationToken" /> to
            observe.</param>
            <returns>true if the current thread successfully entered the <see cref="T:System.Threading.SemaphoreSlim" />;
            otherwise, false.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="timeout" /> is a negative
            number other than -1 milliseconds, which represents an infinite time-out -or- timeout is greater
            than <see cref="F:System.Int32.MaxValue" />.</exception>
            <exception cref="T:System.OperationCanceledException"><paramref name="cancellationToken" /> was canceled.</exception>
        </member>
        <member name="M:System.Threading.SemaphoreSlim.Wait(System.Int32)">
            <summary>
            Blocks the current thread until it can enter the <see cref="T:System.Threading.SemaphoreSlim" />, using a 32-bit
            signed integer to measure the time interval.
            </summary>
            <param name="millisecondsTimeout">The number of milliseconds to wait, or <see cref="F:System.Threading.Timeout.Infinite" />(-1) to wait indefinitely.</param>
            <returns>true if the current thread successfully entered the <see cref="T:System.Threading.SemaphoreSlim" />;
            otherwise, false.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="millisecondsTimeout" /> is a
            negative number other than -1, which represents an infinite time-out.</exception>
        </member>
        <member name="M:System.Threading.SemaphoreSlim.Wait(System.Int32,System.Threading.CancellationToken)">
            <summary>
            Blocks the current thread until it can enter the <see cref="T:System.Threading.SemaphoreSlim" />,
            using a 32-bit signed integer to measure the time interval,
            while observing a <see cref="T:System.Threading.CancellationToken" />.
            </summary>
            <param name="millisecondsTimeout">The number of milliseconds to wait, or <see cref="F:System.Threading.Timeout.Infinite" />(-1) to
            wait indefinitely.</param>
            <param name="cancellationToken">The <see cref="T:System.Threading.CancellationToken" /> to observe.</param>
            <returns>true if the current thread successfully entered the <see cref="T:System.Threading.SemaphoreSlim" />; otherwise, false.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="millisecondsTimeout" /> is a negative number other than -1,
            which represents an infinite time-out.</exception>
            <exception cref="T:System.OperationCanceledException"><paramref name="cancellationToken" /> was canceled.</exception>
        </member>
        <member name="M:System.Threading.SemaphoreSlim.WaitUntilCountOrTimeout(System.Int32,System.Int64,System.Threading.CancellationToken)">
            <summary>
            Local helper function, waits on the monitor until the monitor recieves signal or the
            timeout is expired
            </summary>
            <param name="millisecondsTimeout">The maximum timeout</param>
            <param name="startTimeTicks">The start ticks to calculate the elapsed time</param>
            <param name="cancellationToken">The CancellationToken to observe.</param>
            <returns>true if the monitor recieved a signal, false if the timeout expired</returns>
        </member>
        <member name="M:System.Threading.SemaphoreSlim.Release">
            <summary>
            Exits the <see cref="T:System.Threading.SemaphoreSlim" /> once.
            </summary>
            <returns>The previous count of the <see cref="T:System.Threading.SemaphoreSlim" />.</returns>
            <exception cref="T:System.ObjectDisposedException">The current instance has already been
            disposed.</exception>
        </member>
        <member name="M:System.Threading.SemaphoreSlim.Release(System.Int32)">
            <summary>
            Exits the <see cref="T:System.Threading.SemaphoreSlim" /> a specified number of times.
            </summary>
            <param name="releaseCount">The number of times to exit the semaphore.</param>
            <returns>The previous count of the <see cref="T:System.Threading.SemaphoreSlim" />.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="releaseCount" /> is less
            than 1.</exception>
            <exception cref="T:System.Threading.SemaphoreFullException">The <see cref="T:System.Threading.SemaphoreSlim" /> has
            already reached its maximum size.</exception>
            <exception cref="T:System.ObjectDisposedException">The current instance has already been
            disposed.</exception>
        </member>
        <member name="M:System.Threading.SemaphoreSlim.Dispose">
            <summary>
            Releases all resources used by the current instance of <see cref="T:System.Threading.SemaphoreSlim" />.
            </summary>
            <remarks>
            Unlike most of the members of <see cref="T:System.Threading.SemaphoreSlim" />, <see cref="M:System.Threading.SemaphoreSlim.Dispose" /> is not
            thread-safe and may not be used concurrently with other members of this instance.
            </remarks>
        </member>
        <member name="M:System.Threading.SemaphoreSlim.Dispose(System.Boolean)">
            <summary>
            When overridden in a derived class, releases the unmanaged resources used by the
            <see cref="T:System.Threading.ManualResetEventSlim" />, and optionally releases the managed resources.
            </summary>
            <param name="disposing">true to release both managed and unmanaged resources;
            false to release only unmanaged resources.</param>
            <remarks>
            Unlike most of the members of <see cref="T:System.Threading.SemaphoreSlim" />, <see cref="M:System.Threading.SemaphoreSlim.Dispose(System.Boolean)" /> is not
            thread-safe and may not be used concurrently with other members of this instance.
            </remarks>
        </member>
        <member name="M:System.Threading.SemaphoreSlim.UpdateTimeOut(System.Int64,System.Int32)">
            <summary>Helper function to measure and update the wait time</summary>
            <param name="startTimeTicks"> The first time (in Ticks) observed when the wait started</param>
            <param name="originalWaitMillisecondsTimeout">The orginal wait timeoutout in milliseconds</param>
            <returns>The new wait time in milliseconds, -1 if the time expired</returns>
        </member>
        <member name="M:System.Threading.SemaphoreSlim.CheckDispose">
            <summary>
            Checks the dispose status by checking the lock object, if it is null means that object
            has been disposed and throw ObjectDisposedException
            </summary>
        </member>
        <member name="M:System.Threading.SemaphoreSlim.GetResourceString(System.String)">
            <summary>
            local helper function to retrieve the exception string message from the resource file
            </summary>
            <param name="str">The key string</param>
        </member>
        <member name="T:System.Threading.SparselyPopulatedArray`1">
            <summary>
            A sparsely populated array.  Elements can be sparse and some null, but this allows for
            lock-free additions and growth, and also for constant time removal (by nulling out).
            </summary>
            <typeparam name="T">The kind of elements contained within.</typeparam>
        </member>
        <member name="P:System.Threading.SparselyPopulatedArray`1.Head">
            <summary>The head of the doubly linked list.</summary>
        </member>
        <member name="P:System.Threading.SparselyPopulatedArray`1.Tail">
            <summary>The tail of the doubly linked list.</summary>
        </member>
        <member name="M:System.Threading.SparselyPopulatedArray`1.#ctor(System.Int32)">
            <summary>Allocates a new array with the given initial size.</summary>
            <param name="initialSize">How many array slots to pre-allocate.</param>
        </member>
        <member name="M:System.Threading.SparselyPopulatedArray`1.Add(`0)">
            <summary>
            Adds an element in the first available slot, beginning the search from the tail-to-head.
            If no slots are available, the array is grown.  The method doesn't return until successful.
            </summary>
            <param name="element">The element to add.</param>
            <returns>Information about where the add happened, to enable O(1) deregistration.</returns>
        </member>
        <member name="T:System.Threading.SparselyPopulatedArrayAddInfo`1">
            <summary>
            A struct to hold a link to the exact spot in an array an element was inserted, enabling
            constant time removal later on.
            </summary>
        </member>
        <member name="T:System.Threading.SparselyPopulatedArrayFragment`1">
            <summary>
            A fragment of a sparsely populated array, doubly linked.
            </summary>
            <typeparam name="T">The kind of elements contained within.</typeparam>
        </member>
        <member name="T:System.Threading.SpinLock">
            <summary>
            Provides a mutual exclusion lock primitive where a thread trying to acquire the lock waits in a loop
            repeatedly checking until the lock becomes available.
            </summary>
            <remarks>
            <para>
            Spin locks can be used for leaf-level locks where the object allocation implied by using a <see cref="T:System.Threading.Monitor" />, in size or due to garbage collection pressure, is overly
            expensive. Avoiding blocking is another reason that a spin lock can be useful, however if you expect
            any significant amount of blocking, you are probably best not using spin locks due to excessive
            spinning. Spinning can be beneficial when locks are fine grained and large in number (for example, a
            lock per node in a linked list) as well as when lock hold times are always extremely short. In
            general, while holding a spin lock, one should avoid blocking, calling anything that itself may
            block, holding more than one spin lock at once, making dynamically dispatched calls (interface and
            virtuals), making statically dispatched calls into any code one doesn't own, or allocating memory.
            </para>
            <para>
            <see cref="T:System.Threading.SpinLock" /> should only be used when it's been determined that doing so will improve an
            application's performance. It's also important to note that <see cref="T:System.Threading.SpinLock" /> is a value type,
            for performance reasons. As such, one must be very careful not to accidentally copy a SpinLock
            instance, as the two instances (the original and the copy) would then be completely independent of
            one another, which would likely lead to erroneous behavior of the application. If a SpinLock instance
            must be passed around, it should be passed by reference rather than by value.
            </para>
            <para>
            Do not store <see cref="T:System.Threading.SpinLock" /> instances in readonly fields.
            </para>
            <para>
            All members of <see cref="T:System.Threading.SpinLock" /> are thread-safe and may be used from multiple threads
            concurrently.
            </para>
            </remarks>
        </member>
        <member name="P:System.Threading.SpinLock.IsHeld">
            <summary>
            Gets whether the lock is currently held by any thread.
            </summary>
        </member>
        <member name="P:System.Threading.SpinLock.IsHeldByCurrentThread">
            <summary>
            Gets whether the lock is currently held by any thread.
            </summary>
            <summary>Gets whether the lock is held by the current thread.</summary>
            <remarks>
            If the lock was initialized to track owner threads, this will return whether the lock is acquired
            by the current thread. It is invalid to use this property when the lock was initialized to not
            track thread ownership.
            </remarks>
            <exception cref="T:System.InvalidOperationException">
            Thread ownership tracking is disabled.
            </exception>
        </member>
        <member name="P:System.Threading.SpinLock.IsThreadOwnerTrackingEnabled">
            <summary>Gets whether thread ownership tracking is enabled for this instance.</summary>
        </member>
        <member name="M:System.Threading.SpinLock.#ctor(System.Boolean)">
            <summary>
            Initializes a new instance of the <see cref="T:System.Threading.SpinLock" />
            structure with the option to track thread IDs to improve debugging.
            </summary>
            <remarks>
            The default constructor for <see cref="T:System.Threading.SpinLock" /> tracks thread ownership.
            </remarks>
            <param name="enableThreadOwnerTracking">Whether to capture and use thread IDs for debugging
            purposes.</param>
        </member>
        <member name="M:System.Threading.SpinLock.Enter(System.Boolean@)">
            <summary>
            Initializes a new instance of the <see cref="T:System.Threading.SpinLock" />
            structure with the option to track thread IDs to improve debugging.
            </summary>
            <remarks>
            The default constructor for <see cref="T:System.Threading.SpinLock" /> tracks thread ownership.
            </remarks>
            <summary>
            Acquires the lock in a reliable manner, such that even if an exception occurs within the method
            call, <paramref name="lockTaken" /> can be examined reliably to determine whether the lock was
            acquired.
            </summary>
            <remarks>
            <see cref="T:System.Threading.SpinLock" /> is a non-reentrant lock, meaning that if a thread holds the lock, it is
            not allowed to enter the lock again. If thread ownership tracking is enabled (whether it's
            enabled is available through <see cref="P:System.Threading.SpinLock.IsThreadOwnerTrackingEnabled" />), an exception will be
            thrown when a thread tries to re-enter a lock it already holds. However, if thread ownership
            tracking is disabled, attempting to enter a lock already held will result in deadlock.
            </remarks>
            <param name="lockTaken">True if the lock is acquired; otherwise, false. <paramref name="lockTaken" /> must be initialized to false prior to calling this method.</param>
            <exception cref="T:System.Threading.LockRecursionException">
            Thread ownership tracking is enabled, and the current thread has already acquired this lock.
            </exception>
            <exception cref="T:System.ArgumentException">
            The <paramref name="lockTaken" /> argument must be initialized to false prior to calling Enter.
            </exception>
        </member>
        <member name="M:System.Threading.SpinLock.TryEnter(System.Boolean@)">
            <summary>
            Attempts to acquire the lock in a reliable manner, such that even if an exception occurs within
            the method call, <paramref name="lockTaken" /> can be examined reliably to determine whether the
            lock was acquired.
            </summary>
            <remarks>
            Unlike <see cref="M:System.Threading.SpinLock.Enter(System.Boolean@)" />, TryEnter will not block waiting for the lock to be available. If the
            lock is not available when TryEnter is called, it will return immediately without any further
            spinning.
            </remarks>
            <param name="lockTaken">True if the lock is acquired; otherwise, false. <paramref name="lockTaken" /> must be initialized to false prior to calling this method.</param>
            <exception cref="T:System.Threading.LockRecursionException">
            Thread ownership tracking is enabled, and the current thread has already acquired this lock.
            </exception>
            <exception cref="T:System.ArgumentException">
            The <paramref name="lockTaken" /> argument must be initialized to false prior to calling TryEnter.
            </exception>
        </member>
        <member name="M:System.Threading.SpinLock.TryEnter(System.TimeSpan,System.Boolean@)">
            <summary>
            Attempts to acquire the lock in a reliable manner, such that even if an exception occurs within
            the method call, <paramref name="lockTaken" /> can be examined reliably to determine whether the
            lock was acquired.
            </summary>
            <remarks>
            Unlike <see cref="M:System.Threading.SpinLock.Enter(System.Boolean@)" />, TryEnter will not block indefinitely waiting for the lock to be
            available. It will block until either the lock is available or until the <paramref name="timeout" />
            has expired.
            </remarks>
            <param name="timeout">A <see cref="T:System.TimeSpan" /> that represents the number of milliseconds
            to wait, or a <see cref="T:System.TimeSpan" /> that represents -1 milliseconds to wait indefinitely.
            </param>
            <param name="lockTaken">True if the lock is acquired; otherwise, false. <paramref name="lockTaken" /> must be initialized to false prior to calling this method.</param>
            <exception cref="T:System.Threading.LockRecursionException">
            Thread ownership tracking is enabled, and the current thread has already acquired this lock.
            </exception>
            <exception cref="T:System.ArgumentException">
            The <paramref name="lockTaken" /> argument must be initialized to false prior to calling TryEnter.
            </exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="timeout" /> is a negative
            number other than -1 milliseconds, which represents an infinite time-out -or- timeout is greater
            than <see cref="F:System.Int32.MaxValue" /> milliseconds.
            </exception>
        </member>
        <member name="M:System.Threading.SpinLock.TryEnter(System.Int32,System.Boolean@)">
            <summary>
            Attempts to acquire the lock in a reliable manner, such that even if an exception occurs within
            the method call, <paramref name="lockTaken" /> can be examined reliably to determine whether the
            lock was acquired.
            </summary>
            <remarks>
            Unlike <see cref="M:System.Threading.SpinLock.Enter(System.Boolean@)" />, TryEnter will not block indefinitely waiting for the lock to be
            available. It will block until either the lock is available or until the <paramref name="millisecondsTimeout" /> has expired.
            </remarks>
            <param name="millisecondsTimeout">The number of milliseconds to wait, or <see cref="F:System.Threading.Timeout.Infinite" /> (-1) to wait indefinitely.</param>
            <param name="lockTaken">True if the lock is acquired; otherwise, false. <paramref name="lockTaken" /> must be initialized to false prior to calling this method.</param>
            <exception cref="T:System.Threading.LockRecursionException">
            Thread ownership tracking is enabled, and the current thread has already acquired this lock.
            </exception>
            <exception cref="T:System.ArgumentException">
            The <paramref name="lockTaken" /> argument must be initialized to false prior to calling TryEnter.
            </exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="millisecondsTimeout" /> is
            a negative number other than -1, which represents an infinite time-out.</exception>
        </member>
        <member name="M:System.Threading.SpinLock.ContinueTryEnter(System.Int32,System.Boolean@)">
            <summary>
            Try acquire the lock with long path, this is usually called after the first path in Enter and
            TryEnter failed The reason for short path is to make it inline in the run time which improves the
            performance. This method assumed that the parameter are validated in Enter ir TryENter method
            </summary>
            <param name="millisecondsTimeout">The timeout milliseconds</param>
            <param name="lockTaken">The lockTaken param</param>
        </member>
        <member name="M:System.Threading.SpinLock.DecrementWaiters">
            <summary>
            decrements the waiters, in case of the timeout is expired
            </summary>
        </member>
        <member name="M:System.Threading.SpinLock.ContinueTryEnterWithThreadTracking(System.Int32,System.Int64,System.Boolean@)">
            <summary>ContinueTryEnter for the thread tracking mode enabled</summary>
        </member>
        <member name="M:System.Threading.SpinLock.TimeoutExpired(System.Int64,System.Int32)">
            <summary>Helper function to validate the timeout</summary>
            <param name="startTicks"> The start time in ticks</param>
            <param name="originalWaitTime">The orginal wait time</param>
            <returns>True if expired, false otherwise</returns>
        </member>
        <member name="M:System.Threading.SpinLock.Exit">
            <summary>Releases the lock.</summary>
            <remarks>
            The default overload of <see cref="M:System.Threading.SpinLock.Exit" /> provides the same behavior as if calling <see cref="M:System.Threading.SpinLock.Exit(System.Boolean)" /> using true as the argument.
            </remarks>
            <exception cref="T:System.Threading.SynchronizationLockException">
            Thread ownership tracking is enabled, and the current thread is not the owner of this lock.
            </exception>
        </member>
        <member name="M:System.Threading.SpinLock.Exit(System.Boolean)">
            <summary>Releases the lock.</summary>
            <param name="useMemoryBarrier">
            A Boolean value that indicates whether a memory fence should be issued in order to immediately
            publish the exit operation to other threads.
            </param>
            <remarks>
            Calling <see cref="M:System.Threading.SpinLock.Exit(System.Boolean)" /> with the <paramref name="useMemoryBarrier" /> argument set to
            true will improve the fairness of the lock at the expense of some performance. The default <see cref="M:System.Threading.SpinLock.Enter(System.Boolean@)" />
            overload behaves as if specifying true for <paramref name="useMemoryBarrier" />.
            </remarks>
            <exception cref="T:System.Threading.SynchronizationLockException">
            Thread ownership tracking is enabled, and the current thread is not the owner of this lock.
            </exception>
        </member>
        <member name="T:System.Threading.SpinLock.SystemThreading_SpinLockDebugView">
            <summary>
            Internal class used by debug type proxy attribute to display the owner thread ID
            </summary>
        </member>
        <member name="P:System.Threading.SpinLock.SystemThreading_SpinLockDebugView.IsHeldByCurrentThread">
            <summary>
            Checks if the lock is held by the current thread or not
            </summary>
        </member>
        <member name="P:System.Threading.SpinLock.SystemThreading_SpinLockDebugView.OwnerThreadID">
            <summary>Gets the current owner thread, zero if it is released</summary>
        </member>
        <member name="P:System.Threading.SpinLock.SystemThreading_SpinLockDebugView.IsHeld">
            <summary>
             Gets whether the lock is currently held by any thread or not.
            </summary>
        </member>
        <member name="M:System.Threading.SpinLock.SystemThreading_SpinLockDebugView.#ctor(System.Threading.SpinLock)">
            <summary>SystemThreading_SpinLockDebugView constructor</summary>
            <param name="spinLock">The SpinLock to be proxied.</param>
        </member>
        <member name="T:System.Threading.ThreadLocal`1">
            <summary>Provides thread-local storage of data.</summary>
            <typeparam name="T">Specifies the type of data stored per-thread.</typeparam>
            <remarks>
            <para>
            With the exception of <see cref="M:System.Threading.ThreadLocal`1.Dispose" />, all public and protected members of
            <see cref="T:System.Threading.ThreadLocal`1" /> are thread-safe and may be used
            concurrently from multiple threads.
            </para>
            </remarks>
        </member>
        <member name="P:System.Threading.ThreadLocal`1.Value">
            <summary>
            Gets or sets the value of this instance for the current thread.
            </summary>
            <exception cref="T:System.InvalidOperationException">
            The initialization function referenced <see cref="P:System.Threading.ThreadLocal`1.Value" /> in an improper manner.
            </exception>
            <exception cref="T:System.ObjectDisposedException">
            The <see cref="T:System.Threading.ThreadLocal`1" /> instance has been disposed.
            </exception>
            <remarks>
            If this instance was not previously initialized for the current thread,
            accessing <see cref="P:System.Threading.ThreadLocal`1.Value" /> will attempt to initialize it. If an initialization function was
            supplied during the construction, that initialization will happen by invoking the function
            to retrieve the initial value for <see cref="P:System.Threading.ThreadLocal`1.Value" />.  Otherwise, the default value of
            <typeparamref name="T" /> will be used.
            </remarks>
        </member>
        <member name="P:System.Threading.ThreadLocal`1.IsValueCreated">
            <summary>
            Gets whether <see cref="P:System.Threading.ThreadLocal`1.Value" /> is initialized on the current thread.
            </summary>
            <exception cref="T:System.ObjectDisposedException">
            The <see cref="T:System.Threading.ThreadLocal`1" /> instance has been disposed.
            </exception>
        </member>
        <member name="P:System.Threading.ThreadLocal`1.ValueForDebugDisplay">
            <summary>Gets the value of the ThreadLocal&lt;T&gt; for debugging display purposes. It takes care of getting
            the value for the current thread in the ThreadLocal mode.</summary>
        </member>
        <member name="M:System.Threading.ThreadLocal`1.#ctor">
            <summary>
            Initializes the <see cref="T:System.Threading.ThreadLocal`1" /> instance.
            </summary>
        </member>
        <member name="M:System.Threading.ThreadLocal`1.#ctor(System.Func{`0})">
            <summary>
            Initializes the <see cref="T:System.Threading.ThreadLocal`1" /> instance with the
            specified <paramref name="valueFactory" /> function.
            </summary>
            <param name="valueFactory">
            The <see cref="T:System.Func{T}" /> invoked to produce a lazily-initialized value when
            an attempt is made to retrieve <see cref="P:System.Threading.ThreadLocal`1.Value" /> without it having been previously initialized.
            </param>
            <exception cref="T:System.ArgumentNullException">
            <paramref name="valueFactory" /> is a null reference (Nothing in Visual Basic).
            </exception>
        </member>
        <member name="M:System.Threading.ThreadLocal`1.Finalize">
            <summary>
            Releases the resources used by this <see cref="T:System.Threading.ThreadLocal{T}" /> instance.
            </summary>
        </member>
        <member name="M:System.Threading.ThreadLocal`1.Dispose">
            <summary>
            Releases the resources used by this <see cref="T:System.Threading.ThreadLocal{T}" /> instance.
            </summary>
            <remarks>
            Unlike most of the members of <see cref="T:System.Threading.ThreadLocal{T}" />, this method is not thread-safe.
            </remarks>
        </member>
        <member name="M:System.Threading.ThreadLocal`1.Dispose(System.Boolean)">
            <summary>
            Releases the resources used by this <see cref="T:System.Threading.ThreadLocal{T}" /> instance.
            </summary>
            <param name="disposing">
            A Boolean value that indicates whether this method is being called due to a call to <see cref="M:System.Threading.ThreadLocal`1.Dispose" />.
            </param>
            <remarks>
            Unlike most of the members of <see cref="T:System.Threading.ThreadLocal{T}" />, this method is not thread-safe.
            </remarks>
        </member>
        <member name="M:System.Threading.ThreadLocal`1.FindNextTypeIndex">
            <summary>
            Tries to get a unique index for the current instance of type T, it first tries to get it from the pool if it is not empty, otherwise it
            increments the global counter if it is still below the maximum, otherwise it fails and returns -1
            </summary>
            <returns>True if there is an index available, false otherwise</returns>
        </member>
        <member name="M:System.Threading.ThreadLocal`1.GetTypesFromIndex">
            <summary>
            Gets an array of types that will be used as generic parameters for the GenericHolder class
            </summary>
            <returns>The types array</returns>
        </member>
        <member name="M:System.Threading.ThreadLocal`1.ToString">
            <summary>Creates and returns a string representation of this instance for the current thread.</summary>
            <returns>The result of calling <see cref="M:System.Object.ToString" /> on the <see cref="P:System.Threading.ThreadLocal`1.Value" />.</returns>
            <exception cref="T:System.NullReferenceException">
            The <see cref="P:System.Threading.ThreadLocal`1.Value" /> for the current thread is a null reference (Nothing in Visual Basic).
            </exception>
            <exception cref="T:System.InvalidOperationException">
            The initialization function referenced <see cref="P:System.Threading.ThreadLocal`1.Value" /> in an improper manner.
            </exception>
            <exception cref="T:System.ObjectDisposedException">
            The <see cref="T:System.Threading.ThreadLocal`1" /> instance has been disposed.
            </exception>
            <remarks>
            Calling this method forces initialization for the current thread, as is the
            case with accessing <see cref="P:System.Threading.ThreadLocal`1.Value" /> directly.
            </remarks>
        </member>
        <member name="M:System.Threading.ThreadLocal`1.CreateValue">
            <summary>
            Private helper function to lazily create the value using the calueSelector if specified in the constructor or the default parameterless constructor
            </summary>
            <returns>Returns the boxed object</returns>
        </member>
        <member name="T:System.Threading.ThreadLocal`1.HolderBase">
            <summary>The base abstract class for the holder</summary>
        </member>
        <member name="T:System.Threading.ThreadLocal`1.TLSHolder">
            <summary>The TLS holder representation</summary>
        </member>
        <member name="T:System.Threading.ThreadLocal`1.GenericHolder`3">
            <summary>The generic holder representation</summary>
            <typeparam name="U">Dummy param</typeparam>
            <typeparam name="V">Dummy param</typeparam>
            <typeparam name="W">Dummy param</typeparam>
        </member>
        <member name="T:System.Threading.ThreadLocal`1.Boxed">
            <summary>wrapper to the actual value</summary>
        </member>
        <member name="T:System.Threading.ThreadLocalGlobalCounter">
            <summary>
            A seprate non generic class that contains a global counter for fast path instances for all Ts that has been created, and adds an upper limit for all instances
            that uses the fast path, if this limit has been reached, all new instances will use the slow path
            </summary>
        </member>
        <member name="M:System.IO.StreamExtensions.CopyToAsync(System.IO.Stream,System.IO.Stream)">
            <summary>
            Asynchronously reads the bytes from a source stream and writes them to a destination stream.
            </summary>
            <remarks>
            Copying begins at the current position in <paramref name="stream"/>.
            </remarks>
            <param name="stream">The source stream.</param>
            <param name="destination">The stream to which the contents of the source stream will be copied.</param>
            <returns>A task that represents the asynchronous copy operation.</returns>
            <exception cref="T:System.ArgumentNullException">
            <para>If <paramref name="stream"/> is <see langword="null"/>.</para>
            <para>-or-</para>
            <para>If <paramref name="destination"/> is <see langword="null"/>.</para>
            </exception>
            <exception cref="T:System.ObjectDisposedException">
            <para>If <paramref name="stream"/> is disposed.</para>
            <para>-or-</para>
            <para>If <paramref name="destination"/> is disposed.</para>
            </exception>
            <exception cref="T:System.NotSupportedException">
            <para>If <paramref name="stream"/> does not support reading.</para>
            <para>-or-</para>
            <para>If <paramref name="destination"/> does not support writing.</para>
            </exception>
        </member>
        <member name="M:System.IO.StreamExtensions.CopyToAsync(System.IO.Stream,System.IO.Stream,System.Int32)">
            <summary>
            Asynchronously reads the bytes from a source stream and writes them to a destination stream,
            using a specified buffer size.
            </summary>
            <remarks>
            Copying begins at the current position in <paramref name="stream"/>.
            </remarks>
            <param name="stream">The source stream.</param>
            <param name="destination">The stream to which the contents of the source stream will be copied.</param>
            <param name="bufferSize">The size, in bytes, of the buffer. This value must be greater than zero. The default size is 81920.</param>
            <returns>A task that represents the asynchronous copy operation.</returns>
            <exception cref="T:System.ArgumentNullException">
            <para>If <paramref name="stream"/> is <see langword="null"/>.</para>
            <para>-or-</para>
            <para>If <paramref name="destination"/> is <see langword="null"/>.</para>
            </exception>
            <exception cref="T:System.ArgumentOutOfRangeException">
            If <paramref name="bufferSize"/> is negative or zero.
            </exception>
            <exception cref="T:System.ObjectDisposedException">
            <para>If <paramref name="stream"/> is disposed.</para>
            <para>-or-</para>
            <para>If <paramref name="destination"/> is disposed.</para>
            </exception>
            <exception cref="T:System.NotSupportedException">
            <para>If <paramref name="stream"/> does not support reading.</para>
            <para>-or-</para>
            <para>If <paramref name="destination"/> does not support writing.</para>
            </exception>
        </member>
        <member name="M:System.IO.StreamExtensions.CopyToAsync(System.IO.Stream,System.IO.Stream,System.Int32,System.Threading.CancellationToken)">
            <summary>
            Asynchronously reads the bytes from a source stream and writes them to a destination stream,
            using a specified buffer size and cancellation token.
            </summary>
            <remarks>
            <para>If the operation is canceled before it completes, the returned task contains the <see cref="F:System.Threading.Tasks.TaskStatus.Canceled"/>
            value for the <see cref="P:System.Threading.Tasks.Task.Status"/> property.</para>
            <para>
            Copying begins at the current position in <paramref name="stream"/>.
            </para>
            </remarks>
            <param name="stream">The source stream.</param>
            <param name="destination">The stream to which the contents of the source stream will be copied.</param>
            <param name="bufferSize">The size, in bytes, of the buffer. This value must be greater than zero. The default size is 81920.</param>
            <param name="cancellationToken">The token to monitor for cancellation requests. The default value is <see cref="P:System.Threading.CancellationToken.None"/>.</param>
            <returns>A task that represents the asynchronous copy operation.</returns>
            <exception cref="T:System.ArgumentNullException">
            <para>If <paramref name="stream"/> is <see langword="null"/>.</para>
            <para>-or-</para>
            <para>If <paramref name="destination"/> is <see langword="null"/>.</para>
            </exception>
            <exception cref="T:System.ArgumentOutOfRangeException">
            If <paramref name="bufferSize"/> is negative or zero.
            </exception>
            <exception cref="T:System.ObjectDisposedException">
            <para>If <paramref name="stream"/> is disposed.</para>
            <para>-or-</para>
            <para>If <paramref name="destination"/> is disposed.</para>
            </exception>
            <exception cref="T:System.NotSupportedException">
            <para>If <paramref name="stream"/> does not support reading.</para>
            <para>-or-</para>
            <para>If <paramref name="destination"/> does not support writing.</para>
            </exception>
        </member>
        <member name="M:System.IO.StreamExtensions.FlushAsync(System.IO.Stream)">
            <summary>
            Asynchronously clears all buffers for a stream and causes any buffered data to be written to the underlying device.
            </summary>
            <remarks>
            If a derived class does not flush the buffer in its implementation of the <see cref="M:System.IO.Stream.Flush"/> method,
            the <see cref="M:System.IO.StreamExtensions.FlushAsync(System.IO.Stream)"/> method will not flush the buffer.
            </remarks>
            <param name="stream">The stream to flush.</param>
            <returns>A task that represents the asynchronous flush operation.</returns>
            <exception cref="T:System.ArgumentNullException">If <paramref name="stream"/> is <see langword="null"/>.</exception>
            <exception cref="T:System.ObjectDisposedException">If <paramref name="stream"/> has been disposed.</exception>
        </member>
        <member name="M:System.IO.StreamExtensions.FlushAsync(System.IO.Stream,System.Threading.CancellationToken)">
            <summary>
            Asynchronously clears all buffers for a stream and causes any buffered data to be written to the underlying device,
            and monitors cancellation requests.
            </summary>
            <remarks>
            <para>If the operation is canceled before it completes, the returned task contains the <see cref="F:System.Threading.Tasks.TaskStatus.Canceled"/>
            value for the <see cref="P:System.Threading.Tasks.Task.Status"/> property.</para>
            <para>
            If a derived class does not flush the buffer in its implementation of the <see cref="M:System.IO.Stream.Flush"/> method,
            the <see cref="M:System.IO.StreamExtensions.FlushAsync(System.IO.Stream)"/> method will not flush the buffer.
            </para>
            </remarks>
            <param name="stream">The stream to flush.</param>
            <param name="cancellationToken">The token to monitor for cancellation requests. The default value is <see cref="P:System.Threading.CancellationToken.None"/>.</param>
            <returns>A task that represents the asynchronous flush operation.</returns>
            <exception cref="T:System.ArgumentNullException">If <paramref name="stream"/> is <see langword="null"/>.</exception>
            <exception cref="T:System.ObjectDisposedException">If <paramref name="stream"/> has been disposed.</exception>
        </member>
        <member name="M:System.IO.StreamExtensions.ReadAsync(System.IO.Stream,System.Byte[],System.Int32,System.Int32)">
            <summary>
            Asynchronously reads a sequence of bytes from a stream and advances the position within the stream by the number of bytes read.
            </summary>
            <remarks>
            Use the <see cref="P:System.IO.Stream.CanRead"/> property to determine whether the stream instance supports reading.
            </remarks>
            <param name="stream">The stream to read data from.</param>
            <param name="buffer">The buffer to write the data into.</param>
            <param name="offset">The byte offset in <paramref name="buffer"/> at which to begin writing data from the stream.</param>
            <param name="count">The maximum number of bytes to read.</param>
            <returns>
            A task that represents the asynchronous read operation. When the task completes successfully, the <see cref="P:System.Threading.Tasks.Task`1.Result"/>
            property contains the total number of bytes read into the buffer. The result value can be less than the number of bytes requested if
            the number of bytes currently available is less than the requested number, or it can be 0 (zero) if the end of the stream has been reached.
            </returns>
            <exception cref="T:System.ArgumentNullException">
            <para>If <paramref name="stream"/> is <see langword="null"/>.</para>
            <para>-or-</para>
            <para>If <paramref name="buffer"/> is <see langword="null"/>.</para>
            </exception>
            <exception cref="T:System.ArgumentOutOfRangeException">
            <para>If <paramref name="offset"/> is negative.</para>
            <para>-or-</para>
            <para>If <paramref name="count"/> is negative.</para>
            </exception>
            <exception cref="T:System.ArgumentException">
            If the sum of <paramref name="offset"/> and <paramref name="count"/> is larger than the buffer length.
            </exception>
            <exception cref="T:System.NotSupportedException">If <paramref name="stream"/> does not support reading.</exception>
            <exception cref="T:System.ObjectDisposedException">If <paramref name="stream"/> has been disposed.</exception>
            <exception cref="T:System.InvalidOperationException">If <paramref name="stream"/> is currently in use by a previous read operation.</exception>
        </member>
        <member name="M:System.IO.StreamExtensions.ReadAsync(System.IO.Stream,System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)">
            <summary>
            Asynchronously reads a sequence of bytes from a stream, advances the position within the stream by the number of bytes read,
            and monitors cancellation requests.
            </summary>
            <remarks>
            Use the <see cref="P:System.IO.Stream.CanRead"/> property to determine whether the stream instance supports reading.
            <para>
            If the operation is canceled before it completes, the returned task contains the <see cref="F:System.Threading.Tasks.TaskStatus.Canceled"/>
            value for the <see cref="P:System.Threading.Tasks.Task.Status"/> property.
            </para>
            </remarks>
            <param name="stream">The stream to read data from.</param>
            <param name="buffer">The buffer to write the data into.</param>
            <param name="offset">The byte offset in <paramref name="buffer"/> at which to begin writing data from the stream.</param>
            <param name="count">The maximum number of bytes to read.</param>
            <param name="cancellationToken">The token to monitor for cancellation requests. The default value is <see cref="P:System.Threading.CancellationToken.None"/>.</param>
            <returns>
            A task that represents the asynchronous read operation. When the task completes successfully, the <see cref="P:System.Threading.Tasks.Task`1.Result"/>
            property contains the total number of bytes read into the buffer. The result value can be less than the number of bytes requested if
            the number of bytes currently available is less than the requested number, or it can be 0 (zero) if the end of the stream has been reached.
            </returns>
            <exception cref="T:System.ArgumentNullException">
            <para>If <paramref name="stream"/> is <see langword="null"/>.</para>
            <para>-or-</para>
            <para>If <paramref name="buffer"/> is <see langword="null"/>.</para>
            </exception>
            <exception cref="T:System.ArgumentOutOfRangeException">
            <para>If <paramref name="offset"/> is negative.</para>
            <para>-or-</para>
            <para>If <paramref name="count"/> is negative.</para>
            </exception>
            <exception cref="T:System.ArgumentException">
            If the sum of <paramref name="offset"/> and <paramref name="count"/> is larger than the buffer length.
            </exception>
            <exception cref="T:System.NotSupportedException">If <paramref name="stream"/> does not support reading.</exception>
            <exception cref="T:System.ObjectDisposedException">If <paramref name="stream"/> has been disposed.</exception>
            <exception cref="T:System.InvalidOperationException">If <paramref name="stream"/> is currently in use by a previous read operation.</exception>
        </member>
        <member name="M:System.IO.StreamExtensions.WriteAsync(System.IO.Stream,System.Byte[],System.Int32,System.Int32)">
            <summary>
            Asynchronously writes a sequence of bytes to a stream and advances the position within the stream by the number of bytes written.
            </summary>
            <remarks>
            Use the <see cref="P:System.IO.Stream.CanWrite"/> property to determine whether the stream instance supports writing.
            </remarks>
            <param name="stream">The stream to write data to.</param>
            <param name="buffer">The buffer to read the data from.</param>
            <param name="offset">The zero-based byte offset in buffer from which to begin copying bytes to the stream.</param>
            <param name="count">The maximum number of bytes to write.</param>
            <returns>
            A task that represents the asynchronous write operation.
            </returns>
            <exception cref="T:System.ArgumentNullException">
            <para>If <paramref name="stream"/> is <see langword="null"/>.</para>
            <para>-or-</para>
            <para>If <paramref name="buffer"/> is <see langword="null"/>.</para>
            </exception>
            <exception cref="T:System.ArgumentOutOfRangeException">
            <para>If <paramref name="offset"/> is negative.</para>
            <para>-or-</para>
            <para>If <paramref name="count"/> is negative.</para>
            </exception>
            <exception cref="T:System.ArgumentException">
            If the sum of <paramref name="offset"/> and <paramref name="count"/> is larger than the buffer length.
            </exception>
            <exception cref="T:System.NotSupportedException">If <paramref name="stream"/> does not support writing.</exception>
            <exception cref="T:System.ObjectDisposedException">If <paramref name="stream"/> has been disposed.</exception>
            <exception cref="T:System.InvalidOperationException">If <paramref name="stream"/> is currently in use by a previous write operation.</exception>
        </member>
        <member name="M:System.IO.StreamExtensions.WriteAsync(System.IO.Stream,System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)">
            <summary>
            Asynchronously writes a sequence of bytes to a stream, advances the position within the stream by the number of bytes written,
            and monitors cancellation requests.
            </summary>
            <remarks>
            Use the <see cref="P:System.IO.Stream.CanWrite"/> property to determine whether the stream instance supports writing.
            <para>
            If the operation is canceled before it completes, the returned task contains the <see cref="F:System.Threading.Tasks.TaskStatus.Canceled"/>
            value for the <see cref="P:System.Threading.Tasks.Task.Status"/> property.
            </para>
            </remarks>
            <param name="stream">The stream to write data to.</param>
            <param name="buffer">The buffer to read the data from.</param>
            <param name="offset">The zero-based byte offset in buffer from which to begin copying bytes to the stream.</param>
            <param name="count">The maximum number of bytes to write.</param>
            <param name="cancellationToken">The token to monitor for cancellation requests. The default value is <see cref="P:System.Threading.CancellationToken.None"/>.</param>
            <returns>
            A task that represents the asynchronous write operation.
            </returns>
            <exception cref="T:System.ArgumentNullException">
            <para>If <paramref name="stream"/> is <see langword="null"/>.</para>
            <para>-or-</para>
            <para>If <paramref name="buffer"/> is <see langword="null"/>.</para>
            </exception>
            <exception cref="T:System.ArgumentOutOfRangeException">
            <para>If <paramref name="offset"/> is negative.</para>
            <para>-or-</para>
            <para>If <paramref name="count"/> is negative.</para>
            </exception>
            <exception cref="T:System.ArgumentException">
            If the sum of <paramref name="offset"/> and <paramref name="count"/> is larger than the buffer length.
            </exception>
            <exception cref="T:System.NotSupportedException">If <paramref name="stream"/> does not support writing.</exception>
            <exception cref="T:System.ObjectDisposedException">If <paramref name="stream"/> has been disposed.</exception>
            <exception cref="T:System.InvalidOperationException">If <paramref name="stream"/> is currently in use by a previous write operation.</exception>
        </member>
    </members>
</doc>
